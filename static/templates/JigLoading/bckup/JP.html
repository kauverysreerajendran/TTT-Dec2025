
{% extends "base.html" %} {% load static %} {% block content %}
{% load stock_filters %} 

<style>
 /* Tray validation message styles (non-destructive) */
.tray-validation-message {
  margin-top: 6px;
  font-size: 12px;
  line-height: 1;
  padding: 6px 8px;
  border-radius: 6px;
  display: block;
  width: 100%;
  box-sizing: border-box;
}
.tray-validation-success {
  background: #e8f5e8;
  color: #175d26;
  border: 1px solid #28a745;
}
.tray-validation-error {
  background: #fff3f3;
  color: #8a1f1f;
  border: 1px solid #dc3545;
}
.tray-id-loading {
  margin-top:6px;
  font-size:11px;
  color:#6c757d;
  display:flex;
  align-items:center;
  gap:6px;
}
/* Tray ID error styling - moved below .delink-grid > div */
.tray-id-error {
  color: #d32f2f;
  font-size: 11px;
  font-weight: bold;
  background-color: #ffebee;
  padding: 4px 6px;
  border-radius: 4px;
  margin-top: 4px;
}


/* ensure the input parent keeps space for messages */
.delink-grid > div { position: relative; }


  /* UNIFIED: Simple solid colors matching model slider - no gradients or complex borders */
.delink-grid > div.bg-1,
.delink-grid > .lot-color-1 { background: #e8f5e8 !important; border: 1px solid #ddd !important; }
.delink-grid > div.bg-2,
.delink-grid > .lot-color-2 { background: #e3f2fd !important; border: 1px solid #ddd !important; }
.delink-grid > div.bg-3,
.delink-grid > .lot-color-3 { background: #fff3e0 !important; border: 1px solid #ddd !important; }
.delink-grid > div.bg-4,
.delink-grid > .lot-color-4 { background: #f3e5f5 !important; border: 1px solid #ddd !important; }
.delink-grid > div.bg-5,
.delink-grid > .lot-color-5 { background: #fff8e1 !important; border: 1px solid #ddd !important; }

/* Ensure text and input contrast for colored cells */
.delink-grid > div.bg-1 input,
.delink-grid > div.bg-2 input,
.delink-grid > div.bg-3 input,
.delink-grid > div.bg-4 input,
.delink-grid > div.bg-5 input {
  background: transparent !important;
  color: #1f2937 !important;
  font-weight: 600;
}


  /* De-link Tray Scan UI (visual-only, non-destructive) */
.delink-section {
  margin: 8px 6px 14px 6px;
  font-family: "Segoe UI", Arial, sans-serif;
}
.delink-header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
  padding:6px 8px;
  color:#374151;
  font-weight:700;
  font-size:14px;
  margin-top: -15px;
}
.delink-header small { font-weight:500; color:#6b7280; margin-left:6px; }

/* Grid of tray inputs (3 columns like your screenshot) */
.delink-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr); /* show 6 tray inputs per row on wide screens */
  gap: 8px;
  align-items: center;
  margin-top: -15px;
  padding: 0px;
}

/* class added by the script below to hide unwanted UI-only items */
.delink-grid > .ui-hidden {
  display: none !important;
  width: 0 !important;
  height: 0 !important;
  margin: 0 !important;
  padding: 0 !important;
  border: none !important;
  visibility: hidden !important;
}

/* cell adjustments - make them compact */
.delink-grid > div {
  padding: 6px 8px;
  border-radius: 6px;
  min-height: 36px;       /* reduced height */
  display: flex;
  align-items: center;
  box-sizing: border-box;
  border: 1px solid rgba(15,23,42,0.06);
  overflow:hidden;
}

/* Inputs inside cells: compact and full width */
.delink-grid input[type="text"],
.delink-grid .tray-input {
  width: 100%;
  border: none;
  outline: none;
  background: transparent;
  padding: 6px 8px;      /* reduced padding */
  font-size: 13px;
  color: #2f3742;
  font-weight:600;
  height: 28px;          /* consistent small height */
  box-sizing: border-box;
}

/* Make inputs occupy full width once serial columns hidden */
.delink-grid > div:not(.ui-hidden) .tray-input,
.delink-grid > div:not(.ui-hidden) input[type="text"] {
  width: 100%;
  box-sizing: border-box;
}



/* Hide the S.No/Tray ID header cells visually if present */
.delink-grid > .ui-hidden { display:none !important; }

/* Responsive fallbacks */
@media (max-width:1200px) {
  .delink-grid { grid-template-columns: repeat(4, 1fr); } /* 4 per row */
}
@media (max-width:900px) {
  .delink-grid { grid-template-columns: repeat(3, 1fr); } /* 3 per row */
}
@media (max-width:600px) {
  .delink-grid { grid-template-columns: repeat(2, 1fr); } /* 2 per row */
}
@media (max-width:420px) {
  .delink-grid { grid-template-columns: 1fr; } /* 1 per row */
}

/* Inputs inside cells: compact and full width */
.delink-grid input[type="text"],
.delink-grid .tray-input {
  width: 100%;
  border: none;
  outline: none;
  background: transparent;
  padding: 6px 8px;      /* reduced padding */
  font-size: 13px;
  color: #2f3742;
  font-weight:600;
  height: 28px;          /* consistent small height */
  box-sizing: border-box;
}

/* small helper to ensure grid continues to look good */
#delinkTrayTable {
  gap: 8px;
}

/* Placeholder style */
.delink-grid input[type="text"]::placeholder {
  color: rgba(47,55,66,0.45);
  font-weight:500;
  font-size:13px;
}

/* Responsive: 2 cols on small screens, 1 col on very small */
@media (max-width:900px) {
  .delink-grid { grid-template-columns: repeat(2, 1fr); }
}
@media (max-width:460px) {
  .delink-grid { grid-template-columns: 1fr; }
}

/* Model card color palette for visual distinction */
/* UNIFIED: Simple solid backgrounds for model items to match tray cells */
.model-loaded-item.bg-1 { background: #e8f5e8 !important; }
.model-loaded-item.bg-2 { background: #e3f2fd !important; }
.model-loaded-item.bg-3 { background: #fff3e0 !important; }
.model-loaded-item.bg-4 { background: #f3e5f5 !important; }
.model-loaded-item.bg-5 { background: #fff8e1 !important; }
/* Add more as needed */

    .status-icon.active.pass {
    background: linear-gradient(135deg, #4caf50 0%, #2e7d32 100%) !important;
    border-color: #2e7d32 !important;
    box-shadow: 0 4px 16px rgba(76, 175, 80, 0.4) !important;
  }

  
/* ========== Tablet override â€” paste at file end (after other table styles) ========== */
/* --- Tablet: freeze first 3 columns consistently with desktop --- */
@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {

*{
  font-size: 20px !important; /* Increase font size for better readability */
}

:root { --app-font-size: 20px; }
.rounded-circle{
  padding: 17px !important;
}
.model-image-tooltip{
  transform: translateX(-25%) !important;
  top: 45% !important;
  z-index: 500000 !important; /* high so it sits above table & scrollbar */

}


  /* Core layout blocks */
  .content-wrapper,
  .card, .card-body,
  .table-responsive,
  #order-listing,
  #trayScanModal_DayPlanning,
  .tray-scan-modal-DayPlanning,
  .pagination-wrapper {
    font-size: var(--app-font-size) !important;
    line-height: 1.35 !important;
  }

  /* Table headings / cells / icons */
  #order-listing th,
  #order-listing td,
  #order-listing thead th {
    font-size: var(--app-font-size) !important;
    vertical-align: middle !important;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  /* Ensure heading/title and date controls match */
  h4.text-left.mt-0.mb-3,
  .calendar-bar .date-input-group label,
  .calendar-bar .date-input-group input,
  #search-date-range-simple,
  #clear-date-filter-simple,
  .calendar-btn,
  #trayScanModal_DayPlanning input.form-control,#trayValidateBtn,
  #trayScanModal_DayPlanning table th, #trayScanModal_DayPlanning table td,
  #modalModelNo_DayPlanning
 {
    font-size: var(--app-font-size) !important;
  }  

  /* Reserve space for filter icons in header cells */
#order-listing th {
  position: relative;
  overflow: visible !important;
  white-space: normal !important; /* allow wrapping */
}

/* Ensure filter icons always stay to the right */
#order-listing th .fa-filter {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px !important;
  opacity: 0.8;
  cursor: pointer;
}

  /* Column 1 */
  #order-listing th:nth-child(1),
  #order-listing td:nth-child(1) {
    position: sticky;
    left: 0 !important;
    min-width: 90px !important;
    max-width: 90px !important;
    background: #f7fafd;
    z-index: 30;
  }

  /* Column 2 */
  #order-listing th:nth-child(2),
  #order-listing td:nth-child(2) {
    position: sticky;
    left: 90px !important;   /* = width of col1 */
    min-width: 125px !important;
    max-width: 125px !important;
    background: #f7fafd;
    z-index: 25;
  }

  /* Column 3 */
  #order-listing th:nth-child(3),
  #order-listing td:nth-child(3) {
    position: sticky;
    left: 215px !important;  /* 75 (col1) + 100 (col2 min) */
    min-width: 140px !important;
    max-width: 140px !important;
    background: #f7fafd;
    z-index: 20;
  }

  /* Sticky header */
  #order-listing thead th {
    position: sticky;
    top: 0;
    z-index: 40;
    background: #028084 !important;
    color: #e5fcff !important;
  }
}

@media (pointer: coarse) and (min-width: 680px) and (max-width: 1400px) {
  .table-container {
    overflow-x: auto;
  }

  /* Other columns (fit remaining space) */
  #order-listing th:nth-child(4)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(5)  { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(6)  { min-width: 135px !important; max-width: 135px !important; }
  #order-listing th:nth-child(7)  { min-width: 115px !important; max-width: 125px !important; }
  #order-listing th:nth-child(8)  { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(9)  { min-width: 140px !important; max-width: 145px !important; }
  #order-listing th:nth-child(10) { min-width: 120px !important; max-width: 120px !important; }
  #order-listing th:nth-child(11) { min-width: 120px !important; max-width: 130px !important; }
  #order-listing th:nth-child(12) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(13) { min-width: 120px !important; max-width: 130px !important; }
  #order-listing th:nth-child(14) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(15) { min-width: 115px !important; max-width: 115px !important; }
  #order-listing th:nth-child(16) { min-width: 130px !important; max-width: 150px !important; }
  #order-listing th:nth-child(17) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(18) { min-width: 130px !important; max-width: 130px !important; }
  #order-listing th:nth-child(19) { min-width: 140px !important; max-width: 140px !important; }
  #order-listing th:nth-child(20) { min-width: 130px !important; max-width: 130px !important; }


  /* Prevent overlap */
  #order-listing th:nth-child(-n+3),
  #order-listing td:nth-child(-n+3) {
    z-index: 45 !important;
  }

  /* Hide hidden columns */
  #order-listing th[hidden],
  #order-listing td[hidden] {
    display: none !important;
  }
}
    .model-image-tooltip {
    position: fixed !important;
    z-index: 99999 !important;
    /* Optionally, add a box-shadow for visibility */
    box-shadow: 0 4px 24px rgba(0,0,0,0.18);
  }
      /* Add to your CSS file for Excel-like grid lines */
.table-bordered th, .table-bordered td {
  border: 1px solid #d9dedf !important;
}
  /* Make the table header sticky */
thead th {
  position: sticky;
  top: 0;
  background-color: white; /* or your table header bg color */
  z-index: 5; /* ensure it stays above the table rows */
  
}

#order-listing thead th {
  height: 38px !important; /* Increase as needed */
  background: #028084 !important;
  color: #e5fcff !important;
  vertical-align: middle !important;
}
/* style for hol/unhold row - blurred bg */
#order-listing tr:last-child td {
  margin-bottom: 0 !important;
  padding-bottom: 0 !important;
  /* background: #f4f3f3 !important; */
}
/* Gird line color combination */
#order-listing th,
#order-listing td {
  border-right: 1.5px solid #bababa !important; /* Vertical lines: blue */
  border-bottom: 1.5px solid #121413 !important; /* Horizontal lines: green */
}

  
/* Default: Desktop/Laptop (wider columns for larger font) - server */
/* #order-listing th:nth-child(1) {
  min-width: 90px;
  max-width: 90px;
} */ /* S.No */
/* #order-listing th:nth-child(2) {
  min-width: 90px;
  max-width: 100px;
} */ /* Last Updated */
/* #order-listing th:nth-child(3) {
  min-width: 90px;
  max-width: 120px;
} */ /* Plating */
#order-listing th:nth-child(4) {
  min-width: 110px;
  max-width: 120px;
} /* Polishing Stk No */
#order-listing th:nth-child(5) {
  min-width: 90px;
  max-width: 100px;
} /* Plating Color */
#order-listing th:nth-child(6) {
  min-width: 100px;
  max-width: 110px;
} /* Category */
#order-listing th:nth-child(7) {
  min-width: 90px;
  max-width: 95px;
} /* Polish Finish */
#order-listing th:nth-child(8) {
  min-width: 110px;
  max-width: 110px;
} /* Version */
#order-listing th:nth-child(9) {
  min-width: 105px;
  max-width: 105px;
} /* Tray Cate-Capacity */
#order-listing th:nth-child(10) {
  min-width: 90px;
  max-width: 100px;
} /* Source */
#order-listing th:nth-child(11) {
  min-width: 115px;
  max-width: 115px;
} /* No of Trays */
#order-listing th:nth-child(12) {
  min-width: 100px;
  max-width: 105px;
} /* Input Qty */
#order-listing th:nth-child(13) {
  min-width: 95px;
  max-width: 100px;
} /* Process Status */
#order-listing th:nth-child(14) {
  min-width: 95px;
  max-width: 100px;
} /*  Action */
#order-listing th:nth-child(15) {
  min-width: 90px;
  max-width: 100px;
} /* Lot Status */
#order-listing th:nth-child(16) {
  min-width: 110px;
  max-width: 110px;
} /* Current Stage */
#order-listing th:nth-child(17) {
  min-width: 110px;
  max-width: 100px;
} /* Remarks */
#order-listing th:nth-child(18) {
  min-width: 100px;
  max-width: 110px;
}

@media (min-width: 600px) and (max-width: 900px) {
  #order-listing {
    table-layout: auto !important; /* Let columns auto-fit content */
    width: 100% !important;
    min-width: unset !important;
    max-width: 100vw !important;
  }
  /* Adjust width for all headings (th) and cells (td) */
  #order-listing th,
  #order-listing td {
    min-width: 160px !important;
    max-width: 260px !important;
    width: 180px !important;
  }
  #order-listing th {
    position: relative;
    padding-right: 48px !important; /* More space for filter icon */
    white-space: normal !important;
    overflow: visible !important;
    text-overflow: ellipsis;
  }
  #order-listing th .fa-filter {
    position: absolute;
    right: 18px !important;
    top: 50%;
    transform: translateY(-50%);
    z-index: 2;
    background: transparent;
    pointer-events: auto;
  }
}
/* Right-align filter icons */
#order-listing th .fa-filter {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  opacity: 0.7;
  cursor: pointer;
  transition: opacity 0.2s;
}

#order-listing th .fa-filter:hover {
  opacity: 1;
}


  
#order-listing th:last-child,
#order-listing td:last-child {
  border-right: none;
  max-width: 95px;
  min-width: 100px;
}
/* Overall Table Shrink */
#order-listing tr,
#order-listing td,
#order-listing th {
  height: 20px !important;
  padding-top: 2px !important;
  padding-bottom: 2px !important;
  padding-left: 6px !important;
  padding-right: 6px !important;
}
/* Table heading font size */
/* Add this at the end of your <style> block in DP_PickTable.html */

/* Professional table header styling with proper text wrapping */
#order-listing th {
  position: relative;
  padding: 8px 12px 8px 16px !important;
  text-align: left !important;
  vertical-align: middle !important;
  white-space: normal !important;
  line-height: 1.3 !important;
  word-break: keep-all !important;
  hyphens: none !important;
  /* font-size: 13px; */
  /* font-weight: 600 !important; */
  background: #028084 !important;
  color: #e5fcff !important;
  border-bottom: 2.5px solid #bdbdbd !important;
  /* min-width: 80px;
  max-width: 140px; */
   overflow-wrap: break-word;
  word-wrap: break-word;
   z-index: 20 !important;
}

/* Make sure header cells for sticky columns are always above body cells */
/* Fix: Prevent shadow/rows from showing behind sticky columns while scrolling */
#order-listing th:nth-child(-n+3),
#order-listing td:nth-child(-n+3) {
  z-index: 30 !important; 
box-shadow: 2px 0 8px rgba(0,0,0,0.04);
}

/* Prevent sticky columns from overlapping sticky header */
#order-listing td:nth-child(-n+3) {
  z-index: 11 !important;
}
  /* Make the first column sticky and opaque */
#order-listing td:first-child,
#order-listing th:first-child {
  position: sticky;
  left: 0;
  background: #fff;      /* Or match your table background */
  z-index: 2;            /* Above blurred rows */
  box-shadow: 2px 0 4px rgba(0,0,0,0.03); /* Optional: subtle shadow */
}
/* Force specific table headers to wrap onto two lines */
#order-listing th:nth-child(4),   /* Polishing Stk No */
#order-listing th:nth-child(5),   /* Plating Color */
#order-listing th:nth-child(7),   /* Polish Finish */
#order-listing th:nth-child(9),   /* Tray Cate-Capacity */
#order-listing th:nth-child(11),  /* No of Tray */
#order-listing th:nth-child(12),  /* Input Qty */
#order-listing th:nth-child(13)   /* Process Status */ {
  white-space: normal !important;
  line-height: 1.2 !important;
  word-break: break-word !important;

  text-align: center;
  vertical-align: middle;
  padding-top: 5px !important;
  padding-bottom: 5px !important;
}
/* Freeze style for 1st - 3 columns */
/* --- Freeze first 3 columns and table header for #order-listing --- */
#order-listing {
  position: relative;
  border-collapse: separate !important;
  border-spacing: 0;
  background: #fff;
  /* Ensure enough left padding for sticky columns */
}

#order-listing th,
#order-listing td {
  background-clip: padding-box;
  /* Prevent overlap artifacts */
  z-index: 1;
}

/* Sticky header */
#order-listing thead th {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #028084 !important;
  color: #e5fcff !important;
}

/* Freeze 1st column */
#order-listing th:nth-child(1),
#order-listing td:nth-child(1) {
  position: sticky;
  left: 0 !important;
  z-index: 12; /* Above header */
  background: #f7fafd;
  min-width: 75px;
  max-width: 75px;
}

/* Freeze 2nd column - Last Updated*/
#order-listing th:nth-child(2),
#order-listing td:nth-child(2) {
  position: sticky;
  left: 75px; /* Match min-width of 1st col */
  z-index: 12;
  background: #f7fafd;
  min-width: 100px; /* Increased width */
  max-width: 110px; /* Increased width */
}

/* Freeze 3rd column */
#order-listing th:nth-child(3),
#order-listing td:nth-child(3) {
  position: sticky;
  left: 175px; /* 100px (1st) + 90px (2nd) */
  z-index: 12;
  background: #f7fafd;
  min-width: 130px; /* Increased width 100 - old value*/
  max-width: 140px; /* Increased width  110 - old value*/
}

/* Prevent sticky columns from overlapping sticky header */
#order-listing th:nth-child(-n + 3) {
  z-index: 12;
}
#order-listing td:nth-child(-n + 3) {
  z-index: 11;
}

/* Ensure sticky columns and header work together */
#order-listing th,
#order-listing td {
  box-sizing: border-box;
  /* Prevent content shake */
  /* overflow: hidden; */
  text-overflow: ellipsis;
  white-space: nowrap;
}



    .blurred-heading, .blurred-cell {
    filter: blur(2px) grayscale(0.7) opacity(0.6);
    pointer-events: none !important;
    user-select: none;
    cursor: not-allowed;
    background: #f5f5f5 !important;
  }
    /* Show remark tooltip above the trigger instead of below */
  .remark-tooltip {
    top: auto !important;
    bottom: 110% !important;
  }
#trayScanDetails.table-grid {
  display: grid !important;
  grid-template-columns: 94px 175px 150px !important;
  gap: 0px !important;
  max-height: 300px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
  padding-right: 10px;
  margin-top: 10px;
  border: 1px solid #ddd;
}
 
#trayScanModal{
overflow: scroll !important;
width: 435px !important;
}
#trayScanDetails.table-grid::-webkit-scrollbar {
  width: 8px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}
 
#trayScanDetails.table-grid::-webkit-scrollbar-thumb:hover {
  background: #555;
}
 
 
.tray-scan-modal.open {
  width:500px !important;
}
/* For the 4-column layout (with validation status) */
#trayScanDetails.table-grid.four-column {
  grid-template-columns: 50px 1fr 100px 140px !important;
  overflow-y: auto !important;
  overflow-x: hidden !important;
}
 
/* Styling individual grid cells, only inside trayScanDetails */
#trayScanDetails.table-grid > div {
  background: #f7f7f7;
  padding: 8px 12px;
  font-size: 12px;
  border: 1px solid #ddd;
  margin: 0; /* reset any margin from <p> or others */
}
 
/* S.no column specific styling */
#trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
  text-align: center;
  font-weight: 600;
  padding: 8px 4px; /* Reduced horizontal padding for S.no */
}
 
/* For mobile responsiveness */
@media (max-width: 768px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 45px 1fr 1fr !important; /* Even smaller S.no column on mobile */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 40px 1fr 80px 100px !important;
  }
  #trayScanDetails.table-grid > div:nth-child(3n+1):not(:nth-child(-n+4)) {
    padding: 6px 2px; /* Further reduced padding on mobile */
    font-size: 11px;
  }
}
 
/* For very small screens */
@media (max-width: 480px) {
  #trayScanDetails.table-grid {
    grid-template-columns: 35px 1fr 80px !important; /* Minimal S.no column */
  }
  #trayScanDetails.table-grid.four-column {
    grid-template-columns: 30px 1fr 70px 90px !important;
  }
}
      /* UNIFIED: Lot ID Colors matching bg-* classes (removed lot-color-6 for consistency) */
.lot-color-1 { background-color: #e8f5e8 !important; border: 1px solid #ddd !important; } /* Light Green */
.lot-color-2 { background-color: #e3f2fd !important; border: 1px solid #ddd !important; } /* Light Blue */
.lot-color-3 { background-color: #fff3e0 !important; border: 1px solid #ddd !important; } /* Light Orange */
.lot-color-4 { background-color: #f3e5f5 !important; border: 1px solid #ddd !important; } /* Light Purple */
.lot-color-5 { background-color: #fff8e1 !important; border: 1px solid #ddd !important; } /* Light Yellow */

/* Color legend styling */
.lot-legend {
  margin-top: 10px; 
  font-size: 12px; 
  display: flex; 
  gap: 10px; 
  flex-wrap: wrap;
}

.lot-legend span {
  padding: 2px 8px; 
  border-radius: 4px; 
  border: 1px solid #ccc;
  font-weight: bold;
}
/* Modal Base Styles */
.right-slide-modal {
  position: fixed;
  top: 0;
  right: -100%;
  width: 100%;
  max-width: 650px;
  height: 100%;
  background: #ffffff;
  box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
  transition: right 0.4s ease, opacity 0.3s ease;
  z-index: 10500;
  overflow-y: auto;
  font-family: 'Segoe UI', sans-serif;
  border-radius: 16px 0 0 16px;
}


/* Center and float the right-slide-modal, prevent cropping on small screens */
.right-slide-modal.open {
  position: fixed;
  left: 50%;
  top: 50%;
  right: auto !important;
  transform: translate(-50%, -50%);
  margin: 0;
  opacity: 1;
  max-width: 1300px;        /* Wider modal */
  width: 98vw;              /* Responsive width */
  min-height: 80vh;         /* Prevent cropping top/bottom */
  max-height: 98vh;         /* Prevent cropping bottom/top */
  height: auto;
  border-radius: 16px;
  box-shadow: 0 4px 24px rgba(0,0,0,0.18);
  background: #fff;
  z-index: 10500;
  display: block;
  overflow-y: auto;         /* Allow scrolling if content overflows */
  overflow-x: hidden;
}

/* Responsive: On small screens, modal fills most of viewport */
@media (max-width: 900px) {
  .right-slide-modal.open {
    max-width: 99vw;
    min-height: 90vh;
    max-height: 99vh;
    border-radius: 8px;
  }
}

/* Flexible modal content */
.right-slide-content {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  min-height: 100%;
  height: 60vh;
  padding: 10px;
  box-sizing: border-box;
}

/* Make tray sections flexible */
#delinkTrayTable, #halfFilledTrayTable {
  flex-grow: 1;
  min-height: 100px;
  background: transparent;
}

#halfFilledTraySection {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  margin-top: 10px;
}

/* Make form sections and headers responsive */
.form-section {
  flex-shrink: 0;
  margin-bottom: 10px;
}

h6 {
  flex-shrink: 0;
  margin-bottom: 8px;
  margin-top: 15px;
}

.right-slide-modal:not(.open) {
  opacity: 0;
}

.right-slide-modal.minimized {
  right: 0 !important;
  width: 350px !important;
  max-width: 350px !important;
  height: 60px !important;
  min-height: 60px !important;
  overflow: hidden;
  border-radius: 16px 0 0 0;
  transition: width 0.3s, height 0.3s;
  padding: 0 !important;
  display: flex;
  align-items: center;
  justify-content: center;
  position: fixed !important;
  top: 20px !important;
  z-index: 10500 !important;
}

.right-slide-modal.minimized .right-slide-content {
  width: 100%;
  height: 100%;
  padding: 8px 16px !important;
  display: flex;
  align-items: center;
  justify-content: center;
}

.right-slide-modal.minimized .modal-header {
  display: flex !important;
  align-items: center;
  justify-content: space-between !important;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}

.right-slide-modal.minimized .modal-header h3 {
  font-size: 14px !important;
  margin: 0;
  flex: 1;
  text-align: left !important;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.right-slide-modal.minimized .close-btn {
  display: block !important;
  font-size: 18px !important;
  margin-left: 10px;
  flex-shrink: 0;
}

.right-slide-modal.minimized .modal-actions,
.right-slide-modal.minimized .form-section,
.right-slide-modal.minimized .model-slider-wrapper,
.right-slide-modal.minimized h4 {
  display: none !important;
}

.right-slide-modal.minimized .tray-table,
.right-slide-modal.minimized .action-buttons,
.right-slide-modal.minimized #selectedItemsStatus {
  display: none !important;
}


/* Modal Header: full width, linear gradient background, flex layout */
.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  width: 100%;
  padding: 20px;
      background: linear-gradient(
      90deg,
      #e0f7fa 0%,
      #b2ebf2 33%,
      #ffe0b2 66%,
      #f8bbd0 100%
    );
  border-radius: 16px 16px 0 0;
  min-height: 56px;
  position: relative;
  box-sizing: border-box;
}

/* Place modal-actions at top right inside modal-header */
.modal-header .modal-actions {
    position: absolute;
    top: 12px;
    right: 60px;
    margin: 10px;
    gap: 10px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    z-index: 2;
}

/* Ensure modal-header h3 takes full width except for actions */
.modal-header h3 {
  flex: 1 1 auto;
  text-align: left;
  margin: 0;
  font-size: 18px;
  padding-left: 24px;
  padding-right: 180px; /* leave space for actions */
  color: #028084;
  font-weight: 700;
  background: none;
}

/* Responsive: stack actions below header on small screens */
@media (max-width: 600px) {
  .modal-header {
    flex-direction: column;
    align-items: stretch;
    padding: 0 0 8px 0;
  }
  .modal-header .modal-actions {
    position: static;
    margin-top: 8px;
    justify-content: flex-end;
    width: 100%;
  }
  .modal-header h3 {
    padding-right: 0;
    padding-left: 8px;
  }
}

.highlight {
  color: #028084;
}

.close-btn {
  font-size: 26px;
  text-decoration: none;
  color: red;
  cursor: pointer;
}

.close-btn:hover {
  color: red;
}

/* Modal Actions */
.modal-actions {
  display: flex;
  gap: 10px;
  align-items: center;
  margin: 10px 0;
  flex-wrap: wrap;
}

.btn-action {
  padding: 6px 14px;
  border: none;
  border-radius: 20px;
  font-size: 13px;
  color: white;
  cursor: pointer;
  transition: all 0.2s ease;
  text-decoration: none;
}

.btn-action:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.btn-action.blue { 
  background-color: #0378bd; 
}

.btn-action.teal { 
  background-color: #02b4a8; 
}

.cycle-status {
  background: #e6f9fa;
  padding: 6px 14px;
  border-radius: 20px;
  color: #017d7a;
  font-size: 13px;
}

/* Modal Form Section - Improved alignment and spacing */
.form-section {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  margin-bottom: 18px;
  align-items: flex-end;
  padding: 18px 24px 16px 24px;
  background: #f5f6fa;
  border-radius: 18px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.04);
  justify-content: flex-start;
}

/* Individual form group styling */
.form-group {
  flex: 1 1 150px;
  min-width: 140px;
  max-width: 200px;
  margin-bottom: 0;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
}

/* Label styling */
.form-group label {
  margin-bottom: 4px;
  font-size: 13px;
  color: #555;
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Input field styling - editable fields are light blue */
.form-group input:not([disabled]) {
  width: 100%;
  background: #e3f2fd;
  border: 1.5px solid #bcdffb;
  border-radius: 8px;
  padding: 6px 10px;
  font-size: 14px;
  transition: background 0.2s, border 0.2s;
  margin-bottom: 0;
  box-sizing: border-box;
}

.form-group input[disabled] {
    width: 100%;
    background: #f3f3f3;
    border: 1.5px solid #e0e0e0;
    color: #1f1f1f;
    border-radius: 8px;
    padding: 6px 10px;
    font-size: 14px;
    box-sizing: border-box;
}

/* Validation status and auto-save indicator */
#jigValidationStatus, #autoSaveStatus {
  display: block;
  margin-top: 10px;
  font-size: 11px;
  color: #666;
  border-radius: 6px;
  padding: 2px 6px;
  width: auto;
  max-width: 200px;
}

/* Responsive: Stack fields on small screens */
@media (max-width: 900px) {
  .form-section {
    flex-direction: column;
    gap: 12px;
    padding: 12px 8px;
  }
  .form-group {
    max-width: 100%;
    min-width: 120px;
  }
}

/* QR validation error styling */
.qr-validation-error {
  color: #dc3545;
  font-size: 12px;
  margin-top: 4px;
  font-weight: 500;
}

/* UPDATED: Flexible Tray Table - Responsive Design */
/* --- FLEXIBLE & DISTINCT COLORS FOR .tray-table --- */
.tray-table {
  display: grid;
  grid-template-columns: 70px 1fr;
  gap: 0px;
  margin: 5px 0;
  border: 1px solid #e0e7ef;
  border-radius: 8px;
  min-height: 80px;
  max-height: 50vh;
  overflow-y: auto !important;
  overflow-x: hidden !important;
  scrollbar-width: thin;
  scrollbar-color: #b0b0b0 #f5f5f5;
  flex-grow: 1;
  resize: vertical;
  background: #f7fafd; /* NEW: base bg */
}

/* Header cells: soft blue-green */
.tray-table > div:nth-child(1),
.tray-table > div:nth-child(2) {
  position: sticky;
  top: 0;
  z-index: 2;
  background: linear-gradient(90deg, #dcdcdc 60%, #e0f7fa 100%);
  font-weight: bold;
  color: #017d7a;
  
}

/* Data cells: alternate pastel colors for rows */
.tray-table > div {
  background: #f0fdfc;
  border: 1px solid #e0e7ef;
  padding: 10px 8px;
  font-size: 13px;
  text-align: center;
}
.tray-table > div:nth-child(4n+3) { background: #ffffff; }   /* soft lavender */
.tray-table > div:nth-child(4n+4) { background: #ffffff; }   /* soft yellow */
.tray-table > div:nth-child(4n+1) { background: #ffffff; }   /* soft blue */
.tray-table > div:nth-child(4n+2) { background: #ffffff; }   /* soft green */

/* Responsive for mobile */
@media (max-width: 768px) {
  .tray-table {
    max-height: 35vh;
    font-size: 12px;
    grid-template-columns: 1fr 2fr;
  }
  .tray-table > div {
    padding: 7px 4px;
    font-size: 12px;
  }
}

/* Responsive for tablet */
@media (min-width: 769px) and (max-width: 1200px) {
  .tray-table {
    max-height: 40vh;
    font-size: 14px;
  }
  .tray-table > div {
    padding: 9px 6px;
    font-size: 14px;
  }
}

/* Responsive for desktop */
@media (min-width: 1201px) {
  .tray-table {
    max-height: 50vh;
    font-size: 13px;
  }
  .tray-table > div {
    padding: 10px 8px;
    font-size: 13px;
  }
}

/* Chrome, Edge, Safari */
.tray-table::-webkit-scrollbar {
  width: 6px;
}
.tray-table::-webkit-scrollbar-thumb {
  background: #b0b0b0;
  border-radius: 4px;
}
.tray-table::-webkit-scrollbar-track {
  background: #f5f5f5;
  border-radius: 4px;
}


.tray-table > div {
  background: #f0fdfc;
  border: 1px solid #d1d1d1;
  padding: 8px;
  font-size: 13px;
  text-align: center;
}

.tray-table > div:nth-child(-n+2) { /* Changed from -n+3 to -n+2 */
  position: sticky;
      background: linear-gradient(
          90deg,
          #e0f7fa 0%,
          #b2ebf2 33%,
          #ffe0b2 66%,
          #f8bbd0 100%
        )
  font-weight: bold;
  color: #028084;
}

/* Responsive Tray Table for all screen sizes */
@media (max-width: 768px) {
  .tray-table {
    max-height: 35vh;
    font-size: 12px;
    grid-template-columns: 1fr 2fr; /* Adjust column ratio for mobile */
  }
  .tray-table > div {
    padding: 6px 4px;
    font-size: 12px;
  }
}

@media (min-width: 769px) and (max-width: 1200px) {
  .tray-table {
    max-height: 40vh;
    font-size: 14px;
  }
  .tray-table > div {
    padding: 8px 6px;
    font-size: 14px;
  }
}

@media (min-width: 1201px) {
  .tray-table {
    max-height: 50vh;
    font-size: 13px;
  }
  .tray-table > div {
    padding: 8px;
    font-size: 13px;
  }
}

/* Responsive Tray Table for all screen sizes */
@media (max-width: 768px) {
  .tray-table {
    max-height: 35vh;
    font-size: 12px;
    grid-template-columns: 1fr 2fr; /* Adjust column ratio for mobile */
  }
  .tray-table > div {
    padding: 6px 4px;
    font-size: 12px;
  }
}

@media (min-width: 769px) and (max-width: 1200px) {
  .tray-table {
    max-height: 40vh;
    font-size: 14px;
  }
  .tray-table > div {
    padding: 8px 6px;
    font-size: 14px;
  }
}

@media (min-width: 1201px) {
  .tray-table {
    max-height: 50vh;
    font-size: 13px;
  }
  .tray-table > div {
    padding: 8px;
    font-size: 13px;
  }
}

/* Status indicator styling */
#selectedItemsStatus {
  animation: fadeIn 0.3s ease;
  margin: 15px 0;
  padding: 10px;
  background: #f8f9fa;
  border-radius: 6px;
  font-size: 14px;
  color: #666;
  display: none;
}

/* Action Buttons in Modal */
.action-buttons {
  display: flex;
  flex-wrap: nowrap;
  gap: 10px;
  margin-top: 6px;
  padding: 5px;
  justify-content: center;
}

.action-buttons button {
  min-width: 60px;
  max-width: 120px;
  padding: 6px 14px;
  font-size: 14px;
  border: none !important;         /* Remove all borders */
  box-shadow: none !important;     /* Remove any shadow */
  outline: none !important;        /* Remove outline */
  background-clip: padding-box;
  border-radius: 22px;
  flex: 0 1 auto;
}
.btn-twitter { 
  background-color: #028084a8; 
  color: white; 
}

.btn-success { 
  background-color: #28a745; 
  color: white; 
}

.btn-warning { 
  background-color: #ffc107; 
  color: #000; 
}

.btn-danger { 
  background-color: #dc3545; 
  color: white; 
}

/* Animations for Modal */
@keyframes fadeIn {
  from { 
    opacity: 0; 
    transform: translateY(-10px); 
  }
  to { 
    opacity: 1; 
    transform: translateY(0); 
  }
}

/* Toast animations */
@keyframes slideInToast {
  from { 
    opacity: 0; 
    transform: translateX(100%); 
  }
  to { 
    opacity: 1; 
    transform: translateX(0); 
  }
}

@keyframes slideOutToast {
  from { 
    opacity: 1; 
    transform: translateX(0); 
  }
  to { 
    opacity: 0; 
    transform: translateX(100%); 
  }
}

/* Modal message animations */
@keyframes slideInMessage {
  from { 
    opacity: 0; 
    transform: translateY(-10px); 
  }
  to { 
    opacity: 1; 
    transform: translateY(0); 
  }
}

@keyframes slideOutMessage {
  from { 
    opacity: 1; 
    transform: translateY(0); 
  }
  to { 
    opacity: 0; 
    transform: translateY(-10px); 
  }
}

/* Filter indicator animation */
@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

/* Model Slider in Modal */
.model-slider-wrapper {
  position: relative;
  margin-bottom: 20px;
}

.slider-btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0,0,0,0.1);
  border: none;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  color: #666;
  z-index: 10;
  display: none;
}

.prev-btn {
  left: 4px;
}

.next-btn {
  right: 4px;
}

.model-slider-container {
  overflow: hidden;
  margin: 0 15px;
}

.model-slider {
  display: flex;
  transition: transform 0.3s ease;
  gap: 12px;
}

.model-loaded-item {
  min-width: 100px;
  flex: 0 0 auto;
  margin-right: 12px;
  display: flex;
  align-items: center;
  background: linear-gradient(135deg, #e8f5e8 0%, #fff5bd 100%);
  border: 1px solid #28a745;
  border-radius: 12px;
  padding: 5px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin-top: 10px;
}

/* Responsive Design for Modal */
@media (max-width: 600px) {
  .right-slide-content {
    padding: 16px;
  }
  
  .tray-table {
    grid-template-columns: 1fr;
  }
  
  .form-section {
    grid-template-columns: 1fr;
  }
  
  .action-buttons button {
    flex: 1 1 100%;
  }
}
</style>

<div class="content-wrapper">
   <div class="col-12 grid-margin stretch-card">
     
         <div class="card-body" style="padding-bottom:12px;">
            <h5 class="text-left mt-0 mb-4" style="font-weight:700;">Jig Loading Pick Table</h5>
            <div class="table-responsive" style="overflow: scroll !important">
              <table id="order-listing" class="table">
                <thead>
                  <tr>
                    <th>
                      S.No <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Last<br>Updated
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating<br> Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polishing<br>Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating Color
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polish Finish
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                   
                    <th style="display: none;">
                      Version <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <!-- <th>
                      Source - Location
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Tray Cate- <br> Capacity
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th> -->
                    <th>
                      No of <br> Trays <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      LOT Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Jig Type
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      In.p Info<i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Process Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Action <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Lot <br> Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Current <br> Stage
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Remarks <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                  </tr>
                </thead>
              <tbody>
                {% for data in master_data %}
                <tr class="highlighted-tray-scan{% if data.jig_hold_lot %} row-inactive-blur{% endif %}" 
                    data-batch-id="{{ data.batch_id }}" 
                    data-stock-lot-id="{{ data.stock_lot_id }}">

                <td>
                      <div style="display: flex; align-items: center; gap: 3px;">
                          <input type="checkbox"
                                class="model-select-checkbox"
                                data-model-no="{{ data.model_stock_no__model_no }}"
                                data-stock-lot-id="{{ data.stock_lot_id }}"
                                data-img-url="{{ data.model_images.0|default:'/static/assets/images/imagePlaceholder.png' }}"
                                style="display: none; border:2px solid #dc3545;" />                      
                     
                        <span style="display:flex; align-items:center; gap:2px;">
                    {% if is_admin %}
                      <!-- Admin users: Show toggle switch -->
                      <label class="hold-toggle-switch" style="margin-bottom:0;">
                        {% if not data.jig_hold_lot %}
                          <input type="checkbox" class="hold-toggle-btn" checked />
                          <span class="hold-slider"></span>
                        {% else %}
                          <input type="checkbox" class="hold-toggle-btn" />
                          <span class="hold-slider"></span>
                        {% endif %}
                      </label>
                      <!-- Hold remark icon -->
                      <span class="hold-remark-icon"
                            style="display:{% if data.jig_hold_lot or data.jig_release_lot or data.jig_holding_reason or data.jig_release_reason %}inline-block{% else %}none{% endif %}; cursor:pointer;"
                            title="{% if data.jig_holding_reason %}Holding Reason: {{ data.jig_holding_reason }}{% endif %}{% if data.jig_holding_reason and data.jig_release_reason %}&#10;{% endif %}{% if data.jig_release_reason %}Release Reason: {{ data.jig_release_reason }}{% endif %}">
                        {% if data.jig_hold_lot or data.jig_release_lot or data.jig_holding_reason or data.jig_release_reason %}
                          <img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />
                        {% endif %}
                      </span>
                    {% else %}
                      <!-- Non-admin: Only show view icon if there's a holding/release reason -->
                      {% if data.jig_hold_lot or data.jig_release_lot or data.jig_holding_reason or data.jig_release_reason %}
                        <span class="hold-remark-icon"
                              style="display:inline-block; cursor:pointer;"
                              title="{% if data.jig_holding_reason %}Holding Reason: {{ data.jig_holding_reason }}{% endif %}{% if data.jig_holding_reason and data.jig_release_reason %}&#10;{% endif %}{% if data.jig_release_reason %}Release Reason: {{ data.jig_release_reason }}{% endif %}">
                          <img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:18px; height:18px;" />
                        </span>
                      {% endif %}
                    {% endif %}
                    <span class="sno-value">{{ page_obj.start_index|add:forloop.counter0 }}</span>


                        </span>
                      </div>
                  </td> 
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>
                    {{ data.brass_audit_last_process_date_time|date:"d-M-y" }}<br>
                    <span style="display:inline-block; margin-top:4px;word-break: break-all;">
                      {{ data.brass_audit_last_process_date_time|date:"h:i A" }}
                    </span>
                  </td>
                  <!-- Model/Stock No - Image hover -->  
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <span class="model-hover-trigger" style="cursor: pointer; word-break: break-all;">
                        {{ data.plating_stk_no|highlight_plating_color|safe_html }}
                        <div class="model-image-tooltip" style="position: absolute; left: 80%; top: 110%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 18px; z-index: 9999; display: flex; flex-direction: column; gap: 8px; opacity: 0; pointer-events: none; transition: opacity 0.2s; min-width: 220px;">
                          
                          <!-- Header with Info and Close buttons -->
                          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <button class="info-btn" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer;">
                               Info
                            </button>
                            <button class="close-btn" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer;">
                               Close
                            </button>
                          </div>
                              <!-- Image gallery section -->
                              <div style="display: flex; align-items: center; gap: 8px;">
                                <!-- Hide scroll buttons since only one image is shown -->
                                <div class="img-gallery" style="display: flex; gap: 6px; overflow: hidden; width: 180px;">
                                  <img src="{{ data.model_images.0|default:'/static/assets/images/imagePlaceholder.png' }}" style="width: 55px; height: 55px; object-fit: cover; border-radius: 6px;" />
                                </div>
                              </div>
                        </div>
                      </span>
                    </td>
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.polishing_stk_no }}</td>
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.plating_color }}</td>
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.polish_finish }}</td>
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %} style="display: none;">{{ data.version__version_internal }}</td>             
                  <!-- <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.location__location_name }}</td>
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.tray_type }} {{ data.tray_capacity }}</td> -->
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.no_of_trays }}</td>
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>
                    <input type="number"
                          class="edit-qty-input"
                          value="{{ data.display_qty|default:0 }}"
                          data-batch-id="{{ data.batch_id }}"
                          style="width: 60px; padding: 2px 6px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px;"
                          readonly />
                  </td>
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>
                      {{ data.jig_capacity }} Jig
                  </td>
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <span class="mobile-cross-icon" style="cursor: pointer; display: inline-flex; align-items: center;">
                          <img src="/static/assets/icons/viewRemarks.png"
                               alt="Remarks"
                               style="width:25px; height:25px; 
                                      filter: {% if data.jig_remarks %}none{% else %}grayscale(1){% endif %};
                                      color: {% if data.jig_remarks %}#fb6060{% else %}#999{% endif %}; 
                                      font-weight: 900;"
                               data-bs-toggle="tooltip"
                               data-placement="right"
                               data-bs-original-title="{% if data.jig_remarks %}{{ data.jig_remarks }}{% else %}No remarks{% endif %}" />
                      </span>
                  </td>
                                   <td {% if data.jig_hold_lot and data.batch_status.status != 'Draft' %} class="row-inactive-blur" {% endif %}>
                    <div class="d-flex">
                      <div
                        title="Tray Scan"
                        class="d-flex align-items-center justify-content-center rounded-circle ms-1"
                        style="
                          width: 20px;
                          height: 20px;
                          color: white;
                          font-weight: bold;
                          line-height: 20px;
                          text-align: center;
                          padding-top: 1px;
                          padding-right: 1px;
                          {% if data.batch_status.status == 'Yet to Start' %}
                            background: #bdbdbd; /* gray */
                          {% elif data.batch_status.status == 'Draft' %}
                            background: linear-gradient(90deg, #0c8249 50%, #bdbdbd 50%); /* half green, half gray */
                          {% elif data.batch_status.status == 'Yet to Release' or data.batch_status.status == 'Released' %}
                            background: #0c8249; /* full green */
                          {% else %}
                            background: #bdbdbd; /* default gray */
                          {% endif %}
                        "
                      >
                        L
                      </div>
                    </div>
                  </td>
                  <!-- Action buttons cell -->
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>
           
                    <a href="#" class="jig-delete-batch-btn" data-stock-lot-id="{{ data.stock_lot_id }}" title="Delete"
                      {% if data.batch_status.status == "Yet to Release" or data.batch_status.status == "Released" %}
                        style="pointer-events: none; opacity: 0.5;"
                        tabindex="-1"
                        aria-disabled="true"
                      {% endif %}
                    >
                      <img src="{% static 'assets/icons/bin.png' %}" alt="Delete" style="width: 20px; margin-right: 8px; height: auto" />
                    </a>
                    
                    <!-- Add Jig button section -->
                    {% if data.batch_status.status == 'Yet to Release' %}
                        <button
                            type="button"
                            class="btn btn-social-icon-text btn-twitter"
                            style="background-color: #028084a8; cursor: not-allowed;"
                            disabled
                        >
                            <i class="fa fa-check"></i>Added
                        </button>
                    {% else %}
                        <a href="#rightSideModal" class="open-jig-modal-btn" data-stock-lot-id="{{ data.stock_lot_id }}">
                            <button
                                type="button"
                                class="btn btn-social-icon-text btn-twitter"
                                style="background-color: #028084a8"
                            >
                                <i class="fa fa-plus"></i>Add Jig
                            </button>
                        </a>

                    {% endif %}
                    <!-- CORRECTED -->
                    <a href="#"
                      title="View"
                      class="text-primary tray-scan-btn-BQ-view tray-scan-btn-Jig"
                      style="text-decoration: underline"
                      data-stock-lot-id="{{ data.stock_lot_id }}"
                      data-batch-id="{{ data.batch_id }}"
                      data-model-no="{{ data.plating_stk_no }}"
                      data-no-of-trays="{{ data.no_of_trays }}"
                      data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
                      data-moved-to-d-picker="{{ data.Moved_to_D_Picker }}"
                      data-model-image="{{ data.model_images.0|default:'' }}"
                      data-total-batch-quantity="{{ data.display_qty|default:0 }}"
                      data-physical-qty="{{ data.physical_qty|default:0 }}"
                      data-missing-qty="{{ data.missing_qty|default:0 }}"
                      data-brass-qc-accptance="{{ data.brass_audit_accptance|yesno:'true,false' }}"
                      data-brass-qc-rejection="{{ data.brass_audit_rejection|yesno:'true,false' }}"
                      data-brass-qc-few-cases-accptance="{{ data.brass_audit_few_cases_accptance|yesno:'true,false' }}">
                      <img src="{% static 'assets/icons/view.png' %}"
                            alt="View"
                            style="width: 20px; margin-right: 8px; height: auto; cursor:pointer;" />
                    </a>
                  </td>
                  <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>
                    {% if data.batch_status.status == "On-Hold" %}
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="border: 1px solid #dc3545; background-color: #f8d7da; color: #721c24; font-size: 13px; white-space: nowrap; padding: 5px;">
                        On Hold
                      </div>
                    {% elif data.batch_status.status == "Draft" %}
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="border: 1px solid #4997ac; background-color: #dcdcdc; color: #03425d; font-size: 13px; white-space: nowrap; padding: 5px;">
                        Draft
                      </div>
                    {% elif data.batch_status.status == "Yet to Release" or data.batch_status.status == "Released" %}
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="border: 1px solid #0c8249; background-color: #e8f5e8; color: #0c8249; font-size: 13px; white-space: nowrap; padding: 5px;">
                        {{ data.batch_status.status }}
                      </div>
                    {% elif data.batch_status.status == "Yet to Start" %}
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="border: 1px solid #f9a825; background-color: #fff8e1; color: #b26a00; font-size: 13px; white-space: nowrap; padding: 5px;">
                        Yet to Start
                      </div>
                    {% else %}
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="border: 1px solid #bdbdbd; background-color: #f4f3f3; color: #666; font-size: 13px; white-space: nowrap; padding: 5px;">
                        {{ data.batch_status.status|default:"-" }}
                      </div>
                    {% endif %}
                  </td>
                    <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                           style="border: 1px solid #d1edf3; background-color: #d1edf3; color: #033b5d; font-size: 13px; white-space: nowrap; padding: 5px;">
                        {{ data.last_process_module|default:"N/A" }}
                      </div>
                    </td>
                        <td {% if data.jig_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <!-- VoiceRec with tooltip (audio remark) -->
                        <!-- VoiceRec with tooltip (audio remark) -->
                          <a href="#" title="Add Audio Remark" class="remark-tooltip-trigger" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; position: relative; cursor: pointer;">
                            <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec" style="width: 20px; height: 20px"/>
                            <div class="remark-tooltip" style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 265px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 10px; z-index: 1000;">
                              <!-- Audio recording UI placeholder -->
                              <div style="display: flex; align-items: center; gap: 10px;">
                                <button type="button" style="background: #28a745; color: #fff; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; display: flex; align-items: center; justify-content: center;">
                                  <i class="fa fa-microphone"></i>
                                </button>
                                <span style="font-size: 14px; color: #333;">Hold to record audio</span>
                                  <div style="text-align: right; margin-top: 10px;">
                                <button type="button" style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                  <i class="fa fa-send"></i>
                                </button>
                              </div>
                              </div>
                            
                            </div>
                          </a>

                          <a
                            href="#"
                            title="Add Remark"
                            class="remark-tooltip-trigger"
                            style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; position: relative; cursor: pointer;"
                          >
                            <img
                              src="{% static 'assets/icons/chat_icon.png' %}"
                              alt="Chat"
                              style="width: 20px; height: 20px; {% if data.jig_pick_remarks %}filter: grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2); opacity: 1;{% else %}opacity: 0.7;{% endif %}"
                            />

                            <div
                              class="remark-tooltip"
                              style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 270px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 15px; z-index: 1000;"
                            >
                              <textarea
                                placeholder="Type your remark..."
                                style="width: 75%; height: 40px; resize: vertical; border: 1px solid #ccc; padding: 5px; border-radius: 4px; font-family: Arial, sans-serif; font-size: 14px;"
                                {% if data.jig_pick_remarks %}readonly{% endif %}
                              >{{ data.jig_pick_remarks|default_if_none:"" }}</textarea>
                              <div style="text-align: right; margin-top: -35px">
                                {% if not data.jig_pick_remarks %}
                                  <button
                                    type="button"
                                    style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;"
                                  >
                                    <i class="fa fa-send"></i>
                                  </button>
                                {% else %}
                                  <div style="margin-top: 40px; color: #31708f; background: #d9edf7; border: 1px solid #bce8f1; border-radius: 4px; padding: 8px 12px; font-size: 10px; text-align: left;">
                                    <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                                    Remark already saved and cannot be edited.
                                  </div>
                                {% endif %}
                              </div>
                            </div>
                          </a>
                       
                        </td>
                </tr>
              {% endfor %}
              </tbody>
              </table>

              <!-- Add Jig - Window -->
              <div id="rightSideModal" class="right-slide-modal">
                <div class="right-slide-content">
                  
                  <!-- Add Jig - Header -->
                  <div class="modal-header">
                    <h3>
                      Jig Loading / Plating Stock No: <span class="highlight" id="rightModalModelNo">-</span>
                      <span id="autoSaveStatus" style="font-size: 12px; color: #666; font-weight: 400; margin-left: -7px;">
                        ðŸ’¾ Auto-save Ready
                      </span>
                    </h3>
                    <div class="modal-actions">
                      <a class="nav-link btn-action blue" id="jig-composition-link" href="#">Jig Composition</a>
                      <button type="button" class="btn-action teal">Add Model</button>
                      <div class="cycle-status" id="cycleStatusDisplay">
                        No of Cycle: <strong id="cycleCount">-/-</strong>
                        <span id="cycleAlertMessage" style="display: none; margin-left: 8px;">
                          <span class="cycle-alert-badge">
                            <i class="fa fa-exclamation-triangle" style="margin-right: 3px; font-size: 10px;"></i>
                            <span id="cycleAlertText">Alert</span>
                          </span>
                        </span>
                      </div>
                    </div>
                    <a href="#" class="close-btn" title="Close">&times;</a>
                  </div>



                  <!-- Form Fields -->
                  <div class="form-section" style="grid-template-columns: repeat(3, 1fr);gap: 5px !important;margin-bottom: 10px;, margin-bottom: 10px;">
                    <div class="form-group">
                      <label>Jig ID</label>
                      <div style="position: relative;">
                          <input type="text" placeholder="Enter Jig ID" id="modalJigQrId" maxlength="9" />  
                        <div id="jigValidationStatus" 
                              style="position: absolute;
                              top: 100%;
                              left: 0px;
                              font-size: 12px;
                              margin-top: 2px;
                              display: block;
                              border-radius: 6px;
                              padding: 3px;">
                          <span id="jigValidationMessage"></span>
                        </div>
                      </div>
                    </div>
                    <div class="form-group">
                      <label>Nickel Bath Type</label>
                      <input type="text" placeholder="Auto Fetch" disabled id="modalBathType" />
                    </div>
                    <div class="form-group">
                      <label>Empty Hooks</label>
                      <input type="text" placeholder="Auto Fetch" disabled id="modalEmptySlots" />
                    </div>
                    <div class="form-group">
                      <label>Loaded Case Qty</label>
                      <input type="text" placeholder="Auto Fetch" disabled id="modalLotQty" />
                    </div>
                    <div class="form-group">
                      <label>Jig Capacity</label>
                      <input type="text" placeholder="Auto Fetch" disabled id="modalJigCapacity" />
                    </div>
                    <div class="form-group">
                      <label>Broken/Buildup Hooks</label>
                      <input type="number" placeholder="Enter Broken/Buildup Hooks" id="modalFaultySlots" min="0" />
                    </div>
                  </div>


                                    <!-- Model Slider Section (moved directly after modal-header for left alignment) -->
                  <!-- <h6 style="text-align: left; margin-left: 0;">No of Model Loaded:</h6> -->
                  <div class="model-slider-wrapper" style="position: relative; text-align: left; margin-left: 0;">
                    <button class="slider-btn prev-btn" style="position: absolute; top: 50%; transform: translateY(-50%); left: 4px; background: rgba(0,0,0,0.1); border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; color: #666; z-index: 10; display: none;">&#10094;</button>
                    <div class="model-slider-container" style="overflow: hidden; margin: 5 15px; text-align: left;">
                      <div class="model-slider" id="modelSliderDynamic" style="display: flex; transition: transform 0.3s ease; gap: 12px; text-align: left; margin-top: 6px; margin-left: 0px;">
                        <!-- Dynamic model items will be injected here -->
                        <!-- Only show model number, no image -->
                        {% for model in models %}
                          <div class="model-loaded-item" style="min-width: 100px; flex: 0 0 auto; margin-right: 12px; display: flex; align-items: center; border: 1px solid #28a745; border-radius: 12px; padding: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-top: 10px;">
                            <span style="font-size: 14px; font-weight: bold; color: #333;">{{ model.modelNo }}</span>
                          </div>
                        {% endfor %}
                      </div>
                    </div>
                    <button class="slider-btn next-btn" style="position: absolute; top: 60%; transform: translateY(-50%); right: 4px; background: rgba(0,0,0,0.1); border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; color: #666; z-index: 10; display: none;">&#10095;</button>
                  </div>

                  <!-- Delink Tray Scan - Grids -->
                 
                  <div class="delink-section">
                    <div class="delink-header">
                      <div>De-link Tray Scan <small>(Total Trays: <span id="delinkTrayTotalCount">0</span>)</small></div>
                      <div style="font-size:12px;color:#6b7280;font-weight:600">Scan Tray ID</div>
                    </div>

                    <!-- Existing JS expects element with id="delinkTrayTable" â€” keep it as the grid container -->
                    <div id="delinkTrayTable" class="delink-grid" aria-live="polite">
                      <!-- existing code will inject <div>... or inputs here; this CSS will style them automatically -->
                    </div>
                  </div>
                  
                  <!-- Half Filled Tray / Top Tray to be Scan -->
                  <div id="halfFilledTraySection" style="display: none;">
                    <h6>Half Filled Tray / Top Tray to be Scan:</h6>
                    <div class="tray-table" id="halfFilledTrayTable">
                      <div style="background: #dcdcdc; font-weight: bold;">Tray ID</div>
                      <div style="background: #dcdcdc; font-weight: bold;">Tray Quantity</div>
                      <!-- Dynamic rows will be injected by JavaScript -->
                    </div>
                  </div>
                  
                  <!-- Status indicator for selected items -->
                  <div id="selectedItemsStatus" style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 14px; color: #666; display: none;">
                    <strong>Selected Items:</strong> <span id="selectedCount">0</span> items selected
                  </div>

                  <!-- Footer Buttons -->
                  <div class="action-buttons">
                    <button class="btn-twitter">Add Jig</button>
                    <button class="btn-success">Submit</button>
                    <button class="btn-warning">Draft</button>
                    <button class="btn-secondary" id="clearDraftBtn" style="background-color:#e1e1e1; color: #000 !important">Clear</button>
                    <button class="btn-danger">Cancel</button>
                  </div>
                </div>
              </div>

              <!-- Tray Scan Modal -->
                <div id="trayScanModal_DayPlanning" class="tray-scan-modal-DayPlanning"style="display:none"> 
                  <div class="tray-scan-modal-DayPlanning-content">
                    <span id="closeTrayScanModal_DayPlanning" class="tray-scan-close-readonly">&times;</span>
                    
                    <div class="modal-top-header" style="display: flex; align-items: center; gap: 20px; padding-bottom: 10px;">
                      <div class="user-profile" style="display: flex; align-items: center; gap: 8px">
                        <img src="/static/assets/images/imagePlaceholder.png" alt="User Profile" style="border-radius: 50%; width: 50px; height: 50px; object-fit: cover;" />
                        <!-- Model No and Lot Qty in same line -->
                        <div style="display: flex; flex-direction: column; gap: 2px;">
                          <div style="display: flex; align-items: center; gap: 15px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                              <span style="font-weight: bold; color: #666;">Model No:</span>
                              <h6 id="modalModelNo_DayPlanning" style="margin: 0; color: #028084; font-weight: bold;">(Fetch Dynamically)</h6>
                            </div>
                          <h7 style="margin: 0; color: #666666; font-weight: bold;">
                              Lot Qty: <span id="modalLotQty_DayPlanning" style="font-weight:bold; color:#e67e22;"></span>
                          </h7>
                          </div>
                            
                        </div>
                      </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                      <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                        Jig loading - Tray Scan 
                      </h5>
                      <button id="trayValidateBtn" type="button" style="display: flex; align-items: center; gap: 6px; background: #f5faff; border: 1px solid #023E4DCC; color: #023E4DCC; border-radius: 20px; padding: 4px 14px; font-size: 12px; font-weight: 500; cursor: pointer;">
                       
                        Tray Validate
                      </button>
                      <input id="trayValidateInput" type="text" placeholder="Enter validation info..." style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;" />
                      <img src="{% static 'assets/icons/redo2.png' %}" alt="Redo" id="trayScanRedoBtn" style="width: 24px; height: 24px; cursor: pointer; margin-left: 8px;" title="Clear Tray IDs" />
                    </div>
                    <div id="trayErrorMessage" style="display: none; background-color: #ffebee; border: 1px solid #f44336; color: #c62828; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-size: 12px; text-align: center;">
                      <span id="trayErrorText"></span>
                    </div>
                    <div id="trayScanDetails_DayPlanning" class="table-grid">
                      <!-- Headers and dynamic content will be injected here -->
                    </div>
                  </div>
                </div>           
            </div>
          </div>
            <!-- Pagination Section -->
            <div class="pagination-wrapper">
              <nav aria-label="Page navigation">
                <ul class="pagination justify-content-end mb-0">
                  {# Previous button #}
                  {% if page_obj.has_previous %}
                    <li>
                      <a href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                        <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                    </li>
                  {% endif %}
                
                  {# Always show first page #}
                  {% if page_obj.number > 3 %}
                    <li><a href="?page=1">1</a></li>
                    {% if page_obj.number > 4 %}
                      <li class="disabled"><span>â€¦</span></li>
                    {% endif %}
                  {% endif %}
                
                  {# Show pages around current page #}
                  {% for num in page_obj.paginator.page_range %}
                    {% if num >= page_obj.number|add:'-2' and num <= page_obj.number|add:'2' %}
                      {% if num == page_obj.number %}
                        <li class="active"><span>{{ num }}</span></li>
                      {% else %}
                        <li><a href="?page={{ num }}">{{ num }}</a></li>
                      {% endif %}
                    {% endif %}
                  {% endfor %}
                
                  {# Show ellipsis and last page if needed #}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-2' %}
                    {% if page_obj.number < page_obj.paginator.num_pages|add:'-3' %}
                      <li class="disabled"><span>â€¦</span></li>
                    {% endif %}
                    <li><a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a></li>
                  {% endif %}
                
                  {# Next button #}
                  {% if page_obj.has_next %}
                    <li>
                      <a href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                        <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                    </li>
                  {% endif %}
                </ul>
              </nav>
            </div>
     </div>
</div>


<!-- Hold Remark Modal -->
<div id="holdRemarkModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.18); z-index:20000; align-items:center; justify-content:center;">
   <div style="background:#fff; border-radius:10px; padding:28px 32px 18px 32px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
      <span id="closeHoldRemarkModal" style="position:absolute; top:8px; right:16px; font-size:22px; font-weight:bold; color:#d9534f; cursor:pointer;">&times;</span>
      <h5 style="margin-bottom:16px; color:#028084;">Row Hold Remark</h5>
      <textarea id="holdRemarkInput" maxlength="50" style="width:100%; height:60px; border:1px solid #ccc; border-radius:6px; padding:8px; font-size:15px; resize:none;" placeholder="Enter remark (max 50 chars)"></textarea>
      <div style="text-align:right; margin-top:10px;">
         <button id="saveHoldRemarkBtn" style="background:#007bff; color:#fff; border:none; border-radius:20px; padding:6px 18px; font-size:15px; cursor:pointer;">Save</button>
      </div>
      <div id="holdRemarkError" style="color:red; font-size:13px; min-height:18px; margin-top:6px;"></div>
   </div>
</div>

{% block script %}

<script nonce="{{ csp_nonce }}">
// Smart Clear Draft script: clears Jig ID, De-link Tray Scan, Half-filled Tray Scan, and deletes draft from DB

document.addEventListener("DOMContentLoaded", function() {
    const clearDraftBtn = document.getElementById('clearDraftBtn');

    // Check draft status logic (unchanged)
    function checkDraftStatus() {
        const currentLotId = window.currentLotIds && window.currentLotIds.length > 0 ? window.currentLotIds[0] : null;
        if (!clearDraftBtn) return;
        if (!currentLotId) {
            clearDraftBtn.disabled = true;
            clearDraftBtn.style.opacity = '0.5';
            clearDraftBtn.title = 'No lot selected';
            return;
        }
        fetch(`/jig_loading/check_meaningful_draft/?lot_id=${encodeURIComponent(currentLotId)}`)
            .then(response => response.json())
            .then(data => {
                if (data.has_meaningful_draft) {
                    clearDraftBtn.disabled = false;
                    clearDraftBtn.style.opacity = '1';
                    clearDraftBtn.title = 'Clear meaningful draft for this lot';
                } else {
                    clearDraftBtn.disabled = true;
                    clearDraftBtn.style.opacity = '0.5';
                    clearDraftBtn.title = data.reason || 'No meaningful draft found';
                }
            })
            .catch(() => {
                clearDraftBtn.disabled = true;
                clearDraftBtn.style.opacity = '0.5';
                clearDraftBtn.title = 'Draft check failed';
            });
    }

    // Modal open logic (unchanged)
    document.querySelectorAll('.open-jig-modal-btn').forEach((btn) => {
        btn.addEventListener('click', function () {
            const lotId = this.dataset.lotId;
            const modal = document.getElementById('rightSideModal');
            if (lotId) {
                modal.dataset.currentLotId = lotId;
                modal.classList.add('open');
            }
        });
    });

    // Checkbox change triggers draft check
    document.querySelectorAll('.model-select-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', checkDraftStatus);
    });

    // Initial check
    checkDraftStatus();

    // Clear Draft button click handler
    if (clearDraftBtn) {
        clearDraftBtn.addEventListener('click', async function() {
            if (clearDraftBtn.disabled) return;
            const currentLotId = window.currentLotIds && window.currentLotIds.length > 0 ? window.currentLotIds[0] : null;
            if (!currentLotId) {
                showToast('error', 'No lot selected', 2000);
                return;
            }

            // 1. Clear Jig ID field
            const jigInput = document.getElementById('modalJigQrId');
            if (jigInput) jigInput.value = '';

            // 2. Clear De-link Tray Scan fields (all text inputs in delinkTrayTable)
            const delinkTrayTable = document.getElementById('delinkTrayTable');
            if (delinkTrayTable) {
                delinkTrayTable.querySelectorAll('input[type="text"]').forEach(input => input.value = '');
            }

            // 3. Clear Half-filled Tray Scan fields (all text inputs in halfFilledTrayTable)
            const halfFilledTrayTable = document.getElementById('halfFilledTrayTable');
            if (halfFilledTrayTable) {
                halfFilledTrayTable.querySelectorAll('input[type="text"]').forEach(input => input.value = '');
            }

            // 4. Delete draft from DB (JigDetails and JigAutoSave)
            try {
                // Main draft (JigDetails)
                const res = await fetch('/jig_loading/clear_jig_draft/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({ lot_id: currentLotId })
                });
                const data = await res.json();

                // Also clear autosave (JigAutoSave)
                await fetch(`/jig_loading/autosave/${encodeURIComponent(currentLotId)}/clear/`, {
                    method: 'DELETE',
                    headers: { 'X-CSRFToken': getCookie('csrftoken') }
                });

                if (data.success) {
                    showToast('success', 'Draft cleared successfully!', 1200);
                    setTimeout(() => window.location.reload(), 800);
                } else {
                    showToast('error', data.error || 'Failed to clear draft', 2000);
                }
            } catch (err) {
                showToast('error', 'Network error', 2000);
            }
        });
    }

    // Helper for CSRF
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
});
</script>

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const modal = document.getElementById('rightSideModal');
  const closeButtons = modal.querySelectorAll('.close-btn');

  closeButtons.forEach((btn) => {
    btn.addEventListener('click', function () {
      // Trigger auto-save immediately before closing
      triggerAutoSave(true); // immediate save
      
      // *** FIX: Clear validation status when modal closes ***
      hideJigValidationStatus();
      
      modal.classList.remove('open');
    });
  });
});
</script>

<!--HOld save-->
<script nonce="{{ csp_nonce }}">
   // âœ… FIXED: Store state globally so it persists across table refreshes
   window.holdToggleState = {
     currentHoldCell: null,
     intendedState: null,
     currentBatchId: null,
     currentLotId: null
   };
   
   function attachHoldToggleListeners() {
     console.log('Attaching hold toggle listeners...');
   
     // Attach batch_id to each row for easy access
     document.querySelectorAll("tbody tr").forEach(function (row) {
       const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
       if (trayScanBtn) {
         row.setAttribute('data-batch-id', trayScanBtn.getAttribute('data-batch-id'));
       }
     });
   
     // Remove existing listeners and attach new ones
     document.querySelectorAll('.hold-toggle-btn').forEach(function (btn) {
       // Remove any existing click listeners
       const newBtn = btn.cloneNode(true);
       btn.parentNode.replaceChild(newBtn, btn);
       
       // Add new event listener
       newBtn.addEventListener('click', function (e) {
         e.preventDefault();
         
         const holdCell = newBtn.closest('td');
        const row = holdCell.closest('tr');
        let lotId = row.getAttribute('data-stock-lot-id');
        if (!lotId) {
          // Try to get from checkbox in the row
          const checkbox = row.querySelector('.model-select-checkbox');
          if (checkbox) {
            lotId = checkbox.getAttribute('data-stock-lot-id');
          }
        }
        window.holdToggleState = {
          currentHoldCell: holdCell,
          intendedState: newBtn.checked,
          currentLotId: lotId,
          rowIdentifier: lotId
        };
         console.log('Hold toggle clicked, state:', window.holdToggleState);
         
         document.getElementById('holdRemarkModal').querySelector('h5').textContent = 
           window.holdToggleState.intendedState ? 'Unholding Reason' : 'Holding Reason';
         document.getElementById('holdRemarkInput').value = '';
         document.getElementById('holdRemarkError').textContent = '';
         document.getElementById('holdRemarkModal').style.display = 'flex';
         document.getElementById('holdRemarkInput').focus();
       });
     });
   
     // âœ… Attach save button handler (only once globally)
     const saveBtn = document.getElementById('saveHoldRemarkBtn');
     if (saveBtn && !window.holdSaveHandlerAttached) {
       window.holdSaveHandlerAttached = true;
       
       saveBtn.onclick = function () {
         console.log('Save button clicked, current state:', window.holdToggleState);
         
         const remark = document.getElementById('holdRemarkInput').value.trim();
         if (!remark) {
           document.getElementById('holdRemarkError').textContent = 'Remark required!';
           return;
         }
         
         // âœ… Use stored state instead of current variables
         if (!window.holdToggleState.currentLotId) {
           document.getElementById('holdRemarkError').textContent = 'Lot ID not found!';
           return;
         }
       
         const action = window.holdToggleState.intendedState ? 'unhold' : 'hold';
         
         console.log('Sending request:', {
           lot_id: window.holdToggleState.currentLotId,
           remark: remark,
           action: action
         });
       
         fetch('/jig_loading/jig_save_hold_unhold_reason/', {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': getCookie('csrftoken')
           },
           body: JSON.stringify({
             lot_id: window.holdToggleState.currentLotId,
             remark: remark,
             action: action
           })
         })
         .then(res => res.json())
         .then(data => {
           console.log('Server response:', data);
           
           if (data.success) {
             // âœ… Close modal first
             document.getElementById('holdRemarkModal').style.display = 'none';
             
             // âœ… Update UI immediately before refresh
             const currentRow = document.querySelector(`tr[data-stock-lot-id="${window.holdToggleState.currentLotId}"]`);
             if (currentRow) {
               const toggle = currentRow.querySelector('.hold-toggle-btn');
               const icon = currentRow.querySelector('.hold-remark-icon');
               
               if (action === 'hold') {
                 if (toggle) toggle.checked = false;
                 currentRow.classList.add('row-inactive');
                 currentRow.querySelectorAll('td').forEach((td, idx) => {
                   if (idx > 0) {
                     td.classList.add('row-inactive-blur');
                   } else {
                     td.classList.remove('row-inactive-blur');
                   }
                 });
                 if (icon) {
                   icon.style.display = 'inline-block';
                   icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:18px; height:18px;" />`;
                   icon.setAttribute('title', 'Holding Reason: ' + remark);
                 }
               } else {
                 if (toggle) toggle.checked = true;
                 currentRow.classList.remove('row-inactive');
                 currentRow.querySelectorAll('td').forEach(td => {
                   td.classList.remove('row-inactive-blur');
                 });
                 if (icon) {
                   icon.style.display = 'none';
                 }
               }
             }
             
             // âœ… Then refresh the table data
             setTimeout(() => {
               if (typeof refreshTableData === 'function') {
                 location.reload();
               } else {
                 location.reload();
               }
             }, 500);
             
           } else {
             document.getElementById('holdRemarkError').textContent = data.error || 'Failed to save reason!';
           }
         })
         .catch((error) => {
           console.error('Request failed:', error);
           document.getElementById('holdRemarkError').textContent = 'Network error!';
         });
       };
     }
   
     // âœ… Attach close button handler (only once globally)
     const closeBtn = document.getElementById('closeHoldRemarkModal');
     if (closeBtn && !window.holdCloseHandlerAttached) {
       window.holdCloseHandlerAttached = true;
       closeBtn.onclick = function () {
         document.getElementById('holdRemarkModal').style.display = 'none';
         // Clear the state when modal is closed
         window.holdToggleState = {
           currentHoldCell: null,
           intendedState: null,
           currentBatchId: null,
           currentLotId: null
         };
       };
     }
   
     // Helper for CSRF
     function getCookie(name) {
       let cookieValue = null;
       if (document.cookie && document.cookie !== '') {
         const cookies = document.cookie.split(';');
         for (let i = 0; i < cookies.length; i++) {
           const cookie = cookies[i].trim();
           if (cookie.substring(0, name.length + 1) === (name + '=')) {
             cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
             break;
           }
         }
       }
       return cookieValue;
     }
   }
   
   // âœ… Call on page load
   document.addEventListener("DOMContentLoaded", function () {
     attachHoldToggleListeners();
   });
</script>

<!--No of Cycle Dynamic - Updated-->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function() {
  console.log("ðŸ”§ Enhanced Cycle Count with Alert Messages");
  
  // Function to show/hide and style alert message
  function updateCycleAlert(cycleData) {
    const alertMessage = document.getElementById('cycleAlertMessage');
    let alertText = document.getElementById('cycleAlertText');
    let alertBadge = alertMessage ? alertMessage.querySelector('.cycle-alert-badge') : null;

    // If alertText or alertBadge missing, create them (for robustness)
    if (alertMessage && !alertText) {
      alertText = document.createElement('span');
      alertText.id = 'cycleAlertText';
      alertMessage.appendChild(alertText);
    }
    if (alertMessage && !alertBadge) {
      alertBadge = document.createElement('span');
      alertBadge.className = 'cycle-alert-badge';
      alertMessage.appendChild(alertBadge);
    }

    if (!alertMessage || !alertText || !alertBadge) {
      console.warn("âš ï¸ Alert message elements not found in HTML");
      return;
    }
    
    const nextCycle = cycleData.next_cycle;
    const status = cycleData.status;
    
    console.log(`ðŸ” Updating alert for cycle ${nextCycle}, status: ${status}`);
    
    if (status === 'warning' && nextCycle >= 31 && nextCycle <= 35) {
      // Show warning alert for cycles 31-35
      alertMessage.style.display = 'block';
      alertMessage.className = 'cycle-alert-fade-in';
      
      // Set appropriate message based on cycle range
      let alertTextContent = '';
      if (nextCycle <= 32) {
        alertTextContent = 'Maintenance Soon';
      } else if (nextCycle <= 34) {
        alertTextContent = 'Maintenance Due';
      } else {
        alertTextContent = 'Maintenance Urgent';
      }
      
      alertText.textContent = alertTextContent;
      alertBadge.className = 'cycle-alert-badge'; // Normal warning style
      alertBadge.title = `JIG has completed ${nextCycle-1} cycles. Recommended maintenance at 30 cycles.`;
      
      console.log(`âš ï¸ Alert shown: "${alertTextContent}" for cycle ${nextCycle}`);
      
    } else if (status === 'blocked') {
      // Show critical alert for cycles 36+
      alertMessage.style.display = 'block';
      alertMessage.className = 'cycle-alert-fade-in';
      
      alertText.textContent = 'Max Cycles Reached';
      alertBadge.className = 'cycle-alert-badge critical';
      alertBadge.title = `JIG has reached maximum cycles (${nextCycle-1}). Cannot be used further.`;
      
      console.log(`âŒ Critical alert shown for cycle ${nextCycle}`);
      
    } else {
      // Hide alert for normal cycles (1-30)
      alertMessage.style.display = 'none';
      console.log(`âœ… Alert hidden for normal cycle ${nextCycle}`);
    }
  }
  
  // Function to fetch and display cycle count for a jig QR ID
  window.fetchAndDisplayCycleCount = function(jigQrId) {
    const cycleDisplay = document.getElementById('cycleCount');
    const cycleStatusDiv = document.getElementById('cycleStatusDisplay');
    const alertMessage = document.getElementById('cycleAlertMessage');
    
    if (!jigQrId.trim()) {
      // Reset to default when no QR ID
      cycleDisplay.textContent = '-/-';
      cycleStatusDiv.className = 'cycle-status';
      cycleStatusDiv.title = '';
      if (cycleStatusDiv) {
        cycleStatusDiv.style.background = '';
        cycleStatusDiv.style.borderColor = '';
        cycleStatusDiv.style.color = '';
      }
      // Hide alert message
      if (alertMessage) {
        alertMessage.style.display = 'none';
      }
      return;
    }
    
    // Show loading state
    cycleDisplay.textContent = '...';
    console.log("ðŸ” Fetching cycle count for:", jigQrId);
    
    fetch('/jig_loading/get_cycle_count/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({
        jig_qr_id: jigQrId
      })
    })
    .then(response => {
      console.log("ðŸ“¡ API Response Status:", response.status);
      return response.json();
    })
    .then(data => {
      console.log("ðŸ“Š API Response Data:", data);
      
      if (data.success) {
        // Update cycle display
        cycleDisplay.textContent = data.display_text;
        console.log("âœ… Cycle updated to:", data.display_text);
        
        // Update alert message
        updateCycleAlert(data);
        
        // Apply styling based on status
        cycleStatusDiv.className = 'cycle-status';
        cycleStatusDiv.title = data.message;
        
        // Apply visual styling based on status
        if (data.status === 'warning') {
          cycleStatusDiv.style.background = '#fff3cd';
          cycleStatusDiv.style.borderColor = '#ffc107';
          cycleStatusDiv.style.color = '#856404';
          console.log("âš ï¸ Warning status applied");
        } else if (data.status === 'blocked') {
          cycleStatusDiv.style.background = '#f8d7da';
          cycleStatusDiv.style.borderColor = '#dc3545';
          cycleStatusDiv.style.color = '#721c24';
          console.log("âŒ Blocked status applied");
          
          // Disable save buttons
          document.querySelectorAll('.action-buttons button').forEach(btn => {
            if (btn.textContent.includes('Add Jig') || btn.textContent.includes('Submit')) {
              btn.disabled = true;
              btn.style.opacity = '0.5';
              btn.title = 'Cannot save - Maximum cycles exceeded';
            }
          });
        } else {
          // Normal status - reset styling
          cycleStatusDiv.style.background = '#e6f9fa';
          cycleStatusDiv.style.borderColor = '#02b4a8';
          cycleStatusDiv.style.color = '#017d7a';
          console.log("âœ… Normal status applied");
          
          // Enable save buttons
          document.querySelectorAll('.action-buttons button').forEach(btn => {
            if (btn.textContent.includes('Add Jig') || btn.textContent.includes('Submit')) {
              btn.disabled = false;
              btn.style.opacity = '1';
              btn.title = '';
            }
          });
        }
        
      } else {
        // Error case
        cycleDisplay.textContent = 'Error';
        cycleStatusDiv.title = data.error || 'Failed to get cycle count';
        if (cycleStatusDiv) {
          cycleStatusDiv.style.background = '';
          cycleStatusDiv.style.borderColor = '';
          cycleStatusDiv.style.color = '';
        }
        // Hide alert on error
        if (alertMessage) {
          alertMessage.style.display = 'none';
        }
        console.error("âŒ API Error:", data.error);
      }
    })
    .catch(error => {
      console.error('âŒ Network Error:', error);
      cycleDisplay.textContent = 'Error';
      cycleStatusDiv.title = 'Network error while fetching cycle count';
      if (cycleStatusDiv) {
        cycleStatusDiv.style.background = '';
        cycleStatusDiv.style.borderColor = '';
        cycleStatusDiv.style.color = '';
      }
      // Hide alert on error
      if (alertMessage) {
        alertMessage.style.display = 'none';
      }
    });
  }
  
  // Enhanced JIG QR ID validation with cycle count fetching
  // Existing QR ID input listener - make saves immediate
  const jigQrInput = document.getElementById('modalJigQrId');
  if (jigQrInput) {
    jigQrInput.addEventListener('input', function() {
      // Always fetch and display cycle count on input
      fetchAndDisplayCycleCount(jigQrInput.value.trim());
    });
    // Also fetch cycle count when modal opens with existing QR ID
    if (jigQrInput.value.trim()) {
      fetchAndDisplayCycleCount(jigQrInput.value.trim());
    }
  }
  
  // Reset cycle display and alert when modal closes
  document.querySelectorAll('.close-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      const cycleDisplay = document.getElementById('cycleCount');
      const cycleStatusDiv = document.getElementById('cycleStatusDisplay');
      const alertMessage = document.getElementById('cycleAlertMessage');
      
      if (cycleDisplay) {
        cycleDisplay.textContent = '-/-';
      }
      if (cycleStatusDiv) {
        cycleStatusDiv.className = 'cycle-status';
        cycleStatusDiv.style.background = '';
        cycleStatusDiv.style.borderColor = '';
        cycleStatusDiv.style.color = '';
        cycleStatusDiv.title = '';
      }
      if (alertMessage) {
        alertMessage.style.display = 'none';
      }
    });
  });
  
  console.log("ðŸš€ Enhanced cycle count with alerts ready!");
});
</script>

<!-- Script for View Icon Tray validate -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const redoBtn = document.getElementById("trayScanRedoBtn");
  const validateInput = document.getElementById("trayValidateInput");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
  const errorMessage = document.getElementById("trayErrorMessage");

  if (redoBtn && validateInput && detailsDiv) {
    redoBtn.addEventListener("click", function () {
      // Hide and clear the input
      validateInput.value = "";
      validateInput.blur();
      
      // Hide error message
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Reset Tray Validate button to normal state
      const validateBtn = document.getElementById("trayValidateBtn");
      if (validateBtn) {
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }

      // Reset all icons in the validation status column (read-only modal)
      // For table layout:
      const rows = detailsDiv.querySelectorAll("tbody tr");
      if (rows.length > 0) {
        rows.forEach(row => {
          const statusCell = row.querySelector("td:last-child");
          if (statusCell) {
            statusCell.innerHTML = `
              <div class="validation-status">
                <div class="status-icon fail">
                  <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                </div>
                <div class="status-icon pass">
                  <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                </div>
              </div>
            `;
          }
        });
      } else {
        // For grid layout (if used)
        detailsDiv.querySelectorAll('.tray-validation-status-header, .tray-validation-status-cell').forEach(cell => {
          cell.innerHTML = `
            Tray Validation Status
            <span style="margin-left: 10px;">
              <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
              <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
            </span>
          `;
        });
      }
    });
  }
});
</script>

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  const validateBtn = document.getElementById("trayValidateBtn");
  const validateInput = document.getElementById("trayValidateInput");
  const redoBtn = document.getElementById("trayScanRedoBtn");
  const errorMessage = document.getElementById("trayErrorMessage");

  if (validateBtn && validateInput) {
    validateBtn.addEventListener("click", function () {
      validateInput.value = "";
      
      // Hide error message when starting new validation
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Change button to active state (green color)
      validateBtn.style.background = "#e8f5e8";
      validateBtn.style.borderColor = "#4caf50";
      validateBtn.style.color = "#2e7d32";
      
      // Add the 4th column to the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      
      if (modal && detailsDiv && modal.buildTableHTML) {
        // Rebuild table with validation column
        detailsDiv.innerHTML = modal.buildTableHTML(true);
      }
      
      // Focus the hidden input so it can receive keystrokes
      validateInput.focus();
    });
  }
  
  if (redoBtn && validateInput) {
    redoBtn.addEventListener("click", function () {
      validateInput.value = "";
      validateInput.blur();
      
      // Hide error message
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Reset button to normal state (original blue color)
      if (validateBtn) {
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }
      
      // Remove the 4th column from the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      
      if (modal && detailsDiv && modal.buildTableHTML) {
        // Rebuild table without validation column
        detailsDiv.innerHTML = modal.buildTableHTML(false);
      }
      
      redoBtn.focus();
    });
  }
});
</script>


<script nonce="{{ csp_nonce }}">
// Updated Tray Validation Script with Stock Status Support and Enhanced Error Handling
document.addEventListener("DOMContentLoaded", function () {
  const validateInput = document.getElementById("trayValidateInput");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
  const errorMessage = document.getElementById("trayErrorMessage");
  const errorText = document.getElementById("trayErrorText");

  console.log("ðŸ” Tray validation script loaded");
  console.log("ðŸ“‹ Elements found:", {
    validateInput: !!validateInput,
    detailsDiv: !!detailsDiv,
    errorMessage: !!errorMessage,
    errorText: !!errorText
  });

  function getCurrentBatchId() {
    const modal = document.getElementById("trayScanModal_DayPlanning");
    if (modal && modal.dataset.batchId) return modal.dataset.batchId;
    const lastBtn = document.querySelector('.tray-scan-btn-Jig[data-batch-id]');
    return lastBtn ? lastBtn.getAttribute('data-batch-id') : '';
  }

  function getCurrentStockStatus() {
    // Get stock status from the last clicked button
    const lastBtn = document.querySelector('.tray-scan-btn-Jig[data-batch-id]');
    if (lastBtn) {
      return {
        accepted_ip_stock: lastBtn.getAttribute('data-accepted-ip-stock') === 'true',
        rejected_ip_stock: lastBtn.getAttribute('data-rejected-ip-stock') === 'true',
        few_cases_accepted_ip_stock: lastBtn.getAttribute('data-few-cases-accepted-ip-stock') === 'true'
      };
    }
    return {
      accepted_ip_stock: false,
      rejected_ip_stock: false,
      few_cases_accepted_ip_stock: false
    };
  }

  function showError(message) {
    console.log("ðŸš¨ Showing error:", message);
    if (errorMessage && errorText) {
      errorText.textContent = message;
      
      // Force display with important styles
      errorMessage.style.setProperty('display', 'block', 'important');
      errorMessage.style.setProperty('visibility', 'visible', 'important');
      errorMessage.style.setProperty('opacity', '1', 'important');
      errorMessage.style.setProperty('z-index', '99999', 'important');
      errorMessage.style.setProperty('position', 'relative', 'important');
      errorMessage.style.setProperty('background-color', '#ffebee', 'important');
      errorMessage.style.setProperty('border', '1px solid #f44336', 'important');
      errorMessage.style.setProperty('color', '#c62828', 'important');
      errorMessage.style.setProperty('padding', '8px 12px', 'important');
      errorMessage.style.setProperty('border-radius', '4px', 'important');
      errorMessage.style.setProperty('margin-bottom', '10px', 'important');
      errorMessage.style.setProperty('font-size', '12px', 'important');
      errorMessage.style.setProperty('text-align', 'center', 'important');
      errorMessage.style.setProperty('width', '100%', 'important');
      
      console.log("âœ… Error message styled");
      
      // Scroll to error message if it exists
      errorMessage.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      
      // Flash the background to make it more noticeable
      let flashCount = 0;
      const flashInterval = setInterval(() => {
        if (flashCount < 6) {
          errorMessage.style.backgroundColor = flashCount % 2 === 0 ? '#ffcdd2' : '#ffebee';
          flashCount++;
        } else {
          clearInterval(flashInterval);
          errorMessage.style.backgroundColor = '#ffebee';
        }
      }, 200);
      
      console.log("âœ… Error message displayed");
      
      // Auto-hide after 8 seconds
      setTimeout(() => {
        errorMessage.style.display = "none";
        console.log("â° Auto-hiding error message after 8 seconds");
      }, 8000);
    } else {
      console.log("âŒ Error message elements not found!");
      // Fallback: show alert if error div not found
      alert(message);
    }
  }

  function hideError() {
    console.log("ðŸ«¥ Hiding error message");
    if (errorMessage) {
      errorMessage.style.display = "none";
    }
  }

  if (validateInput && detailsDiv) {
    console.log("ðŸŽ¯ Setting up tray validation event listener");
    
    // Add input event listener for real-time feedback
    validateInput.addEventListener("input", function(e) {
      console.log("âŒ¨ï¸ User typing:", e.target.value);
    });
    
    validateInput.addEventListener("keydown", function (e) {

            // Get brass QC status from the modal or last clicked tray-scan-btn-Jig
      const modal = document.getElementById("trayScanModal_DayPlanning");
      let brassQcAccptance = false;
      let brassQcRejection = false;
      let brassQcFewCasesAccptance = false;
      
      // Try to get from modal dataset if set
      if (modal) {
        brassQcAccptance = modal.getAttribute('data-brass-qc-accptance') === 'true';
        brassQcRejection = modal.getAttribute('data-brass-qc-rejection') === 'true';
        brassQcFewCasesAccptance = modal.getAttribute('data-brass-qc-few-cases-accptance') === 'true';
      }
      
      // If not set, fallback to last clicked tray-scan-btn-Jig
      if (!brassQcAccptance && !brassQcRejection && !brassQcFewCasesAccptance) {
        const lastBtn = document.querySelector('.tray-scan-btn-Jig[data-batch-id]');
        if (lastBtn) {
          brassQcAccptance = lastBtn.getAttribute('data-brass-qc-accptance') === 'true';
          brassQcRejection = lastBtn.getAttribute('data-brass-qc-rejection') === 'true';
          brassQcFewCasesAccptance = lastBtn.getAttribute('data-brass-qc-few-cases-accptance') === 'true';
        }
      }
      console.log("ðŸ”‘ Key pressed:", e.key, "Value:", validateInput.value.trim());
      
      if (e.key === "Enter") {
        const trayId = validateInput.value.trim();
        console.log("ðŸŽ¯ Enter pressed with tray ID:", trayId);
        
        if (!trayId) {
          console.log("âš ï¸ Empty tray ID, returning");
          return;
        }
        
        const batchId = getCurrentBatchId();
        console.log("ðŸ“¦ Current batch ID:", batchId);
        
        if (!batchId) {
          console.log("âŒ No batch ID found");
          showError("Batch ID not found. Please refresh and try again.");
          return;
        }

        const stockStatus = getCurrentStockStatus();
        console.log("ðŸ“Š Stock status:", stockStatus);

        // Hide any existing error message
        hideError();
        console.log("ðŸ”„ Making API call to validate tray...");

        // Include stock status in the validation request
        const requestData = {
          batch_id: batchId,
          tray_id: trayId,
          ...stockStatus
        };

    fetch("/jig_loading/jig_tray_validate/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCookie('csrftoken')
      },
      body: JSON.stringify({
        batch_id: batchId,
        tray_id: trayId,
        brass_audit_accptance: brassQcAccptance,
        brass_audit_rejection: brassQcRejection,
        brass_audit_few_cases_accptance: brassQcFewCasesAccptance
      })
    })
        .then(res => {
          console.log("ðŸ“¡ API Response status:", res.status);
          return res.json();
        })
        .then(data => {
          console.log("ðŸ“Š API Response data:", data);
          
          // Find the row in the table with this Tray ID
          const rows = detailsDiv.querySelectorAll("tbody tr");
          console.log("ðŸ“‹ Found", rows.length, "rows in modal table");
          
          let found = false;
          
          rows.forEach((row, index) => {
            const trayIdInput = row.querySelector('input[type="text"]');
            if (trayIdInput) {
              const rowTrayId = trayIdInput.value.trim();
              console.log(`ðŸ”Ž Row ${index + 1}: checking "${rowTrayId}" vs "${trayId}"`);
              
              if (rowTrayId === trayId) {
                found = true;
                console.log(`âœ… Found matching tray in row ${index + 1}`);
                
                const statusCell = row.querySelector("td:last-child");
                if (statusCell) {
                  if (data.success && data.exists) {
                    // Pass validation - show tick as active, cross as inactive
                    statusCell.innerHTML = `
                      <div class="validation-status">
                        <div class="status-icon fail inactive">
                          <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                        </div>
                        <div class="status-icon pass active">
                          <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                        </div>
                      </div>
                    `;
                    
                    // Add visual feedback for successful validation
                    row.style.backgroundColor = '#e8f5e8';
                    setTimeout(() => {
                      row.style.backgroundColor = '';
                    }, 500);
                    
                    console.log("âœ… Updated status cell to PASS");
                    
                  } else {
                    // Fail validation - show cross as active, tick as inactive
                    statusCell.innerHTML = `
                      <div class="validation-status">
                        <div class="status-icon fail active">
                          <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                        </div>
                        <div class="status-icon pass inactive">
                          <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                        </div>
                      </div>
                    `;
                    
                    // Add visual feedback for failed validation
                    row.style.backgroundColor = '#ffebee';
                    setTimeout(() => {
                      row.style.backgroundColor = '';
                    }, 500);
                    
                    console.log("âŒ Updated status cell to FAIL");
                  }
                }
              }
            }
          });
          
          if (!found) {
            console.log("âŒ Tray not found in table");
            
            // Enhanced error message with stock status context
            let filterContext = '';
            if (stockStatus.accepted_ip_stock && !stockStatus.few_cases_accepted_ip_stock) {
              filterContext = ' (searching in accepted trays only)';
            } else if (stockStatus.rejected_ip_stock && !stockStatus.few_cases_accepted_ip_stock) {
              filterContext = ' (searching in rejected trays only)';
            } else if (stockStatus.few_cases_accepted_ip_stock) {
              filterContext = ' (searching in both accepted and rejected trays)';
            }
            
            showError(`Tray ID "${trayId}" not found in table${filterContext}.`);
          } else {
            console.log("ðŸŽ‰ Validation successful!");
          }
          
          // Always clear and focus input for next scan
          validateInput.value = "";
          validateInput.focus();
        })
        .catch(error => {
          console.error('âŒ Network error:', error);
          showError('Network error occurred while validating the tray ID.');
          validateInput.value = "";
          validateInput.focus();
        });
      }
    });
    
    // Also add focus event to ensure input is ready
    validateInput.addEventListener("focus", function() {
      console.log("ðŸŽ¯ Validate input focused and ready");
    });
    
  } else {
    console.log("âŒ Required elements not found:", {
      validateInput: !!validateInput,
      detailsDiv: !!detailsDiv
    });
  }
  
  // Helper for CSRF
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
  
  console.log("ðŸŽ¯ Tray validation script setup complete");
});
</script>

<!--Update the tray list fetching endpoint in the modal script -->
<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
        link.addEventListener('click', async function (e) {
          e.preventDefault();
    
          // Get modal elements
          const modal = document.getElementById("trayScanModal_DayPlanning");
          const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
          const modalModelNo = document.getElementById("modalModelNo_DayPlanning");
          const modalLotQty = document.getElementById("modalLotQty_DayPlanning"); // âœ… NEW
          const modalMissingQty = document.getElementById("modalMissingQty_DayPlanning"); // âœ… NEW
          const modalPhysicalQty = document.getElementById("modalPhysicalQty_DayPlanning"); // âœ… NEW

          modal.dataset.batchId = link.getAttribute('data-batch-id');
    
          // Get data attributes
          const batchId = link.getAttribute('data-batch-id');
          const modelNo = link.getAttribute('data-model-no');
          const stockLotId = link.getAttribute('data-stock-lot-id');
          const noOfTrays = parseInt(link.getAttribute('data-no-of-trays')) || 0;
          const trayCapacity = link.getAttribute('data-tray-capacity') || "";
          const totalBatchQuantity = link.getAttribute('data-total-batch-quantity') || "0";
          const physicalQty = link.getAttribute('data-physical-qty') || "0";
          const missingQty = link.getAttribute('data-missing-qty') || "0";

          // âœ… UPDATED: Get brass QC specific stock status data
          const brassQcAccptance = link.getAttribute('data-brass-qc-accptance') === 'true';
          const brassQcRejection = link.getAttribute('data-brass-qc-rejection') === 'true';
          const brassQcFewCasesAccptance = link.getAttribute('data-brass-qc-few-cases-accptance') === 'true';
    
          // Set model number in modal
          if (modalModelNo && modelNo) {
            modalModelNo.textContent = modelNo;
          }

          if (modalLotQty) {
            modalLotQty.textContent = totalBatchQuantity;
            console.log("âœ… Set Lot Qty to:", totalBatchQuantity);
          }
          if (modalMissingQty) {
            modalMissingQty.textContent = missingQty;
            console.log("âœ… Set Missing Qty to:", missingQty);
          }
          if (modalPhysicalQty) {
            modalPhysicalQty.textContent = physicalQty;
            console.log("âœ… Set Physical Qty to:", physicalQty);
          }
    
          // Set model image
          const modalUserImg = modal.querySelector('.user-profile img');
          const modelImage = link.getAttribute('data-model-image');
          if (modalUserImg) {
            modalUserImg.src = modelImage || "/static/assets/images/imagePlaceholder.png";
          }
    
          // âœ… UPDATED: Fetch tray data with rejection information using correct endpoint
          let traysData = [];
          let rejectionSummary = {};
          try {
            const params = new URLSearchParams({
              batch_id: batchId,
              stock_lot_id: stockLotId,
              lot_id: stockLotId,
              brass_audit_accptance: brassQcAccptance,
              brass_audit_rejection: brassQcRejection,
              brass_audit_few_cases_accptance: brassQcFewCasesAccptance
            });
            
            // âœ… UPDATED: Use correct endpoint name
            const resp = await fetch(`/jig_loading/jig_tray_id_list/?${params}`);
            const result = await resp.json();
            if (result.success) {
              traysData = result.trays || [];
              rejectionSummary = result.rejection_summary || {};
              console.log('âœ… Fetched trays with rejection data:', traysData);
              console.log('ðŸ“Š Rejection summary:', rejectionSummary);
            }
          } catch (e) {
            console.error('âŒ Error fetching tray data:', e);
          }
    
          // âœ… FIXED: Build modal content - Only show section headers when trays exist
// âœ… FIXED: Build modal content - Only show section headers when trays exist
function buildTableHTML(showValidationColumn = false) {
  let html = `
    <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
      <thead>
        <tr>
          <th style="width:50px;">S.no</th>
          <th>Tray ID</th>
          <th>Tray Qty</th>
          ${showValidationColumn ? '<th>Tray Validation Status</th>' : ''}
        </tr>
      </thead>
      <tbody>
  `;

  let rowCounter = 1;
  let topTrayShown = false;

  // âœ… SECTION 1: ACCEPTED TRAYS ONLY - Only show if there are accepted trays
  if (traysData && traysData.length > 0) {
    const acceptedTrays = traysData.filter(tray => !tray.rejected_tray && !tray.delink_tray);
    
    // âœ… FIXED: Only add header if there are accepted trays
    if (acceptedTrays.length > 0) {
      html += `
      `;
      
      // âœ… STEP 1: Show ONLY the first top tray as row 1
      const topTrays = acceptedTrays.filter(tray => tray.ip_top_tray || tray.top_tray);
      if (topTrays.length > 0) {
        const firstTopTray = topTrays[0]; // Get only the first top tray
        
        let displayQuantity;
        if (brassQcAccptance && firstTopTray.top_tray) {
          displayQuantity = firstTopTray.tray_quantity;
        } else if (firstTopTray.ip_top_tray && firstTopTray.ip_top_tray_qty !== null) {
          displayQuantity = firstTopTray.ip_top_tray_qty;
        } else {
          displayQuantity = firstTopTray.tray_quantity;
        }

        html += `
          <tr class="top-tray-row">
            <td>${rowCounter} (Top Tray)</td>
            <td>
              <input type="text" class="form-control" value="${firstTopTray.tray_id || ''}" readonly style="width: 100%;" />
            </td>
            <td>
              <input type="number" class="form-control" value="${displayQuantity || ''}" readonly style="width: 100%;" />
            </td>
            ${showValidationColumn ? `
              <td>
                <div class="validation-status">
                  <div class="status-icon fail">
                    <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                  </div>
                  <div class="status-icon pass">
                    <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                  </div>
                </div>
              </td>
            ` : ''}
          </tr>
        `;
        rowCounter++;
        topTrayShown = true;
      }
      
      // âœ… STEP 2: Show all other accepted trays (excluding ALL top trays)
      const regularTrays = acceptedTrays.filter(tray => !tray.ip_top_tray && !tray.top_tray);
      regularTrays.forEach((tray) => {
        let displayQuantity;
        if (brassQcAccptance && tray.top_tray) {
          displayQuantity = tray.tray_quantity;
        } else if (tray.ip_top_tray && tray.ip_top_tray_qty !== null) {
          displayQuantity = tray.ip_top_tray_qty;
        } else {
          displayQuantity = tray.tray_quantity;
        }

        html += `
          <tr>
            <td>${rowCounter}</td>
            <td>
              <input type="text" class="form-control" value="${tray.tray_id || ''}" readonly style="width: 100%;" />
            </td>
            <td>
              <input type="number" class="form-control" value="${displayQuantity || ''}" readonly style="width: 100%;" />
            </td>
            ${showValidationColumn ? `
              <td>
                <div class="validation-status">
                  <div class="status-icon fail">
                    <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                  </div>
                  <div class="status-icon pass">
                    <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                  </div>
                </div>
              </td>
            ` : ''}
          </tr>
        `;
        rowCounter++;
      });
    }

    // âœ… SECTION 2: REJECTED/DELINKED/SHORTAGE TRAYS - Dynamic Header Based on Content
    // Sort rejected/delinked trays by tray quantity ascending
    const rejectedTrays = traysData
      .filter(tray => tray.rejected_tray || tray.delink_tray)
      .sort((a, b) => {
        // Use ip_top_tray_qty if present, else tray_quantity
        const qtyA = a.ip_top_tray && a.ip_top_tray_qty !== null ? a.ip_top_tray_qty : a.tray_quantity;
        const qtyB = b.ip_top_tray && b.ip_top_tray_qty !== null ? b.ip_top_tray_qty : b.tray_quantity;
        return (qtyA || 0) - (qtyB || 0);
      });              
    const hasShortage = rejectionSummary.shortage_rejections > 0;
    
    if (rejectedTrays.length > 0 || hasShortage) {
      // Determine what types are present
      const hasRejected = rejectedTrays.some(tray => tray.rejected_tray && !tray.delink_tray);
      const hasDelinked = rejectedTrays.some(tray => tray.delink_tray);
      
      let headerText = '';
      let headerColor = '';
      let bgColor = '';
      
      // âœ… Dynamic header based on combinations
      if (hasRejected && hasDelinked && hasShortage) {
        headerText = 'âŒ REJECTED, DELINKED & SHORTAGE';
        headerColor = '#c62828';
        bgColor = '#ffebee';
      } else if (hasRejected && hasShortage && !hasDelinked) {
        headerText = 'âŒ REJECTED & SHORTAGE';
        headerColor = '#c62828';
        bgColor = '#ffebee';
      } else if (hasDelinked && hasShortage && !hasRejected) {
        headerText = 'ðŸ”— DELINKED & SHORTAGE';
        headerColor = '#6c757d';
        bgColor = '#f8f9fa';
      } else if (hasRejected && hasDelinked && !hasShortage) {
        headerText = 'âŒ REJECTED & DELINKED TRAYS';
        headerColor = '#c62828';
        bgColor = '#ffebee';
      } else if (hasShortage && !hasRejected && !hasDelinked) {
        headerText = 'ðŸ“¦ SHORTAGE';
        headerColor = '#ff9800';
        bgColor = '#fff3e0';
      } else if (hasDelinked && !hasRejected && !hasShortage) {
        headerText = 'ðŸ”— DELINKED TRAYS';
        headerColor = '#6c757d';
        bgColor = '#f8f9fa';
      } else if (hasRejected && !hasDelinked && !hasShortage) {
        headerText = 'âŒ REJECTED TRAYS';
        headerColor = '#c62828';
        bgColor = '#ffebee';
      }
      
      html += `
        <tr style="background-color: ${bgColor}; font-weight: bold;">
          <td colspan="${showValidationColumn ? '4' : '3'}" style="text-align: center; color: ${headerColor}; padding: 8px;">
            ${headerText}
          </td>
        </tr>
      `;

      // Add rejected/delinked trays with tray IDs
      rejectedTrays.forEach((tray) => {
        let displayQuantity;
        if (tray.ip_top_tray && tray.ip_top_tray_qty !== null) {
          displayQuantity = tray.ip_top_tray_qty;
        } else {
          displayQuantity = tray.tray_quantity;
        }

        let statusTag = '';
        if (tray.delink_tray) {
          statusTag = '<span style="background: #6c757d; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 5px;">DELINKED</span>';
        } else {
          statusTag = '<span style="background: #f44336; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 5px;">REJECTED</span>';
        }
        
        html += `
          <tr>
            <td>${rowCounter}</td>
            <td>
              <input type="text" class="form-control" value="${tray.tray_id || ''}" readonly style="width: 100%;" />
              ${statusTag}
            </td>
            <td>
              <input type="number" class="form-control" value="${displayQuantity || ''}" readonly style="width: 100%;" />
            </td>
            ${showValidationColumn ? `
              <td>
                <div class="validation-status">
                  <div class="status-icon fail">
                    <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                  </div>
                  <div class="status-icon pass">
                    <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                  </div>
                </div>
              </td>
            ` : ''}
          </tr>
        `;
        rowCounter++;
      });

      // âœ… Handle SHORTAGE entries (if any)
      if (hasShortage) {
        // âœ… UPDATED: Use correct endpoint name for shortage data
        fetch(`/brass_audit/get_shortage_rejections/?lot_id=${encodeURIComponent(stockLotId)}`)
          .then(res => res.json())
          .then(data => {
            if (data.success && data.shortage_rejections.length > 0) {
              data.shortage_rejections.forEach(shortage => {
                html += `
                  <tr class="shortage-row">
                    <td>${rowCounter}</td>
                    <td>
                      <input type="text" class="form-control" value="SHORTAGE" readonly style="width: 100%; font-weight: bold;" />
                      <span style="background: #ff9800; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 5px;">No Tray-ID</span>
                    </td>
                    <td>
                      <input type="number" class="form-control" value="${shortage.quantity}" readonly style="width: 100%;" />
                    </td>
                    ${showValidationColumn ? `
                      <td>
                        <span style="color: #666; font-size: 11px;">N/A for SHORTAGE</span>
                      </td>
                    ` : ''}
                  </tr>
                `;
                rowCounter++;
              });
              
              // Update the table content
              html += '</tbody></table>';
              detailsDiv.innerHTML = html;
            }
          })
          .catch(e => {
            console.error('Error fetching SHORTAGE details:', e);
            // Fallback: Add basic SHORTAGE row
            for (let i = 0; i < rejectionSummary.shortage_rejections; i++) {
              html += `
                <tr class="shortage-row">
                  <td>${rowCounter}</td>
                  <td>
                    <input type="text" class="form-control" value="SHORTAGE" readonly style="width: 100%; font-weight: bold;" />
                    <span style="background: #ff9800; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 5px;">No Tray-ID</span>
                  </td>
                  <td>
                    <input type="number" class="form-control" value="?" readonly style="width: 100%;" />
                  </td>
                  ${showValidationColumn ? `
                    <td>
                      <span style="color: #666; font-size: 11px;">N/A for SHORTAGE</span>
                    </td>
                  ` : ''}
                </tr>
              `;
              rowCounter++;
            }
            html += '</tbody></table>';
            detailsDiv.innerHTML = html;
          });
        
        // Return early since we're handling async update
        return html;
      }
    }
  }
  
  html += '</tbody></table>';
  return html;
}
// Show table 
          detailsDiv.innerHTML = buildTableHTML(false);
    
          // Store data for later use
          modal.buildTableHTML = buildTableHTML;
          modal.traysData = traysData;
          modal.rejectionSummary = rejectionSummary;
    
          // Show the modal
          modal.style.display = "block";
          modal.classList.add("open");
        });
      });
    
      // Close handler remains the same
      const closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");
      if (closeBtn) {
        closeBtn.addEventListener("click", function () {
          const modal = document.getElementById("trayScanModal_DayPlanning");
          if (modal) {
            modal.classList.remove("open");
            modal.style.display = "none";
          }
        });
      }
    });
    </script>
<!--end of script view icon-->

<script nonce="{{ csp_nonce }}">
  // Example: currentLotIds = ['LOT123', 'LOT456'];
  // You should set this variable dynamically based on your modal's data.
  var currentLotIds = window.currentLotIds || [];

  document.getElementById('jig-composition-link').addEventListener('click', function(e) {
    e.preventDefault();
    if (currentLotIds.length > 0) {
      // Join lot IDs as comma-separated string
      var lotIdsParam = encodeURIComponent(currentLotIds.join(','));
      window.location.href = "{% url 'jig_composition' %}?lot_ids=" + lotIdsParam;
    } else {
      window.location.href = "{% url 'jig_composition' %}";
    }
  });
</script>

  <!-- Script for Text Remarks (unchanged) -->
<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", hideTooltip);
        }
      });
    });
</script>
  
<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", function (e) {
            e.preventDefault();
            // Find the textarea and get its value
            var textarea = tooltip.querySelector("textarea");
            var remark = textarea ? textarea.value.trim() : "";
            if (!remark) {
              Swal.fire('Error', 'Please enter a remark before sending.', 'error');
              return;
            }
            // Find the batch_id from the row (tr) data attribute or from a hidden field
           var row = trigger.closest("tr");
          var trayScanLink = row ? row.querySelector('.tray-scan-btn') : null;
          var lotId = row ? row.getAttribute('data-stock-lot-id') : null;
          if (!lotId) {
            Swal.fire('Error', 'Lot ID not found.', 'error');
            return;
          }
          fetch('/jig_loading/jig_save_ip_pick_remark/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
              lot_id: lotId,
              remark: remark
            })
          })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              Swal.fire({
                icon: 'success',
                title: 'Remark saved!',
                timer: 1200,
                showConfirmButton: false
              }).then(() => {
                // Make the textarea readonly
                if (textarea) {
                  textarea.setAttribute("readonly", true);
                }

                  // Replace send button with info message
                  if (sendButton && tooltip) {
                    const infoDiv = document.createElement("div");
                    infoDiv.style.marginTop = "40px";
                    infoDiv.style.color = "#31708f";
                    infoDiv.style.background = "#d9edf7";
                    infoDiv.style.border = "1px solid #bce8f1";
                    infoDiv.style.borderRadius = "4px";
                    infoDiv.style.padding = "8px 12px";
                    infoDiv.style.fontSize = "10px";
                    infoDiv.style.textAlign = "left";
                    infoDiv.innerHTML = `
                      <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                      Remark already saved and cannot be edited.
                    `;
                    sendButton.parentNode.replaceChild(infoDiv, sendButton);
                  }
                                   
                 // Find the chat icon <img> inside this trigger
                 const chatImg = trigger.querySelector('img[alt="Chat"]');
                 if (chatImg) {
                   chatImg.style.filter = "grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)";
                   chatImg.style.opacity = "1";
                 }
   

                  hideTooltip(); // optional if you still want to hide the tooltip
                });

              } else {
                Swal.fire('Error', data.error || 'Failed to save remark', 'error');
              }
            })
            .catch(() => {
              Swal.fire('Error', 'Network error', 'error');
            });
          });
        }
      });
    });
</script>

<!-- Plating Stk - Image hover - fixed position while hitting the Plating Stk No -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  let openTooltip = null;

  // Helper function to completely close a tooltip
  function closeTooltip(tooltip, trigger) {
    if (tooltip) {
      console.log('ðŸ”´ Closing tooltip completely');
      
      // Remove pinned class
      tooltip.classList.remove("pinned");
      
      // Hide the entire tooltip completely
      tooltip.style.opacity = "0";
      tooltip.style.pointerEvents = "none";
      tooltip.style.visibility = "hidden";
      tooltip.style.display = "none"; // âœ… ADDED: Force display none
      
      // Hide buttons
      const infoBtn = tooltip.querySelector('.info-btn');
      const closeBtn = tooltip.querySelector('.close-btn');
      if (infoBtn) infoBtn.style.display = 'none';
      if (closeBtn) closeBtn.style.display = 'none';
      
      // Remove visual indicator from trigger
      if (trigger) {
        trigger.style.backgroundColor = '';
        trigger.style.borderRadius = '';
      }
      
      // Clear global reference
      openTooltip = null;
      
      console.log('âœ… Tooltip completely closed');
    }
  }

  document.querySelectorAll(".model-image-tooltip .info-btn").forEach(function(btn) {
  btn.addEventListener("click", function(e) {
    e.stopPropagation();
    // Find the closest row
    const row = btn.closest('tr');
    let lotId = null; 
    let batchId = null;
    if (row) {
      batchId = row.getAttribute('data-batch-id');
    }
    // Build the URL with lot_id and batch_id if found
    let url = "/adminportal/dp_visualaid/";
    if (lotId) {
      url += encodeURIComponent(lotId) + "/";
    }
    if (batchId) {
      url += "?batch_id=" + encodeURIComponent(batchId);
    }
    window.location.href = url;
  });
});
   


  // Tooltip show/hide logic
  document.querySelectorAll(".model-hover-trigger").forEach(function (trigger) {
    const tooltip = trigger.querySelector(".model-image-tooltip");

    trigger.addEventListener("mouseenter", function () {
      if (tooltip && !tooltip.classList.contains("pinned")) {
        tooltip.style.display = "flex"; // âœ… ADDED: Reset display
        tooltip.style.visibility = "visible"; // âœ… ADDED: Reset visibility
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        
        // Show Info and Close buttons on hover
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';
      }
    });

    trigger.addEventListener("mouseleave", function () {
      if (tooltip && !tooltip.classList.contains("pinned")) {
        tooltip.style.opacity = "0";
        tooltip.style.pointerEvents = "none";
        
        // Hide Info and Close buttons when not hovering and not pinned
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'none';
        if (closeBtn) closeBtn.style.display = 'none';
      }
    });

    // Keep tooltip visible when hovering over it
    if (tooltip) {
      tooltip.addEventListener("mouseenter", function () {
        if (!tooltip.classList.contains("pinned")) {
          tooltip.style.display = "flex"; // âœ… ADDED: Reset display
          tooltip.style.visibility = "visible"; // âœ… ADDED: Reset visibility
        }
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        
        // Keep buttons visible when hovering over tooltip
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';
      });

      tooltip.addEventListener("mouseleave", function () {
        if (!tooltip.classList.contains("pinned")) {
          tooltip.style.opacity = "0";
          tooltip.style.pointerEvents = "none";
          
          // Hide buttons when leaving tooltip and not pinned
          const infoBtn = tooltip.querySelector('.info-btn');
          const closeBtn = tooltip.querySelector('.close-btn');
          if (infoBtn) infoBtn.style.display = 'none';
          if (closeBtn) closeBtn.style.display = 'none';
        }
      });
    }

    trigger.addEventListener("click", function (e) {
      e.stopPropagation();

      if (tooltip) {
        // Close any previously opened tooltip
        if (openTooltip && openTooltip !== tooltip) {
          const prevTrigger = openTooltip.closest('.model-hover-trigger');
          closeTooltip(openTooltip, prevTrigger);
        }

        tooltip.classList.add("pinned");
        tooltip.style.display = "flex"; // âœ… ADDED: Ensure display
        tooltip.style.visibility = "visible"; // âœ… ADDED: Ensure visibility
        tooltip.style.opacity = "1";
        tooltip.style.pointerEvents = "auto";
        openTooltip = tooltip;
        
        // Keep buttons visible when pinned
        const infoBtn = tooltip.querySelector('.info-btn');
        const closeBtn = tooltip.querySelector('.close-btn');
        if (infoBtn) infoBtn.style.display = 'block';
        if (closeBtn) closeBtn.style.display = 'block';

        // Add visual indicator that tooltip is pinned
        trigger.style.backgroundColor = '#e3f2fd';
        trigger.style.borderRadius = '4px';
      }
    });


    // âœ… FIXED: Handle Close button click - Complete tooltip closure
    const closeBtn = tooltip?.querySelector('.close-btn');
    if (closeBtn) {
      // Initially hide the button
      closeBtn.style.display = 'none';
      
      closeBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        console.log('ðŸ”´ Close button clicked');
        
        // Use the helper function to completely close tooltip
        closeTooltip(tooltip, trigger);
        
        // Feedback animation for close button
        closeBtn.style.transform = 'scale(0.9)';
        setTimeout(() => {
          if (closeBtn.style) {
            closeBtn.style.transform = 'scale(1)';
          }
        }, 150);
      });
      
      // âœ… Add hover effect for close button
      closeBtn.addEventListener('mouseenter', function() {
        closeBtn.style.backgroundColor = '#c82333';
        closeBtn.style.transform = 'scale(1.05)';
      });
      
      closeBtn.addEventListener('mouseleave', function() {
        closeBtn.style.backgroundColor = '#dc3545';
        closeBtn.style.transform = 'scale(1)';
      });
    }
  });

  // âœ… ENHANCED: Close tooltip when clicking outside
  document.addEventListener("click", function (e) {
    if (openTooltip && !e.target.closest('.model-image-tooltip') && !e.target.closest('.model-hover-trigger')) {
      const openTrigger = openTooltip.closest('.model-hover-trigger');
      closeTooltip(openTooltip, openTrigger);
    }
  });

  // âœ… Close tooltip with ESC key
  document.addEventListener("keydown", function (e) {
    if (e.key === "Escape" && openTooltip) {
      const openTrigger = openTooltip.closest('.model-hover-trigger');
      closeTooltip(openTooltip, openTrigger);
      console.log('âœ… Tooltip closed with ESC key');
    }
  });

  // Prevent tooltip from closing when clicking inside it
  document.querySelectorAll(".model-image-tooltip").forEach(function (tooltip) {
    tooltip.addEventListener("click", function (e) {
      e.stopPropagation();
    });
  });
});
</script>

<!-- Script for Model / Stock No - Image Mouse Hover -->
<script nonce="{{ csp_nonce }}">
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.model-hover-trigger').forEach(function(trigger) {
      const tooltip = trigger.querySelector('.model-image-tooltip');
      let currentIndex = 0;
      let tooltipPinned = false;
      let hoverTimeout = null;
      const images = Array.from(tooltip.querySelectorAll('.img-gallery img'));

      function showImages(start) {
        images.forEach((img, i) => {
          img.style.display = (i >= start && i < start + 3) ? 'block' : 'none';
        });
      }
      showImages(currentIndex);

      // Show immediately on mouseenter
      trigger.addEventListener('mouseenter', function() {
        clearTimeout(hoverTimeout);
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
      });

      // Hide when leaving trigger (unless pinned)
      trigger.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          hoverTimeout = setTimeout(function() {
            if (!tooltip.matches(':hover')) {
              tooltip.style.opacity = '0';
              tooltip.style.pointerEvents = 'none';
            }
          }, 300);
        }
      });

      // Keep visible when hovering over tooltip
      tooltip.addEventListener('mouseenter', function() {
        clearTimeout(hoverTimeout);
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
      });

      // Hide when leaving tooltip (unless pinned)
      tooltip.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          hoverTimeout = setTimeout(function() {
            tooltip.style.opacity = '0';
            tooltip.style.pointerEvents = 'none';
          }, 300);
        }
      });

      // Pin tooltip on click (make it sticky)
      trigger.addEventListener('click', function(e) {
        e.preventDefault();
        tooltipPinned = true;
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
        clearTimeout(hoverTimeout);
        
        // Add visual indicator that it's pinned
        trigger.style.backgroundColor = '#e3f2fd';
        trigger.style.borderRadius = '4px';
      });

      // Unpin tooltip if user clicks outside
      document.addEventListener('mousedown', function(e) {
        if (!trigger.contains(e.target) && !tooltip.contains(e.target)) {
          tooltipPinned = false;
          tooltip.style.opacity = '0';
          tooltip.style.pointerEvents = 'none';
          
          // Remove visual indicator
          trigger.style.backgroundColor = '';
          trigger.style.borderRadius = '';
        }
      });

      // Handle scroll buttons with error handling
      const leftBtn = tooltip.querySelector('.img-scroll-left');
      const rightBtn = tooltip.querySelector('.img-scroll-right');
      
      if (leftBtn) {
        leftBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (currentIndex > 0) {
            currentIndex--;
            showImages(currentIndex);
          }
        });
      }
      
      if (rightBtn) {
        rightBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          if (currentIndex < images.length - 3) {
            currentIndex++;
            showImages(currentIndex);
          }
        });
      }

      // Add click event to images for modal slider
      images.forEach(function(img, idx) {
        img.style.cursor = 'pointer';
        img.addEventListener('click', function(e) {
          e.stopPropagation();
          openImageSlider(images.map(i => i.src), idx);
        });
      });
    });

    // Modal slider functions
    const modal = document.getElementById("imageSliderModal");
    const closeModal = document.getElementById("closeImageSliderModal");
    const slidesContainer = modal ? modal.querySelector(".slides") : null;
    let sliderImages = [];
    let currentSlide = 0;

    function openImageSlider(srcArray, startIdx) {
      if (!modal || !slidesContainer) return;
      
      sliderImages = srcArray;
      slidesContainer.innerHTML = '';
      sliderImages.forEach(src => {
        const slide = document.createElement('div');
        slide.className = 'slide';
        const img = document.createElement('img');
        img.src = src;
        slide.appendChild(img);
        slidesContainer.appendChild(slide);
      });
      currentSlide = startIdx;
      showSlide(currentSlide);
      modal.classList.add('open');
    }

    function showSlide(n) {
      const slides = slidesContainer ? slidesContainer.querySelectorAll('.slide') : [];
      if (!slides.length) return;
      currentSlide = (n + slides.length) % slides.length;
      slides.forEach((slide, idx) => {
        slide.classList.toggle('active', idx === currentSlide);
      });
    }

    if (modal) {
      const prevBtn = modal.querySelector("#prevBtn");
      const nextBtn = modal.querySelector("#nextBtn");
      
      if (prevBtn) {
        prevBtn.addEventListener("click", function(e) {
          e.stopPropagation();
          showSlide(currentSlide - 1);
        });
      }
      
      if (nextBtn) {
        nextBtn.addEventListener("click", function(e) {
          e.stopPropagation();
          showSlide(currentSlide + 1);
        });
      }
      
      if (closeModal) {
        closeModal.addEventListener("click", function() {
          modal.classList.remove("open");
        });
      }
      
      modal.addEventListener("click", function(e) {
        if (e.target === modal) modal.classList.remove("open");
      });
    }
  });
</script>

<!-- Enhanced Checkbox and Modal Handling Script -->
<script nonce="{{ csp_nonce }}">
// Enhanced script for handling checkbox selections and modal functionality with Half Filled Tray
document.addEventListener("DOMContentLoaded", function() {
  let originalModalData = null;
  let currentModalLotId = null;
  let currentSlideIndex = 0;
  const itemWidth = 172; // 160px + 12px gap

  // Keep a map of debounce timers for each input
  const trayInputTimers = new WeakMap();
  

// *** NEW: Function to find next empty tray input ***
function findNextEmptyTrayInput(currentInput) {
  const allTrayInputs = Array.from(document.querySelectorAll('#delinkTrayTable input[type="text"]'));
  const currentIndex = allTrayInputs.indexOf(currentInput);
  
  // Look for next empty input after current position
  for (let i = currentIndex + 1; i < allTrayInputs.length; i++) {
    if (!allTrayInputs[i].value.trim()) {
      return allTrayInputs[i];
    }
  }
  
  // If no empty input found after current, look from beginning
  for (let i = 0; i < currentIndex; i++) {
    if (!allTrayInputs[i].value.trim()) {
      return allTrayInputs[i];
    }
  }
  
  return null; // No empty inputs found
}


// Helper: show validation message under a tray input (non-destructive)
function showTrayValidationMessage(inputElem, type, text) {
  try {
    // ensure element
    if (!inputElem || !inputElem.parentNode) return;
    // remove existing validation messages in this cell
    inputElem.parentNode.querySelectorAll('.tray-validation-message, .tray-id-loading').forEach(n => n.remove());
    // create new message
    const msg = document.createElement('div');
    msg.className = 'tray-validation-message ' + (type === 'success' ? 'tray-validation-success' : 'tray-validation-error');
    msg.setAttribute('role', 'status');
    msg.setAttribute('aria-live', 'polite');
    msg.textContent = text;
    inputElem.parentNode.appendChild(msg);
  } catch (e) { console.warn('showTrayValidationMessage error', e); }
}

// *** NEW: Real-time validation function for De-link Tray inputs ***
function validateTrayIdRealTime(trayInput) {
  const trayId = trayInput.value.trim();
  const lotId = trayInput.getAttribute('data-lot-id') || '';
  
  // Remove previous validation messages
  trayInput.parentNode.querySelectorAll('.tray-id-error, .tray-id-success, .tray-id-error-duplicate').forEach(div => div.remove());
  
  // Reset styling
  trayInput.style.borderColor = '';
  trayInput.style.backgroundColor = '';
  
  // If empty, just return without validation
  if (!trayId) {
    return;
  }
  
  // Check for duplicates first (no API call needed)
  const allTrayInputs = Array.from(document.querySelectorAll('#delinkTrayTable input[type="text"]'));
  const duplicates = allTrayInputs.filter((input, idx, arr) => {
    const val = input.value.trim();
    const lid = input.getAttribute('data-lot-id') || '';
    if (!val) return false;
    return arr.some((otherInput, otherIdx) =>
      otherIdx !== idx &&
      otherInput.value.trim() === val &&
      (otherInput.getAttribute('data-lot-id') || '') === lid
    );
  });

  if (duplicates.includes(trayInput)) {
    const dupDiv = document.createElement('div');
    dupDiv.className = 'tray-id-error tray-id-error-duplicate';
    dupDiv.style.cssText = `
      color: #d32f2f;
      font-size: 12px;
      font-weight: bold;
      background-color: #ffebee;
      padding: 4px 6px;
      border-radius: 4px;
      margin-top: 4px;
    `;
    dupDiv.textContent = 'Duplicate Tray ID not allowed for same Lot!';
    trayInput.parentNode.appendChild(dupDiv);
    trayInput.style.borderColor = '#d32f2f';
    trayInput.style.backgroundColor = '#ffebee';
    return;
  }
  
  // Show loading state
  const loadingDiv = document.createElement('div');
  loadingDiv.className = 'tray-id-loading';
  loadingDiv.style.cssText = `
    color: #6c757d;
    font-size: 11px;
    margin-top: 2px;
    display: flex;
    align-items: center;
    gap: 4px;
  `;
  loadingDiv.innerHTML = `
    <i class="fa fa-spinner fa-spin" style="font-size: 10px;"></i>
    <span>Validating...</span>
  `;
  trayInput.parentNode.appendChild(loadingDiv);
  
  // Validate tray ID via API
  fetch('/jig_loading/validate_tray_id/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({ tray_id: trayId, lot_id: lotId })
  })
  .then(res => res.json())
  .then(data => {
    // Remove loading indicator
    const loadingIndicator = trayInput.parentNode.querySelector('.tray-id-loading');
    if (loadingIndicator) {
      loadingIndicator.remove();
    }

    if (!data.exists) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'tray-id-error';
      errorDiv.style.cssText = `
        color: #d32f2f;
        font-size: 11px;
        font-weight: bold;
        background-color: #ffebee;
        padding: 4px 6px;
        border-radius: 4px;
        margin-top: 4px;
      `;
      errorDiv.textContent = 'Tray ID not found';
      trayInput.parentNode.appendChild(errorDiv);
      trayInput.style.borderColor = '#d32f2f';
      trayInput.style.backgroundColor = '#ffebee';
    } else if (!data.lot_match) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'tray-id-error';
      errorDiv.style.cssText = `
        color: #d32f2f;
        font-size: 11px;
        font-weight: bold;
        background-color: #ffebee;
        padding: 4px 6px;
        border-radius: 4px;
        margin-top: 4px;
      `;
      errorDiv.innerHTML = 'Different Lot<br>Scan tray from the chosen lot';
      trayInput.parentNode.appendChild(errorDiv);
      trayInput.style.borderColor = '#d32f2f';
      trayInput.style.backgroundColor = '#ffebee';
    } else {
      // Show success
      const successDiv = document.createElement('div');
      successDiv.className = 'tray-id-success';
      successDiv.style.cssText = `
        color: green;
        font-size: 11px;
        margin-top: 2px;
      `;
      successDiv.textContent = 'Available';
      trayInput.parentNode.appendChild(successDiv);
      trayInput.style.borderColor = '#007bff';
      trayInput.style.backgroundColor = 'rgba(255,255,255,0.95)';
      
      // *** NEW: Auto-advance to next empty input after successful validation ***
      setTimeout(() => {
        const nextEmptyInput = findNextEmptyTrayInput(trayInput);
        if (nextEmptyInput) {
          nextEmptyInput.focus();
          nextEmptyInput.select();
        }
      }, 100); // Small delay to ensure DOM updates are complete
    }
  })
  .catch(error => {
    // Remove loading indicator
    const loadingIndicator = trayInput.parentNode.querySelector('.tray-id-loading');
    if (loadingIndicator) {
      loadingIndicator.remove();
    }
    
    console.error('Tray validation error:', error);
    const errorDiv = document.createElement('div');
    errorDiv.className = 'tray-id-error';
    errorDiv.style.cssText = `
      color: #d32f2f;
      font-size: 11px;
      margin-top: 2px;
    `;
    errorDiv.textContent = 'Validation failed. Please try again.';
    trayInput.parentNode.appendChild(errorDiv);
    trayInput.style.borderColor = '#d32f2f';
    trayInput.style.backgroundColor = '#ffebee';
  });
}




  // *** NEW: Add real-time validation event listener ***
  document.addEventListener('input', function(e) {
    const trayInput = e.target.closest('#delinkTrayTable input[type="text"]');
    if (trayInput) {
      // Clear existing timer for this input
      if (trayInputTimers.has(trayInput)) {
        clearTimeout(trayInputTimers.get(trayInput));
      }
      
      // Set new timer with 500ms debounce
      const timer = setTimeout(() => {
        validateTrayIdRealTime(trayInput);
      }, 500);
      
      trayInputTimers.set(trayInput, timer);
    }
  });

  // *** ENHANCED: Existing keydown validation with improved Tab/Enter handling ***
  document.addEventListener('keydown', function(e) {
    const trayInput = e.target.closest('#delinkTrayTable input[type="text"]');
    if (trayInput && (e.key === 'Tab' || e.key === 'Enter')) {
      // Clear any pending real-time validation
      if (trayInputTimers.has(trayInput)) {
        clearTimeout(trayInputTimers.get(trayInput));
        trayInputTimers.delete(trayInput);
      }
      
      // Remove previous error/success messages
      trayInput.parentNode.querySelectorAll('.tray-id-error, .tray-id-success, .tray-id-error-duplicate, .tray-id-loading').forEach(div => div.remove());

      const trayId = trayInput.value.trim();
      const lotId = trayInput.getAttribute('data-lot-id') || '';

      // Hide success if input is empty
      if (!trayId) {
        trayInput.style.borderColor = '';
        trayInput.style.backgroundColor = '';
        return;
      }

      // Validate tray ID immediately on Tab/Enter
      fetch('/jig_loading/validate_tray_id/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({ tray_id: trayId, lot_id: lotId })
      })
      .then(res => res.json())
      .then(data => {
        let hasError = false;

        // Tray ID invalid
        if (!data.exists || !data.lot_match) {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'tray-id-error';
          errorDiv.style.color = '#d32f2f';
          errorDiv.style.fontSize = '11px';
          errorDiv.style.fontWeight = 'bold';
          errorDiv.style.backgroundColor = '#ffebee';
          errorDiv.style.padding = '4px 6px';
          errorDiv.style.borderRadius = '4px';
          errorDiv.style.marginTop = '4px';
          errorDiv.innerHTML = '<div style="color: #d32f2f;">âŒ Invalid Barcode ID</div>';
          trayInput.parentNode.appendChild(errorDiv);
          trayInput.style.borderColor = '#d32f2f';
          trayInput.style.backgroundColor = '#ffebee';
          trayInput.focus();
          trayInput.select();
          hasError = true;
        }

        // Duplicate Tray ID check (same trayId AND same lotId)
        const allTrayInputs = Array.from(document.querySelectorAll('#delinkTrayTable input[type="text"]'));
        const duplicates = allTrayInputs.filter((input, idx, arr) => {
          const val = input.value.trim();
          const lid = input.getAttribute('data-lot-id') || '';
          if (!val) return false;
          return arr.some((otherInput, otherIdx) =>
            otherIdx !== idx &&
            otherInput.value.trim() === val &&
            (otherInput.getAttribute('data-lot-id') || '') === lid
          );
        });

        if (duplicates.includes(trayInput)) {
          const dupDiv = document.createElement('div');
          dupDiv.className = 'tray-id-error tray-id-error-duplicate';
          dupDiv.style.color = '#d32f2f';
          dupDiv.style.fontSize = '12px';
          dupDiv.style.fontWeight = 'bold';
          dupDiv.style.backgroundColor = '#ffebee';
          dupDiv.style.padding = '4px 6px';
          dupDiv.style.borderRadius = '4px';
          dupDiv.style.marginTop = '4px';
          dupDiv.textContent = 'Duplicate Tray ID not allowed for same Lot!';
          trayInput.parentNode.appendChild(dupDiv);
          trayInput.style.borderColor = '#d32f2f';
          trayInput.style.backgroundColor = '#ffebee';
          trayInput.focus();
          trayInput.select();
          hasError = true;
        }

        // Handle success case
        if (!hasError) {
          // Show success only if input is not empty and valid
          if (trayId) {
            const successDiv = document.createElement('div');
            successDiv.className = 'tray-id-success';
            successDiv.style.color = 'green';
            successDiv.style.fontSize = '12px';
            successDiv.style.marginTop = '2px';
            successDiv.textContent = 'Available';
            trayInput.parentNode.appendChild(successDiv);
            trayInput.style.borderColor = '#007bff';
            trayInput.style.backgroundColor = '#f8fff8';

            // *** ENHANCED: SIMULATE TAB BEHAVIOR FOR ENTER ***
            if (e.key === 'Enter') {
              // First try to move to next input in delink table
              const allDelinkInputs = Array.from(document.querySelectorAll('#delinkTrayTable input[type="text"]'));
              const currentIndex = allDelinkInputs.indexOf(trayInput);
              
              if (currentIndex !== -1 && currentIndex < allDelinkInputs.length - 1) {
                // Move to next row in delink table
                allDelinkInputs[currentIndex + 1].focus();
                allDelinkInputs[currentIndex + 1].select();
              } else {
                // No next row in delink table, move to next focusable element (like Tab does)
                const allFocusable = Array.from(document.querySelectorAll('input, button, select, textarea, [tabindex]:not([tabindex="-1"])'));
                const currentFocusIndex = allFocusable.indexOf(trayInput);
                if (currentFocusIndex !== -1 && currentFocusIndex < allFocusable.length - 1) {
                  allFocusable[currentFocusIndex + 1].focus();
                }
              }
            }
          }
        }

        // Prevent moving to next field if error OR if Enter key (to handle it manually)
        if (hasError || e.key === 'Enter') {
          e.preventDefault();
        }
      });
    }
  });

  // *** NEW: Real-time validation for Half Filled Tray inputs ***
  function validateHalfFilledTrayRealTime(trayInput) {
    const trayId = trayInput.value.trim();
    const lotId = trayInput.getAttribute('data-lot-id') || '';
    
    // Remove previous validation messages
    trayInput.parentNode.querySelectorAll('.half-tray-validation').forEach(div => div.remove());
    
    // Reset styling
    trayInput.style.background = '';
    trayInput.style.borderColor = '';
    
    // If empty, just return
    if (!trayId) {
      return;
    }
    
    // Check against De-link Tray IDs for duplicates first
    const delinkTrayInputs = document.querySelectorAll('#delinkTrayTable input[type="text"]');
    let isDuplicate = false;
    delinkTrayInputs.forEach(input => {
      if (
        input.value.trim() === trayId &&
        (input.getAttribute('data-lot-id') || '') === lotId
      ) {
        isDuplicate = true;
      }
    });

    if (isDuplicate) {
      const msg = document.createElement('div');
      msg.className = 'half-tray-validation';
      msg.style.cssText = `
        color: #d32f2f;
        font-size: 11px;
        font-weight: bold;
        background-color: #ffebee;
        padding: 4px 6px;
        border-radius: 4px;
        margin-top: 4px;
      `;
      msg.innerHTML = '<div style="color: #d32f2f;">âŒ Duplicate Tray ID not allowed for same Lot!</div>';
      trayInput.parentNode.appendChild(msg);
      trayInput.style.borderColor = '#d32f2f';
      trayInput.style.backgroundColor = '#ffebee';
      return;
    }
    
    // Show loading state
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'half-tray-loading';
    loadingDiv.style.cssText = `
      color: #6c757d;
      font-size: 11px;
      margin-top: 2px;
      display: flex;
      align-items: center;
      gap: 4px;
    `;
    loadingDiv.innerHTML = `
      <i class="fa fa-spinner fa-spin" style="font-size: 10px;"></i>
      <span>Validating...</span>
    `;
    trayInput.parentNode.appendChild(loadingDiv);

    // Validate via API
    fetch('/jig_loading/validate_tray_id/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({ tray_id: trayId, lot_id: lotId })
    })
    .then(res => res.json())
    .then(data => {
      // Remove loading indicator
      const loadingIndicator = trayInput.parentNode.querySelector('.half-tray-loading');
      if (loadingIndicator) {
        loadingIndicator.remove();
      }
      
      if (!(data.exists && data.lot_match)) {
        // Error message
        const msg = document.createElement('div');
        msg.className = 'half-tray-validation';
        msg.style.cssText = `
          color: #d32f2f;
          font-size: 11px;
          font-weight: bold;
          background-color: #ffebee;
          padding: 4px 6px;
          border-radius: 4px;
          margin-top: 4px;
        `;
        msg.innerHTML = '<div style="color: #d32f2f;">âŒ Tray ID not found</div>';
        trayInput.parentNode.appendChild(msg);
        trayInput.style.borderColor = '#d32f2f';
        trayInput.style.backgroundColor = '#ffebee';
      } else {
        // SUCCESS: Show success message
        const successMsg = document.createElement('div');
        successMsg.className = 'half-tray-validation';
        successMsg.style.cssText = `
          color: green;
          font-size: 11px;
          margin-top: 2px;
        `;
        successMsg.textContent = 'Available';
        trayInput.parentNode.appendChild(successMsg);
        trayInput.style.borderColor = '#007bff';
        trayInput.style.backgroundColor = 'rgba(255,255,255,0.95)';
      }
    })
    .catch(error => {
      // Remove loading indicator
      const loadingIndicator = trayInput.parentNode.querySelector('.half-tray-loading');
      if (loadingIndicator) {
        loadingIndicator.remove();
      }
      
      console.error('Half-filled tray validation error:', error);
      const errorMsg = document.createElement('div');
      errorMsg.className = 'half-tray-validation';
      errorMsg.style.cssText = `
        color: #d32f2f;
        font-size: 11px;
        margin-top: 2px;
      `;
      errorMsg.textContent = 'Validation failed. Please try again.';
      trayInput.parentNode.appendChild(errorMsg);
      trayInput.style.borderColor = '#d32f2f';
      trayInput.style.backgroundColor = '#ffebee';
    });
  }

  // *** NEW: Add real-time validation for Half Filled Tray inputs ***
  document.addEventListener('input', function(e) {
    const halfTrayInput = e.target.closest('#halfFilledTrayTable input[type="text"]');
    if (halfTrayInput) {
      // Clear existing timer for this input
      if (trayInputTimers.has(halfTrayInput)) {
        clearTimeout(trayInputTimers.get(halfTrayInput));
      }
      
      // Set new timer with 500ms debounce
      const timer = setTimeout(() => {
        validateHalfFilledTrayRealTime(halfTrayInput);
      }, 500);
      
      trayInputTimers.set(halfTrayInput, timer);
    }
  });

  // *** EXISTING: Half Filled tray keydown validation (Enhanced) ***
  document.addEventListener('keydown', function(e) {
    const trayInput = e.target.closest('#halfFilledTrayTable input[type="text"]');
    if (trayInput && (e.key === 'Tab' || e.key === 'Enter')) {
      // Clear any pending real-time validation
      if (trayInputTimers.has(trayInput)) {
        clearTimeout(trayInputTimers.get(trayInput));
        trayInputTimers.delete(trayInput);
      }
      
      // Remove previous validation messages
      trayInput.parentNode.querySelectorAll('.half-tray-validation, .half-tray-loading').forEach(div => div.remove());

      const trayId = trayInput.value.trim();
      const lotId = trayInput.getAttribute('data-lot-id') || '';
      let hasError = false;

      // Check against De-link Tray IDs for duplicates
      const delinkTrayInputs = document.querySelectorAll('#delinkTrayTable input[type="text"]');
      let isDuplicate = false;
      delinkTrayInputs.forEach(input => {
        if (
          input.value.trim() === trayId &&
          (input.getAttribute('data-lot-id') || '') === lotId
        ) {
          isDuplicate = true;
        }
      });

      if (isDuplicate) {
        const msg = document.createElement('div');
        msg.className = 'half-tray-validation';
        msg.style.color = '#d32f2f';
        msg.style.fontSize = '11px';
        msg.style.fontWeight = 'bold';
        msg.style.backgroundColor = '#ffebee';
        msg.style.padding = '4px 6px';
        msg.style.borderRadius = '4px';
        msg.style.marginTop = '4px';
        msg.innerHTML = '<div style="color: #d32f2f;">âŒ Duplicate Tray ID not allowed for same Lot!</div>';
        trayInput.parentNode.appendChild(msg);
        trayInput.style.borderColor = '#d32f2f';
        trayInput.style.backgroundColor = '#ffebee';
        trayInput.focus();
        trayInput.select();
        hasError = true;
      }

      // Validate tray ID via API if not duplicate
      if (!hasError && trayId) {
        fetch('/jig_loading/validate_tray_id/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify({ tray_id: trayId, lot_id: lotId })
        })
        .then(res => res.json())
        .then(data => {
          // Remove previous success/error messages
          trayInput.parentNode.querySelectorAll('.half-tray-validation').forEach(div => div.remove());
      
          if (!(data.exists && data.lot_match)) {
            // Error message
            const msg = document.createElement('div');
            msg.className = 'half-tray-validation';
            msg.style.color = '#d32f2f';
            msg.style.fontSize = '11px';
            msg.style.fontWeight = 'bold';
            msg.style.backgroundColor = '#ffebee';
            msg.style.padding = '4px 6px';
            msg.style.borderRadius = '4px';
            msg.style.marginTop = '4px';
            msg.innerHTML = '<div style="color: #d32f2f;">âŒ Tray ID not found</div>';
            trayInput.parentNode.appendChild(msg);
            trayInput.style.borderColor = '#d32f2f';
            trayInput.style.backgroundColor = '#ffebee';
            trayInput.focus();
            trayInput.select();
            hasError = true;
          } else {
            // SUCCESS: Show success message
            const successMsg = document.createElement('div');
            successMsg.className = 'half-tray-validation';
            successMsg.style.color = 'green';
            successMsg.style.fontSize = '11px';
            successMsg.style.marginTop = '2px';
            successMsg.textContent = 'Available';
            trayInput.parentNode.appendChild(successMsg);
            trayInput.style.borderColor = '';
            trayInput.style.backgroundColor = '';

            // *** ENHANCED: SIMULATE TAB BEHAVIOR FOR ENTER ***
            if (e.key === 'Enter') {
              // First try to move to next input in half-filled table
              const allHalfInputs = Array.from(document.querySelectorAll('#halfFilledTrayTable input[type="text"]'));
              const currentIndex = allHalfInputs.indexOf(trayInput);
              
              if (currentIndex !== -1 && currentIndex < allHalfInputs.length - 1) {
                // Move to next row in half-filled table
                allHalfInputs[currentIndex + 1].focus();
                allHalfInputs[currentIndex + 1].select();
              } else {
                // No next row in half-filled table, move to next focusable element (like Tab does)
                const allFocusable = Array.from(document.querySelectorAll('input, button, select, textarea, [tabindex]:not([tabindex="-1"])'));
                const currentFocusIndex = allFocusable.indexOf(trayInput);
                if (currentFocusIndex !== -1 && currentFocusIndex < allFocusable.length - 1) {
                  allFocusable[currentFocusIndex + 1].focus();
                }
              }
            }
          }
        });
      }

      // Prevent moving to next field if error OR if Enter key (to handle it manually)
      if (hasError || e.key === 'Enter') {
        e.preventDefault();
      }
    }
  });

  // Rest of your existing code continues here...
  // [All the other functions and event listeners remain unchanged]

  // Function to show toast notifications
  function showToast(type, message, duration = 3000) {
    // Remove any existing toast
    const existingToast = document.getElementById('toastMessage');
    if (existingToast) {
      existingToast.remove();
    }

    const toast = document.createElement('div');
    toast.id = 'toastMessage';
    
    let bgColor, textColor, borderColor, icon;
    switch(type) {
      case 'success':
        bgColor = '#d4f7d4';
        textColor = '#0066cc';
        borderColor = '#007bff';
        icon = 'âœ“';
        break;
      case 'error':
        bgColor = '#ffd6d6';
        textColor = '#b30000';
        borderColor = '#dc3545';
        icon = 'âœ—';
        break;
      case 'warning':
        bgColor = '#fff3cd';
        textColor = '#856404';
        borderColor = '#ffc107';
        icon = 'âš ';
        break;
      case 'info':
        bgColor = '#d1ecf1';
        textColor = '#0c5460';
        borderColor = '#17a2b8';
        icon = 'â“˜';
        break;
      default:
        bgColor = '#d1ecf1';
        textColor = '#0c5460';
        borderColor = '#17a2b8';
        icon = 'â“˜';
    }
    
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: ${bgColor};
      color: ${textColor};
      border: 1px solid ${borderColor};
      padding: 12px 20px;
      border-radius: 8px;
      z-index: 10000;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      animation: slideInToast 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      max-width: 350px;
    `;
    
    toast.innerHTML = `
      <span style="font-weight: bold; font-size: 16px;">${icon}</span>
      <span>${message}</span>
    `;
    
    document.body.appendChild(toast);
    
    if (duration > 0) {
      setTimeout(() => {
        toast.style.animation = 'slideOutToast 0.3s ease';
        setTimeout(() => {
          if (toast.parentNode) {
            toast.remove();
          }
        }, 300);
      }, duration);
    }
    
    return toast;
  }


  // Function to show messages inside the modal instead of SweetAlert
  function showModalMessage(type, title, message, options = {}) {
    // Remove any existing message
    const existingMsg = document.getElementById('modalMessage');
    if (existingMsg) {
      existingMsg.remove();
    }

    // Create message element
    const msgDiv = document.createElement('div');
    msgDiv.id = 'modalMessage';
    
    // Style based on message type
    let bgColor, textColor, borderColor, icon;
    switch(type) {
      case 'success':
        bgColor = '#d4f7d4';
        textColor = '#0066cc';
        borderColor = '#007bff';
        icon = 'âœ“';
        break;
      case 'error':
        bgColor = '#ffd6d6';
        textColor = '#b30000';
        borderColor = '#dc3545';
        icon = 'âœ—';
        break;
      case 'warning':
        bgColor = '#fff3cd';
        textColor = '#856404';
        borderColor = '#ffc107';
        icon = 'âš ';
        break;
      case 'info':
        bgColor = '#d1ecf1';
        textColor = '#0c5460';
        borderColor = '#17a2b8';
        icon = 'â“˜';
        break;
      default:
        bgColor = '#d1ecf1';
        textColor = '#0c5460';
        borderColor = '#17a2b8';
        icon = 'â“˜';
    }
    
    msgDiv.style.cssText = `
      margin: 15px 0;
      padding: 12px 16px;
      background: ${bgColor};
      color: ${textColor};
      border: 1px solid ${borderColor};
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: slideInMessage 0.3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    `;
    
    msgDiv.innerHTML = `
      <span style="font-weight: bold; font-size: 16px;">${icon}</span>
      <div style="flex: 1;">
        <div style="font-weight: bold; margin-bottom: 2px;">${title}</div>
        <div style="font-size: 13px; line-height: 1.4;">${message}</div>
      </div>
    `;
    
    // Insert message at the top of modal content
    const modalContent = document.querySelector('#rightSideModal .right-slide-content');
    const modalHeader = modalContent.querySelector('.modal-header');
    modalContent.insertBefore(msgDiv, modalHeader.nextSibling);
    
    // Auto-hide after specified duration
    const duration = options.duration || 5000;
    if (duration > 0) {
      setTimeout(() => {
        if (msgDiv && msgDiv.parentNode) {
          msgDiv.style.animation = 'slideOutMessage 0.3s ease';
          setTimeout(() => {
            if (msgDiv && msgDiv.parentNode) {
              msgDiv.remove();
            }
          }, 300);
        }
      }, duration);
    }
    
    return msgDiv;
  }


// Global variable to track manually entered tray data
window.manuallyEnteredTrayData = new Map();

// Helper function to get the current lot ID from modal context
function getCurrentLotId() {
    // Try to get from modal dataset first
    const modal = document.getElementById('rightSideModal');
    if (modal && modal.dataset.currentLotId) {
        console.log('ðŸ“‹ Found lot_id from modal dataset:', modal.dataset.currentLotId);
        return modal.dataset.currentLotId;
    }
    
    // Fallback to window.currentLotIds
    if (window.currentLotIds && window.currentLotIds.length > 0) {
        console.log('ðŸ“‹ Found lot_id from window.currentLotIds:', window.currentLotIds[0]);
        return window.currentLotIds[0];
    }
    
    // Last resort - try to get from currently open modal button
    const openButton = document.querySelector('.open-jig-modal-btn[data-stock-lot-id]');
    if (openButton) {
        const lotId = openButton.getAttribute('data-stock-lot-id');
        console.log('ðŸ“‹ Found lot_id from open button:', lotId);
        return lotId;
    }
    
    console.warn('âš ï¸ No lot_id found in any location');
    return null;
}

// *** ENHANCED: Function to track manually entered tray data ***
function trackManualTrayEntry(trayId, lotId, index) {
  if (trayId && trayId.trim()) {
    const key = `${lotId}-${index}`;
    window.manuallyEnteredTrayData.set(key, {
      tray_id: trayId.trim(),
      lot_id: lotId,
      row_index: index,
      manually_entered: true,
      timestamp: Date.now()
    });
    console.log(`ðŸ”’ âœ… Tracked manual entry: ${trayId} for lot ${lotId} at index ${index}`);
  }
}

// Jig ID - Function to validate Jig QR ID via API 
function validateJigQrId(qrId, isAutosave = false) {
    if (!qrId.trim()) {
        showQrValidationMessage('error', 'Please enter a JIG QR ID');
        disableSubmitButtons();
        return;
    }

    showQrLoadingState();

    const lotId = getCurrentLotId();
    fetch('/jig_loading/validate_jig_qr/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken'),
        },
        credentials: 'include',
        body: JSON.stringify({
            jig_qr_id: qrId,
            lot_id: lotId,
            autosave: isAutosave
        })
    })
    .then(response => response.json())
    .then(data => {
        clearQrLoadingState();
        if (data.valid) {
            // Only show a message if it's not the generic "JIG QR ID is valid"
            if (data.message && !/JIG QR ID is valid/i.test(data.message)) {
                showQrValidationMessage('success', data.message);
            } else {
                clearQrValidationMessage();
            }
            enableSubmitButtons();
        } else {
            showQrValidationMessage('error', data.error );
            disableSubmitButtons();
        }
    })
    .catch(error => {
        clearQrLoadingState();
        showQrValidationMessage('error', 'Failed to validate JIG QR ID. Please check your connection and try again.');
        disableSubmitButtons();
    });
}





// Function to show Jig ID validation messages below the input
function showQrValidationMessage(type, message) {
    const input = document.getElementById('modalJigQrId');
    const existingMessage = input.parentNode.querySelector('.qr-validation-message');

    if (existingMessage) {
        existingMessage.remove();
    }

    // Remove generic "Jig ID is available" message
    if (type === 'success' && message && /^(Jig ID is available|JIG QR ID is valid)$/i.test(message.trim())) {
        input.style.borderColor = '#007bff';
        input.style.backgroundColor = '#e7f3ff';
        return; // Do not show the generic message
    }

    const messageDiv = document.createElement('div');
    messageDiv.className = 'qr-validation-message';

    if (type === 'success') {
        messageDiv.innerHTML = `
            <i class="fa fa-check-circle"></i>
            <span>${message}</span>
        `;
        input.style.borderColor = '#007bff';
        input.style.backgroundColor = '#e7f3ff';
    } else {
        input.style.borderColor = '#dc3545';
        input.style.backgroundColor = '#ffd6d6';
    }

    input.parentNode.appendChild(messageDiv);
}


function clearQrValidationMessage() {
    const input = document.getElementById('modalJigQrId');
    const existingMessage = input.parentNode.querySelector('.qr-validation-message');
    
    if (existingMessage) {
        existingMessage.remove();
    }
    
    // Reset input styling
    input.style.borderColor = '';
    input.style.backgroundColor = '';
}

function showQrLoadingState() {
    const input = document.getElementById('modalJigQrId');
    clearQrValidationMessage();
    
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'qr-validation-message qr-loading';
/*     loadingDiv.style.cssText = `
        color: #6c757d;
        font-size: 12px;
        margin-top: 4px;
        display: flex;
        align-items: center;
        gap: 6px;
    `; */
    loadingDiv.innerHTML = `
        <i class="fa fa-spinner fa-spin"></i>
        <span>Validating QR ID...</span>
    `;
    
    input.parentNode.appendChild(loadingDiv);
    input.style.borderColor = '#6c757d';
}

function clearQrLoadingState() {
    const loading = document.querySelector('.qr-loading');
    if (loading) {
        loading.remove();
    }
}

function enableSubmitButtons() {
    document.querySelectorAll('.action-buttons button').forEach(btn => {
        if (btn.textContent.includes('Add Jig') || btn.textContent.includes('Submit')) {
            btn.disabled = false;
            btn.classList.remove('disabled');
        }
    });
}

function disableSubmitButtons() {
  document.querySelectorAll('.action-buttons button').forEach(btn => {
    if (btn.textContent.includes('Add Jig') || btn.textContent.includes('Submit')) {
      btn.disabled = true;
      btn.classList.add('disabled');
      btn.style.cursor = 'not-allowed';  // <-- ADD THIS: Change cursor to indicate disabled
      btn.style.pointerEvents = 'none';  // <-- ADD THIS: Prevent clicks
    }
  });
}

// *** UPDATED: Multi-model optimal distribution using backend API ***
async function calculateMultiModelOptimalDistribution(lotQuantities) {
  try {
    console.log('ðŸ”§ Calling backend multi-model distribution API with:', lotQuantities);
    
    const response = await fetch('/jig_loading/get_multi_model_distribution/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({
        lot_quantities: lotQuantities
      })
    });
    
    const result = await response.json();
    console.log('ðŸ“‹ Backend API response:', result);
    
    if (result.success && result.distribution) {
      console.log('âœ… Backend distribution successful:', result.distribution);
      return result.distribution;
    } else {
      console.error('âŒ Backend distribution failed:', result.error);
      return { delink_trays: [], half_filled_trays: [], total_delink_qty: 0, lot_distributions: {} };
    }
  } catch (error) {
    console.error('âŒ Error calling backend distribution:', error);
    return { delink_trays: [], half_filled_trays: [], total_delink_qty: 0, lot_distributions: {} };
  }
}

// Update the populateDelinkTrayTableMultiModel function:
async function populateDelinkTrayTableMultiModel(lotQuantities, trayTable) {
  try {
    console.log('ðŸ”§ Populating multi-model delink tray table with quantities:', lotQuantities);
    
    // *** SMART FIX: Use pre-preserved draft data instead of trying to get it from cleared table ***
    const existingDraftData = window.preservedDraftTrayData || [];
    console.log('ðŸ”„ Using pre-preserved draft tray data:', existingDraftData);
    
    // Get optimal distribution from backend
    const distribution = await calculateMultiModelOptimalDistribution(lotQuantities);
    
    console.log('ðŸ“‹ Backend distribution result:', distribution);
    
    if (!distribution || !distribution.delink_trays || distribution.delink_trays.length === 0) {
      console.log('âŒ No distribution found');
      trayTable.innerHTML += `
        <div style="grid-column: span 2; text-align:center; padding: 20px; color: #666;">
          No optimal distribution found for selected quantities
        </div>
      `;
      return { distribution: null, adjustedTraysData: [] };
    }
    
    console.log(`âœ… Found ${distribution.delink_trays.length} delink trays to populate`);
    
    // CRITICAL FIX: Merge existing draft data with new distribution
    const mergedTrayData = mergeDraftWithNewDistribution(existingDraftData, distribution.delink_trays);
    console.log('ðŸ”€ Merged tray data:', mergedTrayData);
    
    // Populate table with merged data
    mergedTrayData.forEach((tray, index) => {
      const modelForPlaceholder = tray.plating_stk_no || getModelForLot(tray.lot_id) || 'Model';
      const isDraftData = tray.from_draft === true;
      const trayIdValue = isDraftData ? tray.tray_id : ''; // Show draft tray ID, empty for new
      
      console.log(`Adding row ${index + 1}: ${modelForPlaceholder} - ${isDraftData ? 'DRAFT' : 'NEW'} - TrayID: "${trayIdValue}"`);
      
      trayTable.innerHTML += `
        <div>${index + 1}</div>
        <div>
          <input type="text"
            value="${trayIdValue}"
            placeholder="${modelForPlaceholder} - Scan Tray ID"
            data-lot-id="${tray.lot_id || ''}"
            data-expected-usage="${tray.used_quantity || tray.expected_usage || 0}"
            data-is-top-tray="${tray.is_top_tray || false}"
            data-original-tray-qty="${tray.original_tray_quantity || tray.tray_quantity || 0}"
            data-from-draft="${isDraftData}"
            data-backend-optimal="true"
            title="${isDraftData ? 'Draft data preserved' : 'New optimal distribution'}: ${tray.used_quantity || tray.expected_usage} pieces"
            style="width:100%; border:none; background:transparent; ${isDraftData ? 'border: 1px solid #007bff; background: rgba(255,255,255,0.95);' : ''}" />
        </div>
      `;
    });
    
    // Add summary info
/*     if (distribution.total_delink_qty > 0) {
      const draftCount = existingDraftData.length;
      const newCount = mergedTrayData.length - draftCount;
      trayTable.innerHTML += `
        <div style="grid-column: span 2; text-align:center; padding: 10px; background: #e8f5e8; color: #155724; font-size: 11px; border-radius: 4px; margin-top: 5px;">
          â„¹ï¸ Multi-model: ${draftCount} draft + ${newCount} new = ${mergedTrayData.length} total trays
        </div>
      `;
    } */
    
    console.log(`âœ… Successfully populated ${mergedTrayData.length} tray entries (${existingDraftData.length} from draft)`);
    
    // Sync colors between model slider and tray inputs
    if (window.syncModelTrayBg) {
        setTimeout(() => window.syncModelTrayBg(), 100);
    }
    
    return { 
      distribution, 
      adjustedTraysData: mergedTrayData.map(tray => ({
        tray_id: tray.tray_id || '',
        tray_quantity: tray.used_quantity || tray.expected_usage || 0,
        lot_id: tray.lot_id,
        model_no: tray.plating_stk_no || getModelForLot(tray.lot_id),
        original_qty: tray.original_tray_quantity || tray.tray_quantity || 0,
        is_complete: tray.is_complete || false,
        from_draft: tray.from_draft || false
      }))
    };
    
  } catch (error) {
    console.error('âŒ Error populating multi-model delink table:', error);
    trayTable.innerHTML += `
      <div style="grid-column: span 2; text-align:center; padding: 20px; color: #dc3545;">
        Error loading multi-model distribution: ${error.message}
      </div>
    `;
    return { distribution: null, adjustedTraysData: [] };
  }
}

// Helper function to preserve existing draft tray data
function preserveExistingDraftTrayData() {
  const existingTrayData = [];
  const trayTable = document.getElementById('delinkTrayTable');
  
  console.log('ðŸ” DEBUG: Checking for tray table:', !!trayTable);
  
  if (!trayTable) {
    console.log('âŒ DEBUG: No tray table found');
    return existingTrayData;
  }
  
  console.log('ðŸ” DEBUG: Table HTML:', trayTable.innerHTML.substring(0, 200) + '...');
  
  const trayInputs = trayTable.querySelectorAll('input[type="text"]');
  console.log('ðŸ” DEBUG: Found tray inputs:', trayInputs.length);
  
  trayInputs.forEach((input, index) => {
    const trayId = input.value.trim();
    console.log(`ðŸ” DEBUG: Input ${index + 1} - Value: "${trayId}", Lot: "${input.getAttribute('data-lot-id')}"`);
    
    if (trayId) {
      existingTrayData.push({
        tray_id: trayId,
        lot_id: input.getAttribute('data-lot-id') || '',
        expected_usage: parseInt(input.getAttribute('data-expected-usage')) || 0,
        original_tray_quantity: parseInt(input.getAttribute('data-original-tray-qty')) || 0,
        from_draft: true,
        row_index: index + 1
      });
      console.log(`âœ… DEBUG: Preserved tray ${index + 1}: ${trayId}`);
    }
  });
  
  console.log('ðŸ” DEBUG: Total preserved entries:', existingTrayData.length);
  return existingTrayData;
}


// Adding more than 1 new model - Merge draft data with new optimal distribution
function mergeDraftWithNewDistribution(draftData, newDistribution) {
  const merged = [];
  
  console.log('ðŸ”€ MERGE INPUT - Draft data:', draftData.length, 'entries');
  console.log('ðŸ”€ MERGE INPUT - New distribution:', newDistribution.length, 'entries');
  
  if (draftData.length > 0) {
    console.log('ðŸ”€ Draft tray IDs to preserve:', draftData.map(d => d.tray_id));
  }
  
  // STEP 1: Add all draft data first (preserving order and tray IDs)
  draftData.forEach((draft, index) => {
    console.log(`ðŸ”€ Adding draft ${index + 1}: ${draft.tray_id || 'EMPTY'} (lot: ${draft.lot_id})`);
    merged.push({
      ...draft,
      from_draft: true,
      plating_stk_no: getModelForLot(draft.lot_id) || 'Model',
      used_quantity: draft.expected_usage || 0,
      manually_entered: draft.from_current_table || draft.manually_tracked || false
    });
  });
  
  // STEP 2: Add new distribution for additional models (empty tray IDs)
  const draftLotIds = draftData.map(d => d.lot_id);
  console.log('ðŸ”€ Draft lot IDs:', draftLotIds);
  
  newDistribution.forEach((newTray, index) => {
    const hasDraftData = draftLotIds.includes(newTray.lot_id);
    console.log(`ðŸ”€ Checking new tray ${index + 1}: lot ${newTray.lot_id}, has draft: ${hasDraftData}`);
    
    if (!hasDraftData) {
      console.log(`ðŸ”€ Adding new tray for lot: ${newTray.lot_id}`);
      merged.push({
        ...newTray,
        tray_id: '', // Empty for new entries
        from_draft: false,
        manually_entered: false
      });
    } else {
      console.log(`ðŸ”€ Skipping new tray - draft exists for lot: ${newTray.lot_id}`);
    }
  });
  
  console.log(`ðŸ”€ MERGE RESULT: ${draftData.length} draft + ${merged.length - draftData.length} new = ${merged.length} total`);
  
  // STEP 3: Log detailed merge result for debugging
  merged.forEach((entry, i) => {
    const source = entry.from_draft ? 'DRAFT' : 'NEW';
    const manual = entry.manually_entered ? ' (MANUAL)' : '';
    console.log(`ðŸ”€   ${i+1}. ${source}${manual}: TrayID="${entry.tray_id}", LotID="${entry.lot_id}"`);
  });
  
  return merged;
}



// Half-filled tray table for multi-model
function populateHalfFilledTrayTableMultiModel(distribution) {
  const table = document.getElementById('halfFilledTrayTable');
  const halfFilledSection = document.getElementById('halfFilledTraySection');
  
  console.log('Populating multi-model half-filled tray table:', distribution);
  
  if (!distribution || !distribution.half_filled_trays || distribution.half_filled_trays.length === 0) {
    console.log('No half-filled trays for multi-model - hiding table');
    if (halfFilledSection) halfFilledSection.style.display = 'none';
    if (table) table.innerHTML = '';
    return;
  }
  
  // Filter to only show top trays for verification (consistency with single model)
  const topTraysOnly = distribution.half_filled_trays.filter(tray => tray.is_top_tray || tray.remaining_type === 'partial');
  
  if (topTraysOnly.length === 0) {
    console.log('No top trays to show for verification - hiding table');
    if (halfFilledSection) halfFilledSection.style.display = 'none';
    if (table) table.innerHTML = '';
    return;
  }
  
  console.log(`Showing ${topTraysOnly.length} top trays for verification`);
  if (halfFilledSection) halfFilledSection.style.display = 'block';
  
  // Table headers
  table.innerHTML = `
    <div style="background: #dcdcdc; font-weight: bold;">Tray ID</div>
    <div style="background: #dcdcdc; font-weight: bold;">Tray Quantity</div>
  `;
  
  topTraysOnly.forEach((tray, idx) => {
    const verificationLabel = '<span style="color:#b26a00;font-size:11px;font-weight:bold;margin-left:6px;">Multi-Model Verification</span>';
    const modelInfo = tray.plating_stk_no ? `<div style="font-size:10px;color:#007bff;margin-top:1px;font-style:italic;">Model: ${tray.plating_stk_no}</div>` : '';
    
    // tray.tray_quantity is the "remaining count" from backend
    table.innerHTML += `
      <div>
        <input type="text"
          value=""
          placeholder="Scan remaining tray (${tray.plating_stk_no || 'Model'})"
          data-expected-tray-id="${tray.tray_id}"
          data-qty="${tray.tray_quantity}"
          data-original-qty="${tray.original_tray_quantity || tray.tray_quantity}"
          data-top-tray="true"
          data-lot-id="${tray.lot_id || ''}"
          data-model-no="${tray.plating_stk_no || ''}"
          data-verification="true"
          data-multi-model="true"
          style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px;"
        />
        ${modelInfo}
      </div>
      <div>
        <input type="number"
          value="${tray.tray_quantity}"
          readonly
          style="background: #f9f9f9; border: 1px solid #ddd; width: 80px; text-align: center; padding: 4px; border-radius: 4px;"
        />
        ${verificationLabel}
      </div>
    `;
  });
  
  console.log(`âœ… Populated ${topTraysOnly.length} multi-model half-filled tray entries`);
}

// *** UPDATED: Enhanced faulty slots calculation for multi-model ***
function setupFaultySlotHandlerMultiModel(validResults, calculatedLotIdQuantities, distribution) {
  const faultySlotInput = document.getElementById('modalFaultySlots').value=0;
  const emptySlotInput = document.getElementById('modalEmptySlots');
  const lotQtyInput = document.getElementById('modalLotQty');
  
  if (!faultySlotInput) return;
  
  // Store original values for calculation
  const originalEmptySlots = parseInt(emptySlotInput.value) || 0;
  const originalLotQty = parseInt(lotQtyInput.value) || 0;
  
  // Remove any existing event listeners
  faultySlotInput.replaceWith(faultySlotInput.cloneNode(true));
  const newFaultySlotInput = document.getElementById('modalFaultySlots');
  
 newFaultySlotInput.addEventListener('input', async function() {
    const faultySlots = parseInt(newFaultySlotInput.value) || 0;
    const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
    
    // *** NEW: FAULTY SLOTS VALIDATION BASED ON JIG CAPACITY ***
    let maxAllowedFaultySlots;
    if (jigCapacity >= 144) {
        maxAllowedFaultySlots = 10;
    } else {
        maxAllowedFaultySlots = 5;
    }
    
    // Validate faulty slots input
    if (faultySlots > maxAllowedFaultySlots) {
        showModalMessage('error', 'Multi-Model Broken/Buildup Hooks Limit Exceeded', 
            `Maximum ${maxAllowedFaultySlots} faulty slots allowed for jig capacity ${jigCapacity}. ` +
            `(Jig capacity ${jigCapacity >= 144 ? 'â‰¥ 144' : '< 144'}: max ${maxAllowedFaultySlots} faulty slots)`, 
            { duration: 5000 });
        
        // Reset to maximum allowed value
        newFaultySlotInput.value = maxAllowedFaultySlots;
        
        // Continue with calculation using the corrected value
        const correctedFaultySlots = maxAllowedFaultySlots;
        
        // Apply multi-model faulty slots logic with corrected value
        const usableJigCapacity = Math.max(0, jigCapacity - correctedFaultySlots);
        const newLotQty = Math.min(originalLotQty, usableJigCapacity);
        const newEmptySlots = Math.max(0, usableJigCapacity - newLotQty);
        
        emptySlotInput.value = newEmptySlots;
        updateAddJigButtonState(newEmptySlots);  // NEW: Update Add Jig button state
        lotQtyInput.value = newLotQty;
        
        // Update Add Model button state
        updateAddModelButtonState(newEmptySlots);
        return; // Exit early after correction
    }
    
    console.log(`ðŸ”§ Multi-model faulty slots changed to: ${faultySlots} (max allowed: ${maxAllowedFaultySlots})`);
    
    // *** EXISTING MULTI-MODEL FAULTY SLOTS CALCULATION LOGIC CONTINUES HERE ***
    if (faultySlots <= 0) {
    // Reset to original values
    emptySlotInput.value = originalEmptySlots;
    lotQtyInput.value = originalLotQty;
    
    // *** FIXED: REBUILD DE-LINK TRAY TABLE WITH ORIGINAL DISTRIBUTION ***
    const trayTable = document.getElementById('delinkTrayTable');
    trayTable.innerHTML = `
      <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
      <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
    `;
    
    console.log('ðŸ”„ Resetting to original multi-model quantities:', calculatedLotIdQuantities);
    await populateDelinkTrayTableMultiModel(calculatedLotIdQuantities, trayTable);
    
    // Reset half-filled tray table with original distribution
    if (distribution && distribution.half_filled_trays) {
        populateHalfFilledTrayTableMultiModel(distribution);
    } else {
        populateHalfFilledTrayTable([]);
    }
} else {
        // Continue with existing multi-model calculation logic...
        const usableJigCapacity = Math.max(0, jigCapacity - faultySlots);
        
        console.log(`Multi-model faulty slots calculation:`);
        console.log(`  Jig capacity: ${jigCapacity}`);
        console.log(`  Max allowed faulty slots: ${maxAllowedFaultySlots}`);
        console.log(`  Current faulty slots: ${faultySlots}`);
        console.log(`  Usable capacity: ${usableJigCapacity}`);
        
        // Rest of existing multi-model calculation logic...
        const newLotQty = Math.min(originalLotQty, usableJigCapacity);
        const newEmptySlots = Math.max(0, usableJigCapacity - newLotQty);
      
      // Update the fields
      emptySlotInput.value = newEmptySlots;
      updateAddJigButtonState(newEmptySlots);  // NEW: Update Add Jig button state

      lotQtyInput.value = newLotQty;
      
      // Show warning if faulty slots exceed total capacity
      if (faultySlots > jigCapacity) {
        showModalMessage('warning', 'Broken/Buildup Hooks Exceed Capacity', 
          `${faultySlots} faulty slots cannot be accommodated.`, 
          { duration: 500 });
        newFaultySlotInput.value = jigCapacity;
        return;
      }
      
      // *** CRITICAL: Recalculate distribution with adjusted quantity ***
      if (newLotQty !== originalLotQty) {
        console.log('ðŸ”„ Recalculating multi-model distribution due to faulty slots');
        
        // Calculate proportional reduction for each lot
        const reductionRatio = newLotQty / originalLotQty;
        const adjustedLotQuantities = {};
        
        for (const [lotId, originalQty] of Object.entries(calculatedLotIdQuantities)) {
          adjustedLotQuantities[lotId] = Math.floor(originalQty * reductionRatio);
        }
        
        console.log('Original lot quantities:', calculatedLotIdQuantities);
        console.log('Adjusted lot quantities due to faulty slots:', adjustedLotQuantities);
        console.log('Reduction ratio:', reductionRatio);
        
        // *** FIXED: Update global state for modal data collection ***
        window.currentLotIdQuantities = adjustedLotQuantities;
        
        // Update delink tray table with adjusted quantities
        const trayTable = document.getElementById('delinkTrayTable');
        trayTable.innerHTML = `
          <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
          <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
        `;
        
        try {
          console.log('ðŸš€ Calling multi-model backend API with adjusted quantities');
          const adjustedResult = await populateDelinkTrayTableMultiModel(adjustedLotQuantities, trayTable);
          
          // Update half-filled tray table with adjusted distribution
          if (adjustedResult && adjustedResult.distribution) {
            populateHalfFilledTrayTableMultiModel(adjustedResult.distribution);
            console.log('âœ… Updated tables with adjusted distribution');
          } else {
            console.log('âš ï¸ No distribution returned, hiding half-filled');
            populateHalfFilledTrayTableMultiModel({ half_filled_trays: [] });
          }
        } catch (error) {
          console.error('âŒ Error recalculating multi-model distribution:', error);
          showModalMessage('error', 'Calculation Error', 'Failed to recalculate distribution with faulty slots.', { duration: 500 });
        }
      }
    }
    
    // Update Add Model button state
    const currentEmptySlots = parseInt(emptySlotInput.value) || 0;
    updateAddModelButtonState(currentEmptySlots);
  });
}

// *** UPDATED: Helper function to get model number for a lot ***
function getModelForLot(lotId) {
  try {
    // Try to find from checkbox data using correct attribute
    const checkbox = document.querySelector(`.model-select-checkbox[data-stock-lot-id="${lotId}"]`);
    if (checkbox) {
      const modelNo = checkbox.getAttribute('data-model-no');
      if (modelNo) return modelNo;
    }
    
    // Try to find from table row using the correct lot identification
    const row = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
    if (row) {
      const cells = row.querySelectorAll('td');
      if (cells.length > 2) {
        // Get the full plating stock number from the 3rd column (index 2)
        const modelText = cells[2]?.textContent?.trim();
        if (modelText) {
          // FIXED: Don't split - return the full plating stock number
          return modelText; // This will return "2648SAA02" instead of "2648"
        }
      }
    }
    
    return `LOT-${lotId}`;
  } catch (error) {
    console.error('Error getting model for lot:', error);
    return `LOT-${lotId}`;
  }
}


// Helper to deduplicate models by modelNo and lotId
function deduplicateModels(modelArray) {
  const seen = new Set();
  return modelArray.filter(model => {
    const key = `${model.modelNo || model.model_no}-${model.lotId || model.lot_id}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}


// Update selectedModels globally with deduplication
function updateSelectedModels(models) {
  window.selectedModels = deduplicateModels(models);
  // ...existing code to update UI or state...
}


// ENHANCED: clearModalFieldsAfterAddJig function with proper remaining quantity calculation for all selected lots
async function clearModalFieldsAfterAddJig() {
  // *** CRITICAL FIX: Preserve existing tray data BEFORE clearing anything ***
  const preservedTrayData = preserveExistingTrayDataBeforeClear();
  console.log('ðŸ”’ Preserved tray data before clearing:', preservedTrayData);
  
  // ClearJig ID
  document.getElementById('modalJigQrId').value = '';

  // Clear any QR validation errors
  const qrInput = document.getElementById('modalJigQrId');
  const existingError = qrInput.parentNode.querySelector('.qr-validation-error');
  if (existingError) {
    existingError.remove();
  }

  // Clear Broken/Buildup Hooks
  document.getElementById('modalFaultySlots').value = '';

  // *** MODIFIED: Don't clear tray inputs, we'll preserve them ***
  const trayInputs = document.querySelectorAll('#delinkTrayTable input[type="text"]');
  trayInputs.forEach(input => {
    // *** CRITICAL: Don't clear values, just remove validation errors ***
    // input.value = ''; // REMOVED: Don't clear the entered tray IDs
    // Remove any tray validation errors
    const trayErrors = input.parentNode.querySelectorAll('.tray-id-error');
    trayErrors.forEach(error => error.remove());
    input.style.border = ''; // Reset border styling
  });

  // Clear Half Filled Tray inputs
  const halfFilledInputs = document.querySelectorAll('#halfFilledTrayTable input[type="text"]');
  halfFilledInputs.forEach(input => {
    input.value = '';
    // Remove any validation messages
    const validationMsgs = input.parentNode.querySelectorAll('.half-tray-validation');
    validationMsgs.forEach(msg => msg.remove());
    input.style.background = '';
    input.style.borderColor = '';
  });

  // === ENHANCED: REFRESH DATA WITH REMAINING QUANTITY FOR ALL SELECTED LOTS ===
  // Gather all selected lot IDs (including the current modal lot)
  let selectedLotIds = [];
  document.querySelectorAll('.model-select-checkbox:checked').forEach(cb => {
    const lotId = cb.getAttribute('data-stock-lot-id');
    if (lotId) selectedLotIds.push(lotId);
  });
  if (currentModalLotId && !selectedLotIds.includes(currentModalLotId)) {
    selectedLotIds.unshift(currentModalLotId);
  }

  // === UPDATED: Handle both single and multi-model scenarios ===
  const isMultiModel = selectedLotIds.length > 1;
  console.log(`ðŸ”§ Processing ${isMultiModel ? 'MULTI' : 'SINGLE'} model scenario with ${selectedLotIds.length} lots`);
    
  // Filter out fully processed lots (remaining_quantity <= 0)
  let validLotIds = [];
  let lotDataMap = {};
  
  for (const lotId of selectedLotIds) {
    try {
      const response = await fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`);
      const data = await response.json();
      const remainingQty = data.remaining_quantity || 0;
      if (remainingQty > 0) {
        validLotIds.push(lotId);
        lotDataMap[lotId] = data;
        console.log(`âœ… Lot ${lotId}: ${remainingQty} remaining`);
      } else {
        console.log(`âŒ Lot ${lotId}: Fully processed (${remainingQty} remaining)`);
      }
    } catch (error) {
      console.error(`Error fetching data for lot ${lotId}:`, error);
    }
  }

  if (isMultiModel && validLotIds.length > 1) {
    // === MULTI-MODEL LOGIC ===
    console.log('ðŸ”§ Processing multi-model refresh logic');
    
    // Calculate new lot quantities for remaining lots
    const newLotQuantities = {};
    let totalNewQty = 0;
    
    for (const lotId of validLotIds) {
      const data = lotDataMap[lotId];
      const remainingQty = data.remaining_quantity || 0;
      const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
      const displayQty = Math.min(remainingQty, jigCapacity);
      
      if (displayQty > 0) {
        newLotQuantities[lotId] = displayQty;
        totalNewQty += displayQty;
        console.log(`ðŸ“Š Lot ${lotId}: ${displayQty} pieces for next jig`);
      }
    }
    
    if (Object.keys(newLotQuantities).length > 0) {
      // Update modal fields
      document.getElementById('modalLotQty').value = totalNewQty;
      const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
      const newEmptySlots = Math.max(0, jigCapacity - totalNewQty);
        document.getElementById('modalEmptySlots').value = newEmptySlots;
        updateAddModelButtonState(newEmptySlots);
        updateAddJigButtonState(newEmptySlots);  // NEW: Update Add Jig button state
      
      // Update global lot quantities
      window.currentLotIdQuantities = newLotQuantities;      // === CRITICAL FIX: Refresh delink tray table with multi-model backend API ===
      console.log('ðŸš€ Calling multi-model backend API for tray distribution');
      const trayTable = document.getElementById('delinkTrayTable');
      trayTable.innerHTML = `
        <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
        <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
      `;
      
      const populationResult = await populateDelinkTrayTableMultiModel(newLotQuantities, trayTable);
      
      // === CRITICAL FIX: Refresh half-filled tray table with multi-model distribution ===
      if (populationResult && populationResult.distribution) {
        console.log('âœ… Updating half-filled tray table with multi-model distribution');
        populateHalfFilledTrayTableMultiModel(populationResult.distribution);
      } else {
        console.log('âŒ No distribution found, hiding half-filled tray table');
        populateHalfFilledTrayTable([]);
      }
      
      // Show multi-model success message
      let remainingMessages = [];
      for (const lotId of validLotIds) {
        const data = lotDataMap[lotId];
        const remainingQty = data.remaining_quantity || 0;
        remainingMessages.push(`Lot ${lotId}: ${remainingQty} remaining`);
      }
      
      const successMessage = `Multi-model jig added successfully!<br>${remainingMessages.join('<br>')}<br>You can continue adding more jigs or submit when done.`;
      showModalMessage('success', 'Multi-Model Jig Added!', successMessage, { duration: 5000 });
      
    } else {
      showModalMessage('info', 'All Lots Processed', 'All selected lots have been fully processed.', { duration: 500 });
    }
    
  } else {
    // === SINGLE MODEL LOGIC (EXISTING) ===
    console.log('ðŸ”§ Processing single model refresh logic');
    
    // If there are valid lots, show remaining for all; else fallback to original logic
    if (validLotIds.length > 0) {
      let remainingMessages = [];
      for (const lotId of validLotIds) {
        const data = lotDataMap[lotId];
        const remainingQty = data.remaining_quantity || 0;
        const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
        const displayQty = Math.min(remainingQty, jigCapacity);
        if (remainingQty > displayQty) {
          remainingMessages.push(
            `Lot ${lotId}: Remaining quantity: ${remainingQty} (${remainingQty - displayQty} more than jig capacity).`
          );
        } else if (remainingQty > 0) {
          remainingMessages.push(
            `Lot ${lotId}: Remaining quantity: ${remainingQty}.`
          );
        }
      }

      let successMessage = `Jig added successfully!<br>${remainingMessages.join('<br>')}<br>You can continue adding more jigs or submit when done.`;
      showModalMessage('success', 'Jig Added Successfully!', successMessage, { duration: 5000 });

      // Update modal fields for the next lot with available quantity
      let nextLotId = null;
      for (const lotId of validLotIds) {
        const data = lotDataMap[lotId];
        const remainingQty = data.remaining_quantity || 0;
        const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
        const displayQty = Math.min(remainingQty, jigCapacity);
        if (remainingQty > 0) {
          nextLotId = lotId;
          document.getElementById('modalLotQty').value = displayQty;
          const newEmptySlots = Math.max(0, jigCapacity - displayQty);
          document.getElementById('modalEmptySlots').value = newEmptySlots;
          updateAddModelButtonState(newEmptySlots);

          // Update De-link Tray table and Half Filled Tray table for the next lot
          try {
            const trayTable = document.getElementById('delinkTrayTable');
            
            // *** CRITICAL FIX: Preserve entered tray IDs when rebuilding ***
            const preservedTrayData = preserveExistingTrayDataBeforeClear();
            
            trayTable.innerHTML = `
              <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
              <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
            `;
            
            // *** ENHANCED: Use preserved data in population ***
            populateDelinkTrayTableFromCalculationWithPreservedData(data, trayTable, displayQty, preservedTrayData);
            
            // Update Half Filled Tray table (only top tray)
            const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays || []);
            populateHalfFilledTrayTable(topTrayOnly);
          } catch (error) {
            console.error('Error updating tray tables:', error);
          }
          break;
        }
      }
    } else if (currentModalLotId) {
      // Fallback: single lot logic
      try {
        const response = await fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentModalLotId)}`);
        const data = await response.json();
        const remainingQty = data.remaining_quantity || 0;
        const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
        const displayQty = Math.min(remainingQty, jigCapacity);
        document.getElementById('modalLotQty').value = displayQty;
        const newEmptySlots = Math.max(0, jigCapacity - displayQty);
        document.getElementById('modalEmptySlots').value = newEmptySlots;
        updateAddModelButtonState(newEmptySlots);
        updateAddJigButtonState(newEmptySlots);  // NEW: Update Add Jig button state

        let successMessage = `Jig added successfully! `;
        if (remainingQty > displayQty) {
          successMessage += `Remaining quantity: ${remainingQty} (${remainingQty - displayQty} more than jig capacity). `;
        } else if (remainingQty > 0) {
          successMessage += `Remaining quantity: ${remainingQty}. `;
        } else {
          successMessage += `Lot fully processed. `;
        }
        successMessage += `You can continue adding more jigs or submit when done.`;
        showModalMessage('success', 'Jig Added Successfully!', successMessage, { duration: 5000 });

        // Update De-link Tray table and Half Filled Tray table for the current lot
        const trayTable = document.getElementById('delinkTrayTable');
        
        // *** CRITICAL FIX: Preserve entered tray IDs when rebuilding ***
        const preservedTrayData = preserveExistingTrayDataBeforeClear();
        
        trayTable.innerHTML = `
          <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
          <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
        `;
        
        // *** ENHANCED: Use preserved data in population ***
        populateDelinkTrayTableFromCalculationWithPreservedData(data, trayTable, displayQty, preservedTrayData);
        
        // Update Half Filled Tray table (only top tray)
        const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays || []);
        populateHalfFilledTrayTable(topTrayOnly);
      } catch (error) {
        console.error('Error in fallback logic:', error);
        showModalMessage('success', 'Jig Added Successfully!',
          'The jig has been added. Please refresh the page to see updated quantities.',
          { duration: 500 });
      }
    } else {
      // No current modal lot ID - fallback to original behavior
      if (originalModalData) {
        const originalLotQty = parseInt(originalModalData.lotQty) || 0;
        const jigCapacity = parseInt(originalModalData.jigCapacity) || 0;
        const emptySlots = Math.max(0, jigCapacity - originalLotQty);

        document.getElementById('modalLotQty').value = originalLotQty;
        document.getElementById('modalEmptySlots').value = emptySlots;

        updateAddModelButtonState(emptySlots);
        updateAddJigButtonState(emptySlots);  // NEW: Update Add Jig button state

        // Update De-link Tray table with original data
        const trayTable = document.getElementById('delinkTrayTable');
        trayTable.innerHTML = originalModalData.trayTableContent || '';
        
        // Hide Half Filled Tray table for original data
        populateHalfFilledTrayTable([]);
      }
      showModalMessage('success', 'Jig Added Successfully!',
        'The jig has been added. You can continue adding more jigs or submit when done.',
        { duration: 3000 });
    }
  }

  // Focus onJig ID for next entry (only if not disabled)
  setTimeout(() => {
    const jigQrInput = document.getElementById('modalJigQrId');
    if (jigQrInput && !jigQrInput.disabled) {
      jigQrInput.focus();
    }
  }, 100);
  // triggerAutoSave();
}




//Half Filled tray id Validation
document.addEventListener('keydown', function(e) {
  const trayInput = e.target.closest('#halfFilledTrayTable input[type="text"]');
  if (trayInput && (e.key === 'Tab' || e.key === 'Enter')) {
    // Remove previous validation messages
    trayInput.parentNode.querySelectorAll('.half-tray-validation').forEach(div => div.remove());

    const trayId = trayInput.value.trim();
    const lotId = trayInput.getAttribute('data-lot-id') || '';
    let hasError = false;

    // Check against De-link Tray IDs for duplicates
    const delinkTrayInputs = document.querySelectorAll('#delinkTrayTable input[type="text"]');
    let isDuplicate = false;
    delinkTrayInputs.forEach(input => {
      if (
        input.value.trim() === trayId &&
        (input.getAttribute('data-lot-id') || '') === lotId
      ) {
        isDuplicate = true;
      }
    });

    if (isDuplicate) {
      const msg = document.createElement('div');
      msg.className = 'half-tray-validation';
      msg.style.color = '#d32f2f';
      msg.style.fontSize = '11px';
      msg.style.fontWeight = 'bold';
      msg.style.backgroundColor = '#ffebee';
      msg.style.padding = '4px 6px';
      msg.style.borderRadius = '4px';
      msg.style.marginTop = '4px';
      msg.innerHTML = '<div style="color: #d32f2f;">âŒ Duplicate Tray ID not allowed for same Lot!</div>';
      trayInput.parentNode.appendChild(msg);
      trayInput.style.borderColor = '#d32f2f';
      trayInput.style.backgroundColor = '#ffebee';
      trayInput.focus();
      trayInput.select();
      hasError = true;
    }

    // Validate tray ID via API if not duplicate
    if (!hasError && trayId) {
      fetch('/jig_loading/validate_tray_id/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({ tray_id: trayId, lot_id: lotId })
      })
      .then(res => res.json())
      .then(data => {
        // Remove previous success/error messages
        trayInput.parentNode.querySelectorAll('.half-tray-validation').forEach(div => div.remove());
    
        if (!(data.exists && data.lot_match)) {
          // Error message
          const msg = document.createElement('div');
          msg.className = 'half-tray-validation';
          msg.style.color = '#d32f2f';
          msg.style.fontSize = '11px';
          msg.style.fontWeight = 'bold';
          msg.style.backgroundColor = '#ffebee';
          msg.style.padding = '4px 6px';
          msg.style.borderRadius = '4px';
          msg.style.marginTop = '4px';
          msg.innerHTML = '<div style="color: #d32f2f;">âŒ Tray ID not found</div>';
          trayInput.parentNode.appendChild(msg);
          trayInput.style.borderColor = '#d32f2f';
          trayInput.style.backgroundColor = '#ffebee';
          trayInput.focus();
          trayInput.select();
          hasError = true;
        } else {
          // SUCCESS: Show success message
          const successMsg = document.createElement('div');
          successMsg.className = 'half-tray-validation';
          successMsg.style.color = 'green';
          successMsg.style.fontSize = '11px';
          successMsg.style.marginTop = '2px';
          successMsg.textContent = 'Available';
          trayInput.parentNode.appendChild(successMsg);
          trayInput.style.borderColor = '';
          trayInput.style.backgroundColor = '';

          // *** FIXED: SIMULATE TAB BEHAVIOR FOR ENTER ***
          if (e.key === 'Enter') {
            // First try to move to next input in half-filled table
            const allHalfInputs = Array.from(document.querySelectorAll('#halfFilledTrayTable input[type="text"]'));
            const currentIndex = allHalfInputs.indexOf(trayInput);
            
            if (currentIndex !== -1 && currentIndex < allHalfInputs.length - 1) {
              // Move to next row in half-filled table
              allHalfInputs[currentIndex + 1].focus();
              allHalfInputs[currentIndex + 1].select();
            } else {
              // No next row in half-filled table, move to next focusable element (like Tab does)
              const allFocusable = Array.from(document.querySelectorAll('input, button, select, textarea, [tabindex]:not([tabindex="-1"])'));
              const currentFocusIndex = allFocusable.indexOf(trayInput);
              if (currentFocusIndex !== -1 && currentFocusIndex < allFocusable.length - 1) {
                allFocusable[currentFocusIndex + 1].focus();
              }
            }
          }
        }
      });
    }

    // Prevent moving to next field if error OR if Enter key (to handle it manually)
    if (hasError || e.key === 'Enter') {
      e.preventDefault();
    }
  }
});

// ENHANCED: Function to save JIG details with modal messages
async function saveJigDetails(options = {}) {
  try {
    const modalData = collectModalData();
    const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
    const faultySlots = modalData.faulty_slots;
    const emptySlots = modalData.empty_slots;
    const trayRows = document.querySelectorAll('#delinkTrayTable input[type="text"]');
    let delinkTrayError = false;
    
    trayRows.forEach(input => {
      const trayId = input.value.trim();
      const errorDiv = input.parentNode.querySelector('.tray-id-error');
            if (
        !trayId ||
        (errorDiv && (
          errorDiv.textContent.includes('Tray ID not found') ||
          errorDiv.innerHTML.includes('Different Lot') // catch the new error
        ))
      ) {
        delinkTrayError = true;
        // Highlight the input if not already
        input.style.border = '1px solid #dc3545';
      } else {
        input.style.border = '';
      }
    });
    
    if (trayRows.length > 0 && delinkTrayError) {
      showModalMessage('error', 'Validation Error', 'Please fill all De-link Tray IDs correctly. Remove or correct any invalid Tray IDs before saving.');
      return false;
    }

    // Validation with modal messages instead of Swal
    if (!modalData.jig_qr_id) {
      showModalMessage('error', 'Validation Error', 'Jig ID is required');
      return false;
    }
    if (modalData.plating_stock_numbers.length === 0 && modalData.lot_ids.length === 0) {
      showModalMessage('error', 'Validation Error', 'At least one model is required');
      return false;
    }
    if (modalData.lot_ids.length === 0) {
      showModalMessage('error', 'Validation Error', 'At least one lot ID is required');
      return false;
    }

    // Show loading message instead of Swal loading
    const loadingMsg = showModalMessage('info', 'Saving...', 'Please wait while we save the jig details', { duration: 0 });

    // Send data to API
    const response = await fetch('/jig_loading/save_jig_details/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify(modalData)
    });

    const result = await response.json();

    // Remove loading message
    if (loadingMsg && loadingMsg.parentNode) {
      loadingMsg.remove();
    }

    if (result.success) {
      // ðŸ—‘ï¸ NEW: Clear autosave data on successful save
      try {
        const lotId = window.currentLotIds && window.currentLotIds.length > 0 ? window.currentLotIds[0] : null;
        if (lotId) {
          console.log('ðŸ—‘ï¸ Clearing autosave data after successful save for lot:', lotId);
          await fetch(`/jig_loading/autosave/${encodeURIComponent(lotId)}/clear/`, {
            method: 'DELETE',
            credentials: 'include'
          });
          console.log('âœ… Autosave data cleared');
        }
      } catch (clearErr) {
        console.warn('âš ï¸ Error clearing autosave data:', clearErr);
      }

      // Check for alert message (cycle warning)
      if (result.alert) {
        showModalMessage('warning', 'Cycle Warning', result.alert, { duration: 8000 });
      }
      
      // Handle modal behavior based on options
      if (options.keepModalOpen) {
        // For "Add Jig" - keep modal open, clear fields, update with remaining data
        await clearModalFieldsAfterAddJig();

        // --- NEW: Reload modal data from backend to sync lot_id_quantities and other fields ---
        let lotId = window.currentLotIds && window.currentLotIds.length > 0 ? window.currentLotIds[0] : null;
        if (lotId) {
          fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`)
            .then(res => res.json())
            .then(data => {
              // Update modal fields and in-memory variables with fresh data
              // Example: update lot quantities and any other fields as needed
              if (data.lot_id_quantities) {
                window.currentLotIdQuantities = data.lot_id_quantities;
              }
              // Update modal fields if needed
              if (data.display_qty !== undefined) {
                document.getElementById('modalLotQty').value = data.display_qty;
              }
              if (data.jig_capacity !== undefined) {
                document.getElementById('modalJigCapacity').value = data.jig_capacity;
              }
              // Update Half Filled Tray table with fresh data (only top tray)
              const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays || []);
              populateHalfFilledTrayTable(topTrayOnly);
            });
        }
        return true;
      } else {
        // For "Submit" - show success message, close modal and refresh after delay
        showModalMessage('success', 'Success!', result.message, { duration: 3000 });
        setTimeout(() => {
          const modal = document.getElementById('rightSideModal');
          if (modal) {
            modal.classList.remove('open');
            modal.style.display = 'none';
          }
          window.location.reload();
        }, 3500);
        return true;
      }
    } else {
      // Show error message in modal
      showModalMessage('error', 'Save Failed', result.error || 'An error occurred while saving', { duration: 2000 });
      return false;
    }
  } catch (error) {
    // Remove any loading message
    const loadingMsg = document.getElementById('modalMessage');
    if (loadingMsg) loadingMsg.remove();
    
    console.error('Save jig details error:', error);
    showModalMessage('error', 'Network Error', 'Failed to connect to server. Please try again.', { duration: 500 });
    return false;
  }
}

// *** NEW: Add event listener to track manual tray entries ***
document.addEventListener('input', function(e) {
  const input = e.target;
  if (input.type === 'text' && input.closest('#delinkTrayTable')) {
    const trayId = input.value.trim();
    const lotId = input.getAttribute('data-lot-id') || '';
    const index = Array.from(input.closest('#delinkTrayTable').querySelectorAll('input[type="text"]')).indexOf(input);
    
    if (trayId && lotId) {
      console.log(`ðŸ”’ ðŸ“ Manual entry detected: "${trayId}" for lot ${lotId} at index ${index}`);
      trackManualTrayEntry(trayId, lotId, index);
    }
  }
});

// Enhanced button click handlers with pre-save JIG QR ID validation
document.addEventListener('click', async function(e) {
  const draftBtn = e.target.closest('.action-buttons .btn-twitter');
  const submitBtn = e.target.closest('.action-buttons .btn-success');
  
  if (draftBtn && draftBtn.textContent.trim() === 'Add Jig') {
    e.preventDefault();
    const qrId = document.getElementById('modalJigQrId').value.trim();
    if (qrId) {
      const isValid = await validateJigQrIdForAction(qrId);
      if (!isValid) return; // Block if invalid
    }
    // Proceed with existing draft logic
    saveJigDetails({ is_draft: true });
  }
  
  if (submitBtn && submitBtn.textContent.trim() === 'Submit') {
    e.preventDefault();
    const qrId = document.getElementById('modalJigQrId').value.trim();
    if (qrId) {
      const isValid = await validateJigQrIdForAction(qrId);
      if (!isValid) return; // Block if invalid
    }
    // Proceed with existing submit logic
    saveJigDetails({ is_draft: false });
  }
});

// New helper function for button validation (reuses existing logic)
async function validateJigQrIdForAction(qrId) {
  try {
    // Get the current lot_id from modal context
    const lotId = getCurrentLotId();
    console.log('ðŸ” validateJigQrIdForAction: Sending jig_qr_id=', qrId, 'lot_id=', lotId);
    
    const response = await fetch('/jig_loading/validate_jig_qr/', {
      method: 'POST',
      headers: {
        'X-CSRFToken': getCookie('csrftoken'),
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ 
        jig_qr_id: qrId,
        lot_id: lotId,  // Include lot_id for validation
        autosave: false  // This is manual validation, not autosave
      })
    });
    const data = await response.json();
    
    if (!data.valid) {
      showModalMessage('error', data.error, { duration: 5000 });
      disableSubmitButtons();
      return false;
    }
    
    enableSubmitButtons();
    return true;
  } catch (error) {
    showModalMessage('error', 'Validation Error', 'Failed to validate JIG QR ID. Please try again.', { duration: 5000 });
    disableSubmitButtons();
    return false;
  }
}


  // *** ENHANCED: Complete Form Auto-Save System ***
  // Set up comprehensive auto-save for all form fields
  function setupFormAutoSave() {
    const formFields = [
      { id: 'modalJigQrId', type: 'text', autoValidate: true },
      { id: 'modalFaultySlots', type: 'number', autoValidate: false },
      { id: 'modalEmptySlots', type: 'text', autoValidate: false },  // Disabled but might become enabled
      { id: 'modalLotQty', type: 'text', autoValidate: false },      // Disabled but might become enabled
      { id: 'modalJigCapacity', type: 'text', autoValidate: false }, // Disabled but might become enabled
      { id: 'modalBathType', type: 'text', autoValidate: false }     // Disabled but might become enabled
    ];

    console.log('ðŸ”§ Setting up comprehensive form auto-save for', formFields.length, 'fields');

    formFields.forEach(field => {
      const element = document.getElementById(field.id);
      if (element) {
        // Add input event listener for auto-save
        element.addEventListener('input', function() {
          console.log(`ðŸ’¾ Field ${field.id} changed:`, element.value);
          showAutoSaveIndicator(field.id, 'saving');
          
          // Update global status indicator
          const statusIndicator = document.getElementById('autoSaveStatus');
          if (statusIndicator) {
            statusIndicator.style.color = '#ffc107';
            statusIndicator.innerHTML = 'ðŸ’¾ Saving...';
          }
          
          // Trigger auto-save with debouncing
          if (window.triggerAutoSave) {
            window.triggerAutoSave(false); // Use debounced save
          }
        });

        // Add blur event listener for immediate save
        element.addEventListener('blur', function() {
          console.log(`ðŸ”’ Field ${field.id} lost focus:`, element.value);
          showAutoSaveIndicator(field.id, 'saving');
          
          // Update global status indicator
          const statusIndicator = document.getElementById('autoSaveStatus');
          if (statusIndicator) {
            statusIndicator.style.color = '#ffc107';
            statusIndicator.innerHTML = 'ðŸ’¾ Saving...';
          }
          
          // Trigger immediate auto-save
          if (window.triggerAutoSave) {
            window.triggerAutoSave(true); // Use immediate save
          }
        });

        console.log(`âœ… Auto-save setup complete for field: ${field.id}`);
      } else {
        console.warn(`âš ï¸ Field element not found: ${field.id}`);
      }
    });
  }

  // Visual feedback for auto-save operations
  function showAutoSaveIndicator(fieldId, status = 'saving') {
    const field = document.getElementById(fieldId);
    if (!field) return;

    // Remove any existing indicators
    const existingIndicator = field.parentNode.querySelector('.autosave-indicator');
    if (existingIndicator) {
      existingIndicator.remove();
    }

    // Create new indicator
    const indicator = document.createElement('div');
    indicator.className = 'autosave-indicator';
    indicator.style.cssText = `
      position: absolute;
      top: 2px;
      right: 8px;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 500;
      z-index: 100;
      transition: all 0.3s ease;
      pointer-events: none;
    `;

    if (status === 'saving') {
      indicator.style.background = 'linear-gradient(90deg, #ffc107, #fd7e14)';
      indicator.style.color = 'white';
      indicator.innerHTML = 'ðŸ’¾ Saving...';
    } else if (status === 'saved') {
      indicator.style.background = 'linear-gradient(90deg, #28a745, #20c997)';
      indicator.style.color = 'white';
      indicator.innerHTML = 'âœ… Saved';
    } else if (status === 'error') {
      indicator.style.background = 'linear-gradient(90deg, #dc3545, #fd1d53)';
      indicator.style.color = 'white';
      indicator.innerHTML = 'âš ï¸ Error';
    }

    // Position relative to field
    field.parentNode.style.position = 'relative';
    field.parentNode.appendChild(indicator);

    // Auto-remove after 2 seconds for saved/error states
    if (status === 'saved' || status === 'error') {
      setTimeout(() => {
        if (indicator && indicator.parentNode) {
          indicator.style.opacity = '0';
          setTimeout(() => indicator.remove(), 300);
        }
      }, 2000);
    }
  }

  // Global auto-save success/error handler
  window.addEventListener('autosave-success', function() {
    const statusIndicator = document.getElementById('autoSaveStatus');
    if (statusIndicator) {
      statusIndicator.style.color = '#28a745';
      statusIndicator.innerHTML = 'âœ… Auto-saved';
      setTimeout(() => {
        statusIndicator.style.color = '#666';
        statusIndicator.innerHTML = 'ðŸ’¾ Auto-save Ready';
      }, 2000);
    }
    
    document.querySelectorAll('.autosave-indicator').forEach(indicator => {
      indicator.style.background = 'linear-gradient(90deg, #28a745, #20c997)';
      indicator.innerHTML = 'âœ… Saved';
    });
  });

  window.addEventListener('autosave-error', function() {
    const statusIndicator = document.getElementById('autoSaveStatus');
    if (statusIndicator) {
      statusIndicator.style.color = '#dc3545';
      statusIndicator.innerHTML = 'âš ï¸ Save Error';
      setTimeout(() => {
        statusIndicator.style.color = '#666';
        statusIndicator.innerHTML = 'ðŸ’¾ Auto-save Ready';
      }, 3000);
    }
    
    document.querySelectorAll('.autosave-indicator').forEach(indicator => {
      indicator.style.background = 'linear-gradient(90deg, #dc3545, #fd1d53)';
      indicator.innerHTML = 'âš ï¸ Error';
    });
  });

  // *** NEW: Setup monitoring for tray data changes ***
  function setupTrayAutoSaveMonitoring() {
    console.log('ðŸ”§ Setting up tray data auto-save monitoring');
    
    // Monitor changes to delink tray table
    const delinkTable = document.getElementById('delinkTrayTable');
    if (delinkTable) {
      const observer = new MutationObserver(function(mutations) {
        let hasChanges = false;
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
            hasChanges = true;
          }
        });
        
        if (hasChanges) {
          console.log('ðŸ“¦ Delink tray table changed, triggering auto-save');
          const statusIndicator = document.getElementById('autoSaveStatus');
          if (statusIndicator) {
            statusIndicator.style.color = '#ffc107';
            statusIndicator.innerHTML = 'ðŸ’¾ Saving Trays...';
          }
          
          if (window.triggerAutoSave) {
            window.triggerAutoSave(true); // Immediate save for tray data
          }
        }
      });
      
      observer.observe(delinkTable, { 
        childList: true, 
        subtree: true 
      });
      console.log('âœ… Delink tray table monitoring active');
    }
    
    // Monitor changes to half-filled tray table
    const halfFilledTable = document.getElementById('halfFilledTrayTable');
    if (halfFilledTable) {
      const observer = new MutationObserver(function(mutations) {
        let hasChanges = false;
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
            hasChanges = true;
          }
        });
        
        if (hasChanges) {
          console.log('ðŸ“¦ Half-filled tray table changed, triggering auto-save');
          const statusIndicator = document.getElementById('autoSaveStatus');
          if (statusIndicator) {
            statusIndicator.style.color = '#ffc107';
            statusIndicator.innerHTML = 'ðŸ’¾ Saving Trays...';
          }
          
          if (window.triggerAutoSave) {
            window.triggerAutoSave(true); // Immediate save for tray data
          }
        }
      });
      
      observer.observe(halfFilledTable, { 
        childList: true, 
        subtree: true 
      });
      console.log('âœ… Half-filled tray table monitoring active');
    }
  }

  // *** NEW: Setup monitoring for model selection changes ***
  function setupModelSelectionMonitoring() {
    console.log('ðŸ”§ Setting up model selection auto-save monitoring');
    
    // Monitor the model slider for changes
    const modelSlider = document.getElementById('modelSliderDynamic');
    if (modelSlider) {
      const observer = new MutationObserver(function(mutations) {
        let hasChanges = false;
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
            hasChanges = true;
          }
        });
        
        if (hasChanges) {
          console.log('ðŸŽ¯ Model selection changed, triggering auto-save');
          const statusIndicator = document.getElementById('autoSaveStatus');
          if (statusIndicator) {
            statusIndicator.style.color = '#ffc107';
            statusIndicator.innerHTML = 'ðŸ’¾ Saving Models...';
          }
          
          if (window.triggerAutoSave) {
            window.triggerAutoSave(true); // Immediate save for model changes
          }
        }
      });
      
      observer.observe(modelSlider, { 
        childList: true, 
        subtree: true 
      });
      console.log('âœ… Model selection monitoring active');
    }
    
    // Also monitor model checkboxes if they exist
    document.addEventListener('change', function(event) {
      if (event.target.classList.contains('model-select-checkbox')) {
        console.log('ðŸ“¦ Model checkbox changed, triggering auto-save');
        if (window.triggerAutoSave) {
          window.triggerAutoSave(true);
        }
      }
    });
  }

  // *** NEW: Setup monitoring for cycle count changes ***
  function setupCycleCountMonitoring() {
    console.log('ðŸ”§ Setting up cycle count auto-save monitoring');
    
    const cycleCountElement = document.getElementById('cycleCount');
    if (cycleCountElement) {
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            const newValue = cycleCountElement.textContent || '-/-';
            console.log('ðŸ”„ Cycle count changed to:', newValue);
            
            const statusIndicator = document.getElementById('autoSaveStatus');
            if (statusIndicator) {
              statusIndicator.style.color = '#ffc107';
              statusIndicator.innerHTML = 'ðŸ’¾ Saving Cycle...';
            }
            
            if (window.triggerAutoSave) {
              window.triggerAutoSave(true); // Immediate save for cycle changes
            }
          }
        });
      });
      
      observer.observe(cycleCountElement, { 
        childList: true, 
        subtree: true, 
        characterData: true 
      });
      console.log('âœ… Cycle count monitoring active');
    }
  }

  // Add QR ID validation on input (enhanced)
const jigQrInput = document.getElementById('modalJigQrId');
if (jigQrInput) {
  jigQrInput.addEventListener('input', async function() {
    const qrId = jigQrInput.value.trim();
    console.log('ðŸ” JIG QR ID entered:', qrId);
    if (!qrId) {
      showQrValidationMessage('info', 'Enter Jig ID');
      return;
    }
    try {
      // Get the current lot_id from modal context
      const lotId = getCurrentLotId();
      console.log('ðŸ” input event: Sending jig_qr_id=', qrId, 'lot_id=', lotId);
      
      const res = await fetch('/jig_loading/validate_jig_qr/', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json', 
          'X-CSRFToken': getCookie('csrftoken') 
        },
        body: JSON.stringify({ 
          jig_qr_id: qrId,
          lot_id: lotId  // Include lot_id for autosave
        })
      });
      const result = await res.json();
      
      // âœ… FIXED: Check 'valid' property and disable buttons properly
      if (result.valid) {
        showQrValidationMessage('success', 'Jig ID is available');
        enableSubmitButtons();
      } else {
        showQrValidationMessage('error', result.error);
        disableSubmitButtons();
      }
    } catch (e) {
      showQrValidationMessage('error', 'Network error');
      disableSubmitButtons();
    }
  });
}

function enableSubmitButtons() {
  document.querySelectorAll('.action-buttons button').forEach(btn => {
    if (btn.textContent.includes('Draft') || btn.textContent.includes('Submit')) {
      btn.disabled = false;
      btn.style.opacity = '1';
    }
  });
}

function disableSubmitButtons() {
  document.querySelectorAll('.action-buttons button').forEach(btn => {
    if (btn.textContent.includes('Draft') || btn.textContent.includes('Submit')) {
      btn.disabled = true;
      btn.style.opacity = '0.5';
    }
  });
}

  // Function to update Add Model button and checkbox states
  function updateAddModelButtonState(emptySlots) {
    const addModelBtn = document.querySelector('.btn-action.teal');
    if (addModelBtn) {
      if (emptySlots <= 0) {
        addModelBtn.disabled = true;
        addModelBtn.style.opacity = '0.5';
        addModelBtn.style.cursor = 'not-allowed';
        addModelBtn.style.pointerEvents = 'none';
        addModelBtn.title = 'Cannot add more models - No empty slots available';
      } else {
        addModelBtn.disabled = false;
        addModelBtn.style.opacity = '1';
        addModelBtn.style.cursor = 'pointer';
        addModelBtn.style.pointerEvents = 'auto';
        addModelBtn.title = `${emptySlots} slots available`;
      }
    }
    
    // Also update checkbox states
    if (emptySlots <= 0) {
      document.querySelectorAll('.model-select-checkbox').forEach(function(cb) {
        if (cb.style.display !== 'none') {
          cb.disabled = true;
          cb.style.opacity = '0.5';
          cb.style.cursor = 'not-allowed';
          cb.title = 'Cannot select - No slots available';
          
          const row = cb.closest('tr');
          if (row) {
            row.style.opacity = '0.7';
            row.style.pointerEvents = 'none';
          }
        }
      });
    } else {
      document.querySelectorAll('.model-select-checkbox').forEach(function(cb) {
        if (cb.style.display !== 'none') {
          cb.disabled = false;
          cb.style.opacity = '1';
          cb.style.cursor = 'pointer';
          cb.title = '';
          
          const row = cb.closest('tr');
          if (row) {
            row.style.opacity = '1';
            row.style.pointerEvents = 'auto';
          }
        }
      });
    }
  }

// NEW: Function to update Add Jig button state based on empty slots
function updateAddJigButtonState(emptySlots) {
  const addJigBtn = document.querySelector('.action-buttons .btn-twitter');
  if (addJigBtn) {
    if (emptySlots <= 0) {
      addJigBtn.disabled = true;
      addJigBtn.style.opacity = '0.5';
      addJigBtn.style.cursor = 'not-allowed';
      addJigBtn.title = 'Cannot add jig - No empty slots available';
    } else {
      addJigBtn.disabled = false;
      addJigBtn.style.opacity = '1';
      addJigBtn.style.cursor = 'pointer';
      addJigBtn.title = 'Add jig as draft';
    }
  }
}


// Enhanced createModelItem function with cross icon for added models
function createModelItem(modelData) {
    // Consistent color assignment based on lot ID hash for stability
    const getColorForLot = (lotId) => {
        if (!lotId) return 'bg-1';
        // Simple hash function to get consistent color for same lot
        let hash = 0;
        for (let i = 0; i < lotId.length; i++) {
            hash = ((hash << 5) - hash + lotId.charCodeAt(i)) & 0x7fffffff;
        }
        return `bg-${(hash % 5) + 1}`;
    };
    
    const colorClass = getColorForLot(modelData.lotId);

    const item = document.createElement('div');
    item.className = `model-loaded-item ${colorClass}`;
    item.style = 'min-width: 100px; flex: 0 0 auto; margin-right: 12px; display: flex; align-items: center; border: 1px solid #28a745; border-radius: 12px; padding: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); position: relative;';
    
    // Determine if this is primary or added model
    const isPrimary = modelData.isOriginal !== false;
    const statusText = isPrimary ? '' : '';
    const statusColor = isPrimary ? '#666' : '#28a745';
    
    // CRITICAL FIX: Always ensure lot ID is stored
    if (modelData.lotId) {
        item.setAttribute('data-lot-id', modelData.lotId);
        console.log(`Set data-lot-id="${modelData.lotId}" for model ${modelData.modelNo}`);
    } else {
        console.error(`No lotId provided for model ${modelData.modelNo}`);
    }
    
    // Model Image Loaded Section - Alignment and Logic 
    item.innerHTML = `
        
        <div style="flex: 1;">
            <div style="font-size: 14px; font-weight: bold; color: #333; margin-bottom: 2px;">${modelData.modelNo}</div>
            <div style="font-size: 12px; color: ${statusColor};">${statusText}</div>
        </div>
        ${!isPrimary ? `
            <button class="remove-model-btn" style="
                position: absolute;
                top: -11px;
                right: -13px;
                width: 24px;
                height: 24px;
                border-radius: 50%;
                background: #dc3545;
                border: 2px solid white;
                color: white;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                z-index: 10;
            " title="Remove this model from selection">Ã—</button>
        ` : ''}
    `;
    
    // Add click handler for cross icon
    if (!isPrimary) {
        const removeBtn = item.querySelector('.remove-model-btn');
        if (removeBtn) {
            removeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                
                // ENHANCED FIX: Get lot ID from multiple sources
                let lotIdToRemove = modelData.lotId;
                if (!lotIdToRemove) {
                    lotIdToRemove = item.getAttribute('data-lot-id');
                }
                if (!lotIdToRemove && window.currentLotIds && window.currentLotIds.length > 1) {
                    // Fallback: use the last lot ID in currentLotIds (since first is primary)
                    lotIdToRemove = window.currentLotIds[window.currentLotIds.length - 1];
                }
                
                console.log(`Attempting to remove model ${modelData.modelNo} with lot ID: ${lotIdToRemove}`);
                removeModelFromSelection(lotIdToRemove, modelData.modelNo);
            });
            
            // Add hover effects
            removeBtn.addEventListener('mouseenter', function() {
                this.style.background = '#c82333';
                this.style.transform = 'scale(1.1)';
            });
            
            removeBtn.addEventListener('mouseleave', function() {
                this.style.background = '#dc3545';
                this.style.transform = 'scale(1)';
            });
        }
    }
    
    return item;
}

// Render the model slider with unique models
function renderModelSlider(models) {
  const uniqueModels = deduplicateModels(models);
  const slider = document.getElementById('modelSliderDynamic');
  slider.innerHTML = '';
  uniqueModels.forEach(modelData => {
    const item = createModelItem(modelData);
    slider.appendChild(item);
  });
}



// Function to remove specific model from multi-model selection
async function removeModelFromSelection(lotId, modelNo) {
    if (!lotId) {
        console.error('No lot ID provided for removal');
        return;
    }
    
    console.log(`Removing model ${modelNo} (lot: ${lotId}) from selection`);
    
    try {
        // 1. Clear draft for this specific lot_id
        const response = await fetch('/jig_loading/clear_specific_lot_draft/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                lot_id: lotId
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // 2. Remove from global tracking arrays
            if (window.currentLotIds) {
                window.currentLotIds = window.currentLotIds.filter(id => id !== lotId);
            }
            
            if (window.currentLotIdQuantities) {
                delete window.currentLotIdQuantities[lotId];
            }
            
            // 3. Uncheck the corresponding checkbox in table
            const checkbox = document.querySelector(`.model-select-checkbox[data-stock-lot-id="${lotId}"]`);
            if (checkbox) {
                checkbox.checked = false;
                // *** NEW: Dispatch change event to trigger UI updates (slider rebuild, etc.) ***
                checkbox.dispatchEvent(new Event('change'));
                console.log(`Unchecked checkbox for lot: ${lotId}`);
            }
            
            // 4. Remove from selection order tracking
            if (window.checkboxSelectionOrder) {
                const index = checkboxSelectionOrder.indexOf(lotId);
                if (index > -1) {
                    checkboxSelectionOrder.splice(index, 1);
                    console.log('Updated selection order:', checkboxSelectionOrder);
                }
            }
            
            // *** NEW: Instant recalculation of modal fields ***
            const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
            const totalCasesLoaded = Object.values(window.currentLotIdQuantities || {}).reduce((sum, qty) => sum + (parseInt(qty) || 0), 0);
            const faultySlots = parseInt(document.getElementById('modalFaultySlots').value) || 0;
            const emptySlots = Math.max(0, jigCapacity - totalCasesLoaded - faultySlots);
            
            document.getElementById('modalLotQty').value = totalCasesLoaded;
            document.getElementById('modalEmptySlots').value = emptySlots;
            
            // Update button states instantly
            updateAddModelButtonState(emptySlots);
            updateAddJigButtonState(emptySlots);
            
            console.log(`Instant recalc: Jig Capacity=${jigCapacity}, Total Cases=${totalCasesLoaded}, Faulty Slots=${faultySlots}, Empty Slots=${emptySlots}`);


            
            // *** OPTIONAL: Still rebuild modal for consistency (comment out if not needed) ***
            // await rebuildModalFromBackendData();
            
            // 6. Update selected items status
            if (typeof updateSelectedItemsStatus === 'function') {
                updateSelectedItemsStatus();
            }
            
            showToast('success', `Model ${modelNo} removed from selection`, 1500);
            
        } else {
            showToast('error', result.error || 'Failed to remove model', 2000);
        }
        
    } catch (error) {
        console.error('Error removing model:', error);
        showToast('error', 'Network error while removing model', 2000);
    }
}

// NEW FUNCTION: Rebuild modal by fetching fresh data from backend
async function rebuildModalFromBackendData() {
    const remainingLotIds = window.currentLotIds || [];
    const remainingQuantities = window.currentLotIdQuantities || {};
    
    console.log('ðŸ”„ Rebuilding modal from fresh backend data for lots:', remainingLotIds);
    
    if (remainingLotIds.length === 0) {
        // No models left - close modal
        const modal = document.getElementById('rightSideModal');
        if (modal) {
            modal.classList.remove('open');
            modal.style.display = 'none';
        }
        showToast('info', 'All models removed - modal closed', 1500);
        return;
    }
    
    if (remainingLotIds.length === 1) {
        // *** SINGLE MODEL: Fetch fresh backend data and rebuild ***
        console.log('ðŸ”„ Single model remaining - fetching fresh data from backend');
        
        try {
            const lotId = remainingLotIds[0];
            const response = await fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`);
            const data = await response.json();
            
            console.log('ðŸ”„ Fresh backend data:', data);
            
            // Update modal title
            document.getElementById('rightModalModelNo').textContent = data.plating_stk_no || '-';
            
            // Update quantities from fresh data
            const finalLotQty = data.display_qty || 0;
            const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
            const emptySlots = Math.max(0, jigCapacity - finalLotQty);
            
            document.getElementById('modalLotQty').value = finalLotQty;
            document.getElementById('modalEmptySlots').value = emptySlots;
            
            // Rebuild single model slider
            const slider = document.getElementById('modelSliderDynamic');
            slider.innerHTML = '';
            
            const modelData = {
                modelNo: data.plating_stk_no || '-',
                image: (data.model_images && data.model_images.length > 0) ? data.model_images[0] : '/static/assets/images/imagePlaceholder.png',
                isOriginal: true
            };
            const item = createModelItem(modelData);
            slider.appendChild(item);
            
            // *** CRITICAL FIX: Use backend's actual tray count, not frontend assumptions ***
            const trayTable = document.getElementById('delinkTrayTable');
            trayTable.innerHTML = `
                <div style="background: #dcdcdc; font-weight: bold;">S.No</div>
                <div style="background: #dcdcdc; font-weight: bold;">Tray ID</div>
            `;
            
            // Check if backend has draft data for this lot
            let backendDraftTrays = [];
            if (data.draft_data && data.draft_data.delink_tray_data) {
                backendDraftTrays = data.draft_data.delink_tray_data.filter(tray => tray.tray_id && tray.tray_id.trim());
                console.log('ðŸ”„ Backend has draft tray data:', backendDraftTrays.length, 'entries');
            }
            
            if (backendDraftTrays.length > 0) {
                // Use backend draft data - this gives us the EXACT count
                console.log('ðŸ”„ Using backend draft tray data (exact count)');
                backendDraftTrays.forEach((tray, index) => {
                    console.log(`ðŸ”„ Adding backend draft row ${index + 1}: ${tray.tray_id}`);
                    trayTable.innerHTML += `
                        <div>${index + 1}</div>
                        <div>
                            <input type="text"
                                value="${tray.tray_id}"
                                placeholder="${data.plating_stk_no} - Scan Tray ID"
                                data-lot-id="${tray.lot_id || lotId}"
                                data-expected-usage="${tray.expected_usage || 0}"
                                data-from-draft="true"
                                style="width:100%; border:none; background:transparent; border: 1px solid #007bff; background: rgba(255,255,255,0.95);" />
                        </div>
                    `;
                });
                
                // Add summary showing exact backend count
                trayTable.innerHTML += `
                    <div style="grid-column: span 2; text-align:center; padding: 8px; background: #e8f5e8; color: #155724; font-size: 11px; border-radius: 4px; margin-top: 5px;">
                        âœ… Backend sync: ${backendDraftTrays.length} draft entries (exact match)
                    </div>
                `;
                
                console.log(`ðŸŽ¯ EXACT MATCH: ${backendDraftTrays.length} rows from backend draft data`);
                
            } else {
                // Use fresh calculation from backend
                console.log('ðŸ”„ No backend draft - using fresh calculation');
                populateDelinkTrayTableFromCalculation(data, trayTable, finalLotQty);
            }
            
            // Update half filled trays
            const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays || []);
            populateHalfFilledTrayTable(topTrayOnly);
            
            console.log('ðŸ”„ Successfully rebuilt single model from backend data');
            
        } catch (error) {
            console.error('ðŸ”„ Error rebuilding from backend data:', error);
        }
        
    } else {
        // Multi-model mode - use existing logic
        console.log('ðŸ”„ Multi-model remaining - using existing rebuild logic');
        await rebuildModalAfterRemoval();
    }
    
    // Update Add Model button state
    const currentEmptySlots = parseInt(document.getElementById('modalEmptySlots').value) || 0;
    updateAddModelButtonState(currentEmptySlots);
}
// Function to update slider position
  function updateSliderPosition() {
    const slider = document.getElementById('modelSliderDynamic');
    const container = document.querySelector('.model-slider-container');
    if (!slider || !container) return;
    
    const containerWidth = container.offsetWidth;
    const visibleItems = Math.floor(containerWidth / itemWidth);
    const totalItems = slider.children.length;
    
    // Update button visibility
    const prevBtn = document.querySelector('.prev-btn');
    const nextBtn = document.querySelector('.next-btn');
    
    if (prevBtn) prevBtn.style.display = currentSlideIndex > 0 ? 'block' : 'none';
    if (nextBtn) nextBtn.style.display = (currentSlideIndex + visibleItems < totalItems) ? 'block' : 'none';
    
    // Update slider position
    slider.style.transform = `translateX(-${currentSlideIndex * itemWidth}px)`;
  }

  // Function to store original modal data
  function storeOriginalModalData() {
    if (!originalModalData) {
      originalModalData = {
        modelNo: document.getElementById('rightModalModelNo').textContent,
        bathType: document.getElementById('modalBathType').value,
        jigCapacity: document.getElementById('modalJigCapacity').value,
        lotQty: document.getElementById('modalLotQty').value,
        trayTableContent: document.getElementById('delinkTrayTable').innerHTML
      };
      console.log('Original modal data stored:', originalModalData);
    }
  }

  // Function to update selected items status
  function updateSelectedItemsStatus() {
    const checkedBoxes = document.querySelectorAll('.model-select-checkbox:checked');
    const statusDiv = document.getElementById('selectedItemsStatus');
    const countSpan = document.getElementById('selectedCount');
    
    if (checkedBoxes.length > 0) {
      if (statusDiv) {
        statusDiv.style.display = 'block';
        if (countSpan) countSpan.textContent = checkedBoxes.length;
      }
    } else {
      if (statusDiv) statusDiv.style.display = 'none';
    }
    
    // Highlight selected rows
    document.querySelectorAll('tbody tr').forEach(row => {
      const checkbox = row.querySelector('.model-select-checkbox');
      if (checkbox && checkbox.checked) {
        row.classList.add('checkbox-selected');
      } else {
        row.classList.remove('checkbox-selected');
      }
    });
  }

// Function to preserve existing tray data before rebuilding the table
function preserveExistingTrayData() {
  const existingTrayData = [];
  const trayTable = document.getElementById('delinkTrayTable');
  const trayRows = trayTable.querySelectorAll('div');
  
  // UPDATED: Process tray table in groups of 2 (S.No, Tray ID input) instead of 3
  for (let i = 2; i < trayRows.length; i += 2) { // Start from index 2 to skip headers
    const sNoDiv = trayRows[i];
    const trayIdDiv = trayRows[i + 1];

    if (sNoDiv && trayIdDiv) {
      const trayInput = trayIdDiv.querySelector('input[type="text"]');
      const trayId = trayInput ? trayInput.value.trim() : '';
      const lotId = trayInput ? trayInput.getAttribute('data-lot-id') || '' : '';

      // Store without tray_quantity since we removed that column
      existingTrayData.push({
        tray_id: trayId,
        lot_id: lotId
      });
    }
  }
  
  return existingTrayData;
}

// *** ENHANCED: Function specifically for preserving before clearing ***
function preserveExistingTrayDataBeforeClear() {
  const preservedData = [];
  const trayTable = document.getElementById('delinkTrayTable');
  
  console.log('ðŸ”’ ðŸ” Starting comprehensive tray preservation...');
  console.log('ðŸ”’ ðŸ“‹ Tray table exists:', !!trayTable);
  
  if (!trayTable) {
    console.log('ðŸ”’ âŒ No tray table found to preserve');
    return preservedData;
  }
  
  // Debug: Log current table structure
  console.log('ðŸ”’ ðŸ“‹ Table innerHTML length:', trayTable.innerHTML.length);
  console.log('ðŸ”’ ðŸ“‹ Table first 200 chars:', trayTable.innerHTML.substring(0, 200));
  
  // Try multiple selectors to find inputs
  const selectors = [
    'input[type="text"][data-lot-id]',
    'input[type="text"]',
    'input[data-lot-id]',
    'div input[type="text"]'
  ];
  
  let foundInputs = [];
  for (const selector of selectors) {
    const inputs = trayTable.querySelectorAll(selector);
    console.log(`ðŸ”’ ðŸ“‹ Selector "${selector}": found ${inputs.length} inputs`);
    if (inputs.length > 0) {
      foundInputs = Array.from(inputs);
      break;
    }
  }
  
  console.log(`ðŸ”’ ðŸ“‹ Using ${foundInputs.length} inputs for preservation`);
  
  // Process the found inputs
  foundInputs.forEach((input, index) => {
    const trayId = input.value ? input.value.trim() : '';
    const lotId = input.getAttribute('data-lot-id') || 
                  input.closest('[data-lot-id]')?.getAttribute('data-lot-id') || 
                  input.dataset.lotId || '';
    const expectedUsage = parseInt(input.getAttribute('data-expected-usage')) || 0;
    const fromDraft = input.getAttribute('data-from-draft') === 'true';
    
    console.log(`ðŸ”’ ðŸ“ Input ${index + 1}: value="${input.value}", trayId="${trayId}", lotId="${lotId}", fromDraft=${fromDraft}`);
    
    if (trayId || lotId) { // Preserve both filled and empty slots with lot assignments
      preservedData.push({
        tray_id: trayId,
        lot_id: lotId,
        expected_usage: expectedUsage,
        from_draft: fromDraft,
        row_index: index + 1,
        preserved_at: Date.now()
      });
      console.log(`ðŸ”’ âœ… Preserved ${trayId ? 'FILLED' : 'EMPTY'} slot ${index + 1}: "${trayId}" for lot ${lotId}`);
      
      // Track manually entered data for future use
      if (trayId && !fromDraft) {
        trackManualTrayEntry(trayId, lotId, index);
      }
    }
  });
  
  // Also include any manually entered data from our tracking map
  window.manuallyEnteredTrayData.forEach((data, key) => {
    const exists = preservedData.find(p => p.tray_id === data.tray_id && p.lot_id === data.lot_id);
    if (!exists && data.tray_id.trim()) {
      console.log(`ðŸ”’ ðŸ“¥ Adding tracked manual entry: ${data.tray_id} for lot ${data.lot_id}`);
      preservedData.push({
        tray_id: data.tray_id,
        lot_id: data.lot_id,
        expected_usage: 0,
        from_draft: false,
        row_index: data.row_index,
        manually_tracked: true
      });
    }
  });
  
  console.log(`ðŸ”’ ðŸ“Š FINAL preservation result: ${preservedData.length} entries`);
  preservedData.forEach((entry, i) => {
    const source = entry.from_draft ? 'DRAFT' : (entry.manually_tracked ? 'TRACKED' : (entry.fallback_capture ? 'FALLBACK' : 'CURRENT'));
    console.log(`ðŸ”’   ${i+1}. TrayID="${entry.tray_id}", LotID="${entry.lot_id}", Source=${source}`);
  });
  
  return preservedData;
}

// *** NEW: Enhanced population function that preserves entered tray IDs ***
function populateDelinkTrayTableFromCalculationWithPreservedData(data, trayTable, displayQty, preservedTrayData = []) {
  console.log('ðŸ”§ Populating tray table with preserved data:', preservedTrayData.length, 'entries');
  
  // Clear previous rows except headers (already done by caller)
  
  if (data.trays && data.trays.length > 0) {
    // Show optimal tray distribution based on physical constraints
    data.trays.forEach((tray, idx) => {
      // Use plating_stk_no from API data first, then fallback
      const modelForPlaceholder =
        data.plating_stk_no ||
        tray.plating_stk_no ||
        getModelForLot(tray.lot_id || data.stock_lot_id || currentModalLotId) ||
        'Model';

      // *** CRITICAL FIX: Check if we have preserved data for this row ***
      const preservedEntry = preservedTrayData[idx];
      const trayIdValue = preservedEntry && preservedEntry.tray_id ? preservedEntry.tray_id : '';
      
      console.log(`ðŸ”§ Row ${idx + 1}: Using preserved tray ID "${trayIdValue}" for ${modelForPlaceholder}`);

      // Create hint for expected usage
      const usageHint = `Expected: ${tray.used_quantity} pieces (Complete)`;
      
      // *** ENHANCED: Show preserved tray ID if available ***
      const inputStyle = trayIdValue ? 'width:100%; border:1px solid #007bff; background:rgba(255,255,255,0.95);' : 'width:100%; border:none; background:transparent;';
      const preservedTitle = trayIdValue ? `Preserved: ${trayIdValue} (${usageHint})` : usageHint;

      trayTable.innerHTML += `
        <div>${idx + 1}</div>
        <div>
          <input type="text"
            value="${trayIdValue}"
            placeholder="${modelForPlaceholder} - Scan Tray ID"
            data-lot-id="${tray.lot_id || data.stock_lot_id || currentModalLotId}"
            data-expected-usage="${tray.used_quantity}"
            data-is-top-tray="false"
            data-original-tray-qty="${tray.original_tray_quantity || tray.tray_quantity}"
            data-theoretical="true"
            data-preserved="${trayIdValue ? 'true' : 'false'}"
            title="${preservedTitle}"
            style="${inputStyle}"
          />
        </div>
      `;
    });

    // Add info about preservation
    const preservedCount = preservedTrayData.filter(p => p.tray_id).length;
    if (preservedCount > 0) {
      trayTable.innerHTML += `
        <div style="grid-column: span 2; text-align:center; padding: 8px; background: #e8f5e8; color: #155724; font-size: 11px; border-radius: 4px; margin-top: 5px;">
          âœ… Preserved ${preservedCount} entered tray IDs during rebuild
        </div>
      `;
    }

    // Add info about remaining quantity if any
    const totalUsedInDelink = data.trays.reduce(
      (sum, tray) => sum + (tray.used_quantity || 0),
      0
    );
    const remainingQty = displayQty - totalUsedInDelink;
    console.log(`Total used in delink trays: ${totalUsedInDelink}, Remaining qty: ${remainingQty}`);

    if (remainingQty > 0) {
      trayTable.innerHTML += `
        <div style="grid-column: span 2; text-align:center; padding: 10px; background: #e8f5e8; color: #155724; font-size: 11px; border-radius: 4px; margin-top: 5px;">
          â„¹ï¸ ${remainingQty} remaining cases yet to be loaded
        </div>
      `;
    }
  } else {
    trayTable.innerHTML += `
      <div style="grid-column: span 2; text-align:center; padding: 20px; color: #666;">
        No optimal distribution found for quantity ${displayQty}
      </div>
    `;
  }
  
  console.log('ðŸ”§ Tray table population complete with preserved data');
}

// Handle opening of individual jig modal (enhanced with draft delink tray support)
document.querySelectorAll('.open-jig-modal-btn').forEach(function(btn) {
  btn.addEventListener('click', async function(e) {
    e.preventDefault();
    const lotId = btn.getAttribute('data-stock-lot-id');
    if (!lotId) return;
    window.initialLotId = lotId; 
    window.currentLotIds = [lotId];

    currentModalLotId = lotId;
    originalModalData = null; // Reset for new modal
    currentSlideIndex = 0; // Reset slider

    // Show modal
    currentModalLotId = lotId;

// Add this line right after:
const modal = document.getElementById('rightSideModal');
if (modal) {
    modal.dataset.currentLotId = lotId; // Store in modal for auto-save reference
    modal.classList.add('open');
    modal.classList.remove('minimized');
}

    // === FOCUS LOGIC: Set focus based on data loading completion ===
    setTimeout(function focusNextEmptyInput() {
      const jigInput = document.getElementById('modalJigQrId');
      
      // Wait for all data to be loaded and DOM to be ready
      setTimeout(() => {
        const currentJigValue = jigInput ? jigInput.value.trim() : '';
        
        if (currentJigValue !== '') {
          // Jig ID has value, focus next empty tray input
          console.log('ðŸ” Jig ID has value, looking for empty tray input');
          const trayInputs = document.querySelectorAll('#delinkTrayTable input[type="text"]');
          let focused = false;
          
          for (let i = 0; i < trayInputs.length; i++) {
            if (trayInputs[i].value.trim() === '') {
              console.log('âœ… Focusing empty tray input at index:', i);
              trayInputs[i].focus();
              trayInputs[i].select();
              focused = true;
              break;
            }
          }
          
          if (!focused) {
            console.log('â„¹ï¸ All tray inputs filled, no focus change');
          }
        } else if (jigInput) {
          // Jig ID is empty, focus it
          console.log('âœ… Focusing empty Jig ID input');
          jigInput.focus();
          jigInput.select();
        }
      }, 500); // Additional delay to ensure all data is loaded
    }, 200);

    // ðŸ”§ NEW: Setup comprehensive form auto-save when modal opens
    setupFormAutoSave();
    
    // *** NEW: Setup tray data auto-save monitoring ***
    setupTrayAutoSaveMonitoring();
    
    // *** NEW: Setup monitoring for model selection changes ***
    setupModelSelectionMonitoring();
    
    // *** NEW: Setup monitoring for cycle count changes ***
    setupCycleCountMonitoring();

    // ðŸ”„ NEW: Check for existing autosave data before loading API data
    let autosaveData = null;
    try {
        console.log(`ðŸ” Checking for autosave data for lot: ${lotId}`);
        const autosaveRes = await fetch(`/jig_loading/autosave/${encodeURIComponent(lotId)}/`, {
            credentials: 'include'
        });
        const autosaveJson = await autosaveRes.json();
        
        if (autosaveJson.success && autosaveJson.autosave) {
            autosaveData = autosaveJson.autosave;
            console.log('âœ… Found autosave data:', autosaveData);
        } else {
            console.log('â„¹ï¸ No autosave data found');
        }
    } catch (autoSaveErr) {
        console.warn('âš ï¸ Error checking autosave:', autoSaveErr);
    }

    // Fetch data from API
    try {
      const res = await fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`);
      const data = await res.json();
      console.log("API response:", data);

      // Fill basic modal fields first
      document.getElementById('rightModalModelNo').textContent = data.plating_stk_no || '-';
      document.getElementById('modalBathType').value = data.ep_bath_type || '';
      document.getElementById('modalJigCapacity').value = data.jig_capacity || '';
      
      // ðŸ”„ ENHANCED: Use autosave data if available, otherwise use defaults
      if (autosaveData && (autosaveData.jig_qr_id || autosaveData.faulty_slots > 0 || autosaveData.delink_tray_data?.length > 0)) {
          console.log('ðŸ”„ Populating modal with comprehensive autosave data');
          
          // *** ENHANCED: Populate all saved form fields ***
          if (autosaveData.jig_qr_id) {
              document.getElementById('modalJigQrId').value = autosaveData.jig_qr_id;
              
              // *** FIX: Re-validate the Jig ID when modal reopens ***
              setTimeout(() => {
                  const jigId = autosaveData.jig_qr_id.trim().toUpperCase();
                  if (jigId) {
                      console.log('ðŸ” Re-validating restored Jig ID:', jigId);
                      validateJigId(jigId, lotId)
                          .then(result => {
                              if (result.valid) {
                                  showJigValidationStatus(true, result.message);
                              } else {
                                  showJigValidationStatus(false, result.error);
                              }
                          });
                  }
              }, 300); // Small delay to ensure DOM is ready
          }
          if (autosaveData.faulty_slots !== undefined) {
              document.getElementById('modalFaultySlots').value = autosaveData.faulty_slots;
          }
          if (autosaveData.empty_slots !== undefined) {
              document.getElementById('modalEmptySlots').value = autosaveData.empty_slots;
              updateAddJigButtonState(autosaveData.empty_slots);  // NEW: Update Add Jig button state
          }
          if (autosaveData.total_cases_loaded !== undefined) {
              document.getElementById('modalLotQty').value = autosaveData.total_cases_loaded;
          }
          
          // Advanced fields (if they become editable in future)
          if (autosaveData.bath_type) {
              document.getElementById('modalBathType').value = autosaveData.bath_type;
          }
          if (autosaveData.jig_capacity !== undefined) {
              document.getElementById('modalJigCapacity').value = autosaveData.jig_capacity;
          }
          
          // *** NEW: Restore tray data ***
          if (autosaveData.delink_tray_data && autosaveData.delink_tray_data.length > 0) {
              console.log('ðŸ”„ Restoring', autosaveData.delink_tray_data.length, 'delink trays');
              restoreDelinkTrayData(autosaveData.delink_tray_data);
          }
          
          if (autosaveData.half_filled_tray_data && autosaveData.half_filled_tray_data.length > 0) {
              console.log('ðŸ”„ Restoring', autosaveData.half_filled_tray_data.length, 'half-filled trays');
              restoreHalfFilledTrayData(autosaveData.half_filled_tray_data);
          }
          
          // Restore cycle count display if available
          if (autosaveData.no_of_cycle_count && autosaveData.no_of_cycle_count !== '-/-') {
              const cycleDisplay = document.getElementById('cycleCount');
              if (cycleDisplay) {
                  cycleDisplay.textContent = autosaveData.no_of_cycle_count;
              }
          }
          
          // Show enhanced toast notification
          const toastMsg = document.createElement('div');
          toastMsg.style.cssText = `
              position: fixed; top: 20px; right: 20px; 
              background: linear-gradient(45deg, #28a745, #20c997); 
              color: white; padding: 12px 18px; border-radius: 8px; 
              z-index: 10000; font-size: 14px; font-weight: 500;
              box-shadow: 0 4px 24px rgba(0,0,0,0.18);
              border: 1px solid rgba(255,255,255,0.2);
          `;
          
          const fieldsRestored = [
              autosaveData.jig_qr_id ? 'JIG QR ID' : null,
              autosaveData.faulty_slots > 0 ? 'Broken/Buildup Hooks' : null,
              autosaveData.empty_slots > 0 ? 'Empty Hooks' : null,
              autosaveData.total_cases_loaded > 0 ? 'Case Qty' : null,
              autosaveData.delink_tray_data?.length > 0 ? `${autosaveData.delink_tray_data.length} Trays` : null,
              autosaveData.half_filled_tray_data?.length > 0 ? `${autosaveData.half_filled_tray_data.length} Half-filled` : null
          ].filter(Boolean);
          
          toastMsg.innerHTML = `
              <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="font-size: 16px;">ðŸ’¾</span>
                  <div>
                      <div>Auto-save data restored!</div>
                      <div style="font-size: 12px; opacity: 0.9;">${fieldsRestored.join(', ')}</div>
                  </div>
              </div>
          `;
          
          document.body.appendChild(toastMsg);
          
          // Remove toast after 4 seconds
          setTimeout(() => {
              if (toastMsg && toastMsg.parentNode) {
                  toastMsg.remove();
              }
          }, 4000);
          
          // Trigger validation for the restored JIG QR ID (mark as autosave)
          if (autosaveData.jig_qr_id) {
              validateJigQrId(autosaveData.jig_qr_id, true);  // true = isAutosave
          }
      } else {
          document.getElementById('modalFaultySlots').value = 0; // <-- Set default value
          document.getElementById('modalJigQrId').value = ''; // Clear JIG QR ID field
          
          // *** FIX: Clear any previous validation status when opening fresh modal ***
          hideJigValidationStatus();
      }

      const jigCapacity = parseInt(data.jig_capacity) || 0;
      const availableQty = parseInt(data.display_qty) || 0;
      const finalLotQty = Math.min(jigCapacity, availableQty);
      document.getElementById('modalLotQty').value = finalLotQty;
      document.getElementById('modalEmptySlots').value = jigCapacity - finalLotQty;
      updateAddJigButtonState(jigCapacity - finalLotQty);  // NEW: Update Add Jig button state

      let finalDisplayQty, finalEmptySlots, finalFaultySlots;
      let isDraftMode = false;

      // === ENHANCED: HANDLE DRAFT DATA INCLUDING DELINK TRAYS ===
if (data.draft_data && data.draft_data.has_draft) {
  console.log("Loading draft data:", data.draft_data);
  isDraftMode = true;
  
  // Fill form fields with draft data
  document.getElementById('modalJigQrId').value = data.draft_data.jig_qr_id || '';
  document.getElementById('modalFaultySlots').value = data.draft_data.faulty_slots || 0;
  document.getElementById('modalEmptySlots').value = data.draft_data.empty_slots || 0;
  updateAddJigButtonState(data.draft_data.empty_slots || 0);  // NEW: Update Add Jig button state
  document.getElementById('modalLotQty').value = data.draft_data.total_cases_loaded || 0;
  
  // *** FIX: Re-validate the Jig ID when draft data is loaded ***
  if (data.draft_data.jig_qr_id) {
      setTimeout(() => {
          const jigId = data.draft_data.jig_qr_id.trim().toUpperCase();
          if (jigId) {
              console.log('ðŸ” Re-validating draft Jig ID:', jigId);
              validateJigId(jigId, lotId)
                  .then(result => {
                      if (result.valid) {
                          showJigValidationStatus(true, result.message);
                      } else {
                          showJigValidationStatus(false, result.error);
                      }
                  });
          }
      }, 300); // Small delay to ensure DOM is ready
  }
  
  // Store draft ID for updates
  window.currentDraftId = data.draft_data.draft_id;
  
  // *** CRITICAL FIX: Store draft tray data immediately when draft loads ***
  if (data.draft_data.delink_tray_data && data.draft_data.delink_tray_data.length > 0) {
    window.originalDraftTrayData = data.draft_data.delink_tray_data.map(tray => ({
      tray_id: tray.tray_id || '',
      lot_id: tray.lot_id || '',
      expected_usage: tray.expected_usage || 0,
      from_draft: true
    }));
    console.log('ðŸ’¾ STORED original draft tray data:', window.originalDraftTrayData);
    console.log('ðŸ’¾ Draft tray IDs:', window.originalDraftTrayData.map(t => t.tray_id));
  }
        // === NEW: UPDATE HEADER WITH ALL MODELS FROM DRAFT ===
        if (data.draft_data.no_of_model_cases && data.draft_data.no_of_model_cases.length > 0) {
          const allDraftModels = data.draft_data.no_of_model_cases;
          document.getElementById('rightModalModelNo').textContent = allDraftModels.join(', ');
          console.log("Updated header with draft models:", allDraftModels.join(', '));
        }
        
        // === NEW: SET CURRENT LOT IDS FROM DRAFT ===
        if (data.draft_data.new_lot_ids && data.draft_data.new_lot_ids.length > 0) {
          window.currentLotIds = data.draft_data.new_lot_ids;
          console.log("Set currentLotIds from draft:", window.currentLotIds);
          
          // *** FIX: Auto-check checkboxes for additional models from draft ***
          data.draft_data.new_lot_ids.forEach(lotId => {
            if (lotId !== currentModalLotId) { // Don't check the primary modal lot
              const checkbox = document.querySelector(`.model-select-checkbox[data-stock-lot-id="${lotId}"]`);
              if (checkbox && !checkbox.checked) {
                console.log(`Auto-checking checkbox for draft lot: ${lotId}`);
                checkbox.checked = true;
                
                // Trigger change event to update UI
                const changeEvent = new Event('change', { bubbles: true });
                checkbox.dispatchEvent(changeEvent);
              }
            }
          });
        }
        
        // === NEW: FETCH AND DISPLAY CYCLE COUNT FOR DRAFT JIG QR ID ===
        if (data.draft_data.jig_qr_id) {
          setTimeout(() => {
            fetchAndDisplayCycleCount(data.draft_data.jig_qr_id);
          }, 500);
        }
        
        // === NEW: STORE DRAFT LOT ID QUANTITIES FOR MODAL DATA COLLECTION ===
        if (data.draft_data.lot_id_quantities) {
          window.currentLotIdQuantities = data.draft_data.lot_id_quantities;
          console.log("Stored draft lot_id_quantities:", window.currentLotIdQuantities);
        }
        
        // *** FIX: Trigger model slider repopulation after draft data is loaded ***
        setTimeout(() => {
          if (window.currentLotIds && window.currentLotIds.length > 1) {
            console.log("Triggering model slider repopulation for draft with", window.currentLotIds.length, "models");
            // Find first checked checkbox to trigger the multi-model update
            const firstChecked = document.querySelector('.model-select-checkbox:checked');
            if (firstChecked) {
              const changeEvent = new Event('change', { bubbles: true });
              firstChecked.dispatchEvent(changeEvent);
            }
          }
        }, 1000); // Delay to ensure all checkboxes are checked first
        
        // Use draft values for calculations
        finalDisplayQty = parseInt(data.draft_data.total_cases_loaded) || 0;
        finalEmptySlots = parseInt(data.draft_data.empty_slots) || 0;
        finalFaultySlots = parseInt(data.draft_data.faulty_slots) || 0;

        // *** FIXED: Handle Half Filled Tray Data from Draft ***
        console.log("ðŸ” Checking for draft half_filled_tray_data...");
        
        // Check if draft has saved half_filled_tray_data
        let draftHalfFilledData = data.draft_data.half_filled_tray_data || [];
        
        console.log("ðŸ“„ Draft half_filled_tray_data:", draftHalfFilledData);
        
        if (draftHalfFilledData && draftHalfFilledData.length > 0) {
          console.log("âœ… Found saved draft half_filled_tray_data - using it instead of calculated");
          populateHalfFilledTrayTableFromDraft(draftHalfFilledData);
        } else {
          console.log("ðŸ“Š No saved draft half_filled_tray_data - using calculated");
          // Fall back to calculated half filled trays if no draft data
          const shouldShowHalfFilled = data.half_filled_trays && data.show_half_filled_table && 
            finalDisplayQty < (data.original_quantity || 0) && !data.jig_fully_utilized;
            
          if (shouldShowHalfFilled) {
            const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
            populateHalfFilledTrayTable(topTrayOnly);
          } else {
            populateHalfFilledTrayTable([]);
          }
        }

      } else {
        console.log("No draft data, using fresh calculation");
        window.currentDraftId = null;

        // Use display_qty from the enhanced API response
        finalDisplayQty = (data.edited_quantity > 0 ? data.edited_quantity : (data.display_qty || 0));

        // âœ… SMART FIX - Cap by jig capacity
        const jigCapacity = parseInt(data.jig_capacity) || 0;
        if (jigCapacity > 0) {
            finalDisplayQty = Math.min(finalDisplayQty, jigCapacity);
        }

        document.getElementById('modalLotQty').value = finalDisplayQty;        
        // Calculate Empty Hooks automatically: Jig Capacity - Display LOT Qty
        finalEmptySlots = Math.max(0, jigCapacity - finalDisplayQty);
        document.getElementById('modalEmptySlots').value = finalEmptySlots;
        updateAddJigButtonState(finalEmptySlots);  // NEW: Disable Add Jig if empty slots > 0

        finalFaultySlots = 0;
        
        // FIXED: Enhanced Half Filled Tray Table logic for fresh data
        console.log("Half filled trays data:", data.half_filled_trays);
        console.log("Show half filled table:", data.show_half_filled_table);
        console.log("Final display qty:", finalDisplayQty);
        console.log("Original quantity:", data.original_quantity);
        console.log("Jig fully utilized:", data.jig_fully_utilized);
        
        const shouldShowHalfFilled = data.half_filled_trays && data.show_half_filled_table && 
          finalDisplayQty < (data.original_quantity || 0) && !data.jig_fully_utilized;
          
        console.log("Should show half filled table (fresh):", shouldShowHalfFilled);
        
        if (shouldShowHalfFilled) {
          // FIXED: Filter to only show top tray for verification
          const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
          populateHalfFilledTrayTable(topTrayOnly);
        } else {
          // Hide the half filled tray table if conditions not met
          populateHalfFilledTrayTable([]);
        }
      }

      // === POPULATE DELINK TRAY TABLE ===
      const trayTable = document.getElementById('delinkTrayTable');
      trayTable.innerHTML = `
        <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
        <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
      `;

      if (isDraftMode && data.draft_data.delink_tray_data && data.draft_data.delink_tray_data.length > 0) {
        // === USE SAVED DRAFT DELINK TRAY DATA WITH PROPER MODEL PLACEHOLDERS ===
        console.log("Populating delink trays from draft data:", data.draft_data.delink_tray_data);
        
        // Create a map of lot_id to model_no for proper placeholders
        const lotIdToModelMap = {};
        
        // Build the mapping from draft data
        if (data.draft_data.new_lot_ids && data.draft_data.no_of_model_cases) {
          for (let i = 0; i < data.draft_data.new_lot_ids.length; i++) {
            const lotId = data.draft_data.new_lot_ids[i];
            const modelNo = data.draft_data.no_of_model_cases[i] || data.draft_data.no_of_model_cases[0] || data.plating_stk_no;
            lotIdToModelMap[lotId] = modelNo;
            console.log(`Mapped lot ${lotId} to model ${modelNo}`);
          }
        }
        
        // Populate the tray table with correct model placeholders
        data.draft_data.delink_tray_data.forEach((trayEntry, index) => {
          const trayId = trayEntry.tray_id || '';
          const lotId = trayEntry.lot_id || '';
          const trayQuantity = trayEntry.tray_quantity || trayEntry.delink_qty || 0;
          
          // Get correct model number for this lot_id
          const modelForPlaceholder = lotIdToModelMap[lotId] || data.plating_stk_no || 'Unknown';
          
            // Define usageHint here (this was missing and causing the error)
          const usageHint = `Expected: ${trayEntry.expected_usage} pieces (Complete)`;
          
          console.log(`Loading draft tray ${index + 1}: ID="${trayId}", Lot="${lotId}", Model="${modelForPlaceholder}", Qty=${trayQuantity}`);
          
          // *** ENHANCED: Show draft tray IDs with preserved styling ***
          const inputStyle = trayId ? 'width:100%; border:1px solid #28a745; background:#f8fff8;' : 'width:100%; border:none; background:transparent;';
          const preservedTitle = trayId ? `Preserved: ${trayId} (${usageHint})` : usageHint;

          trayTable.innerHTML += `
            <div>${index + 1}</div>
            <div>
              <input type="text"
                value="${trayId}"
                placeholder="${modelForPlaceholder} - Scan Tray ID"
                data-lot-id="${lotId}"
                data-expected-usage="${trayEntry.expected_usage || trayQuantity}"
                data-from-draft="true"
                data-preserved="${trayId ? 'true' : 'false'}"
                title="${preservedTitle}"
                style="${inputStyle}" />
            </div>
          `;
        });
        
        console.log(`Loaded ${data.draft_data.delink_tray_data.length} saved delink tray entries from draft with correct model placeholders`);
        
      } else {
        // === USE CALCULATED TRAY DISTRIBUTION (FRESH OR DRAFT WITHOUT SAVED TRAY DATA) ===
        console.log("Using calculated tray distribution");
        
        // *** ENHANCED: Check for autosaved tray data to preserve ***
        const autosavedTrayData = autosaveData && autosaveData.delink_tray_data ? autosaveData.delink_tray_data : [];
        
        if (autosavedTrayData.length > 0) {
          console.log('ðŸ”„ Using autosaved tray data:', autosavedTrayData.length, 'entries');
          populateDelinkTrayTableFromCalculationWithPreservedData(data, trayTable, finalDisplayQty, autosavedTrayData);
        } else {
          populateDelinkTrayTableFromCalculation(data, trayTable, finalDisplayQty);
        }
      }

      // === ADD EVENT LISTENER FOR FAULTY SLOTS CALCULATION ===
      const faultySlotInput = document.getElementById('modalFaultySlots');
      const emptySlotInput = document.getElementById('modalEmptySlots');
      const lotQtyInput = document.getElementById('modalLotQty');
      
      // Store original values for calculation (use final values, not just API response)
      const originalEmptySlots = finalEmptySlots;
      const originalDisplayQty = finalDisplayQty;
      
      if (faultySlotInput) {
        // Remove any existing event listeners to prevent duplicates
        faultySlotInput.replaceWith(faultySlotInput.cloneNode(true));
        const newFaultySlotInput = document.getElementById('modalFaultySlots');
        
        // Set the value again after cloning
        if (isDraftMode) {
          newFaultySlotInput.value = finalFaultySlots;
        }
        
// UPDATED: Enhanced faulty slots calculation for single model
newFaultySlotInput.addEventListener('input', function() {
    const faultySlots = parseInt(newFaultySlotInput.value) || 0;
    const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
    
    // *** FAULTY SLOTS VALIDATION (your existing validation code) ***
    let maxAllowedFaultySlots = jigCapacity >= 144 ? 10 : 5;
    
    if (faultySlots > maxAllowedFaultySlots) {
        showModalMessage('error', 'Broken/Buildup Hooks Limit Exceeded', 
            `Maximum ${maxAllowedFaultySlots} faulty slots allowed for jig capacity ${jigCapacity}.`, 
            { duration: 5000 });
        newFaultySlotInput.value = maxAllowedFaultySlots;
        return;
    }
    
    if (faultySlots <= 0) {
        // *** FIXED: COMPLETE RESET TO ORIGINAL STATE ***
        console.log('ðŸ”„ Resetting faulty slots to 0 - restoring original distribution');
        
        // Reset form fields to original values
        emptySlotInput.value = originalEmptySlots;
        lotQtyInput.value = originalDisplayQty;
        
        // *** NEW: REBUILD DE-LINK TRAY TABLE WITH ORIGINAL CALCULATION ***
        const currentLotId = currentModalLotId;
        if (currentLotId) {
            console.log('ðŸ”„ Fetching original tray distribution for reset');
            
            fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentLotId)}`)
                .then(res => res.json())
                .then(data => {
                    console.log('âœ… Received original data for reset:', data);
                    
                    // *** REBUILD DE-LINK TRAY TABLE WITH ORIGINAL DATA ***
                    const trayTable = document.getElementById('delinkTrayTable');
                    trayTable.innerHTML = `
                        <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
                        <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
                    `;
                    
                    // Use the original calculation function
                    populateDelinkTrayTableFromCalculation(data, trayTable, originalDisplayQty);
                    
                    // *** REBUILD HALF FILLED TRAY TABLE WITH ORIGINAL DATA ***
                    if (data.half_filled_trays && data.show_half_filled_table) {
                        const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
                        populateHalfFilledTrayTable(topTrayOnly);
                        console.log('âœ… Restored original half filled trays');
                    } else {
                        populateHalfFilledTrayTable([]);
                        console.log('âœ… Hidden half filled trays (not needed for original qty)');
                    }
                    
                    console.log('âœ… Successfully restored original tray distribution');
                })
                .catch(error => {
                    console.error('âŒ Error fetching original data for reset:', error);
                    
                    // *** FALLBACK: RESET USING STORED ORIGINAL DATA ***
                    if (originalModalData && originalModalData.trayTableContent) {
                        console.log('ðŸ”„ Using fallback - restoring from stored original data');
                        document.getElementById('delinkTrayTable').innerHTML = originalModalData.trayTableContent;
                    }
                    
                    // Reset half filled trays
                    populateHalfFilledTrayTable([]);
                });
        } else {
            // *** FALLBACK: RESET USING STORED ORIGINAL DATA ***
            if (originalModalData && originalModalData.trayTableContent) {
                console.log('ðŸ”„ Using fallback - restoring from stored original data');
                document.getElementById('delinkTrayTable').innerHTML = originalModalData.trayTableContent;
            }
            
            // Reset half filled trays
            populateHalfFilledTrayTable([]);
        }
        
    } else {
        // *** EXISTING FAULTY SLOTS CALCULATION LOGIC ***
        const usableJigCapacity = Math.max(0, jigCapacity - faultySlots);
        
        console.log(`Faulty slots calculation:`);
        console.log(`  Jig capacity: ${jigCapacity}`);
        console.log(`  Faulty slots: ${faultySlots}`);
        console.log(`  Usable capacity: ${usableJigCapacity}`);
        console.log(`  Original LOT qty: ${originalDisplayQty}`);
        
        // *** KEY FIX: Only reduce LOT qty if it exceeds usable jig capacity ***
        if (originalDisplayQty > usableJigCapacity) {
          // LOT qty exceeds usable capacity, need to reduce it
          newLotQty = usableJigCapacity;
          newEmptySlots = 0; // No empty slots if at capacity
          
          console.log(`  LOT qty reduced to fit usable capacity: ${newLotQty}`);
          
          // Show half filled tray only if there's actual remaining quantity
          // For single model, check if original available quantity > reduced jig quantity
          const filteredCombinedHalfFilledTrays = filterToTopTrayOnly(combinedHalfFilledTrays);
          if (filteredCombinedHalfFilledTrays.length > 0) {
            console.log(`  Showing original half filled trays`);
            populateHalfFilledTrayTable(filteredCombinedHalfFilledTrays);
          } else {
            console.log(`  No half filled trays available`);
            populateHalfFilledTrayTable([]);
          }
        } else {
          // *** FIXED: LOT qty fits within usable capacity ***
          // Only reduce empty slots, keep LOT qty unchanged
          newEmptySlots = Math.max(0, originalEmptySlots - faultySlots);
          newLotQty = originalDisplayQty; // Keep original LOT qty
          
          console.log(`  LOT qty fits in usable capacity, keeping original: ${newLotQty}`);
          console.log(`  New empty slots: ${newEmptySlots}`);
          
          // *** KEY FIX: Check if original half filled trays should be shown ***
          // Only show half filled trays if they were originally calculated and jig doesn't use entire quantity
          const filteredCombinedHalfFilledTrays = filterToTopTrayOnly(combinedHalfFilledTrays);
          
          // *** ADDITIONAL FIX: Check if backend said no half filled tray needed ***
          // If backend indicated jig_fully_utilized or show_half_filled_table is false, don't show half filled tray
          let shouldShowHalfFilled = filteredCombinedHalfFilledTrays.length > 0;
          
          // Check if any data object indicates jig uses entire quantity
          if (window.currentJigData) {
            const jigUsesEntireQuantity = window.currentJigData.jig_fully_utilized || 
                                            !window.currentJigData.show_half_filled_table ||
                                            (window.currentJigData.display_qty >= (window.currentJigData.original_quantity || 0));
            if (jigUsesEntireQuantity) {
              shouldShowHalfFilled = false;
              console.log(`  Backend indicates jig uses entire quantity - no half filled tray needed`);
            }
          }
          
          if (shouldShowHalfFilled) {
            console.log(`  Showing original half filled trays`);
            populateHalfFilledTrayTable(filteredCombinedHalfFilledTrays);
          } else {
            console.log(`  No half filled tray needed - jig uses entire quantity or backend said no`);
            populateHalfFilledTrayTable([]);
          }
        }
        
        // Update the fields
        emptySlotInput.value = newEmptySlots;
        updateAddJigButtonState(newEmptySlots);  // NEW: Update Add Jig button state
        lotQtyInput.value = newLotQty;

        // *** RECALCULATE WITH ADJUSTED QUANTITY ***
        if (newLotQty !== originalDisplayQty) {
          const currentLotId = currentModalLotId;
          if (currentLotId) {
            console.log(`ðŸ”„ Recalculating with adjusted qty: ${newLotQty}`);
            
            fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentLotId)}&adjusted_qty=${newLotQty}`)
              .then(res => res.json())
              .then(data => {
                console.log('âœ… Received recalculated data:', data);
                
                // Update tray tables with new distribution
                const trayTable = document.getElementById('delinkTrayTable');
                trayTable.innerHTML = `
                  <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
                  <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
                `;
                populateDelinkTrayTableFromCalculation(data, trayTable, newLotQty);
                
                // Update half filled trays
                if (data.half_filled_trays && data.show_half_filled_table) {
                  const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
                  populateHalfFilledTrayTable(topTrayOnly);
                } else {
                  populateHalfFilledTrayTable([]);
                }
              })
              .catch(error => console.error('Error recalculating with adjusted qty:', error));
          }
        }
        
        // Show warning if faulty slots exceed total capacity
        if (faultySlots > jigCapacity) {
          showModalMessage('warning', 'Broken/Buildup Hooks Exceed Capacity', 
            `Faulty slots (${faultySlots}) exceed jig capacity (${jigCapacity}).`, 
            { duration: 500 });
          newFaultySlotInput.value = jigCapacity;
          return; // Exit early
        }
      }
    
    // Update Add Model button state
    const currentEmptySlots = parseInt(emptySlotInput.value) || 0;
    updateAddModelButtonState(currentEmptySlots);
});
        }

      // Update Add Model button state
      updateAddModelButtonState(finalEmptySlots);

      // Populate model slider
      const slider = document.getElementById('modelSliderDynamic');
      slider.innerHTML = '';
      
      let lotIdsToShow = [];
      if (isDraftMode && data.draft_data && data.draft_data.new_lot_ids && data.draft_data.new_lot_ids.length > 0) {
        lotIdsToShow = data.draft_data.new_lot_ids;
      } else if (window.currentLotIds && window.currentLotIds.length > 0) {
        lotIdsToShow = window.currentLotIds;
      } else if (currentModalLotId) {
        lotIdsToShow = [currentModalLotId];
      }
      
      // For each lot_id, fetch model info and add to slider
      await Promise.all(lotIdsToShow.map(async (lotId, idx) => {
        try {
          const resp = await fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`);
          const lotData = await resp.json();
          const modelData = {
            modelNo: lotData.plating_stk_no || '-',
            image: (lotData.model_images && lotData.model_images.length > 0) ? lotData.model_images[0] : '/static/assets/images/imagePlaceholder.png',
            isOriginal: idx === 0 // Mark first as original
          };
          const item = createModelItem(modelData);
          slider.appendChild(item);
        } catch (err) {
          // fallback if error
          const item = createModelItem({ modelNo: 'Unknown', image: '/static/assets/images/imagePlaceholder.png', isOriginal: idx === 0 });
          slider.appendChild(item);
        }
      }));
      
      // Update slider position
      setTimeout(updateSliderPosition, 100);

      // Store original data after modal is populated
      setTimeout(() => {
        storeOriginalModalData();
      }, 200);
    } catch (error) {
      console.error('Error fetching jig data:', error);
      showModalMessage('error', 'Data Loading Error', 'Failed to load jig data. Please try again.', { duration: 5000 });
    }

    // *** NEW: Recalculate emptySlots based on current values after loading ***
    const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
    const totalCasesLoaded = parseInt(document.getElementById('modalLotQty').value) || 0;
    const faultySlots = parseInt(document.getElementById('modalFaultySlots').value) || 0;
    const emptySlots = Math.max(0, jigCapacity - totalCasesLoaded - faultySlots);
    
    document.getElementById('modalEmptySlots').value = emptySlots;
    
    // Update button states based on recalculated emptySlots
    updateAddModelButtonState(emptySlots);
    updateAddJigButtonState(emptySlots);
    
    console.log(`ðŸ”„ Recalculated after loading: Jig Capacity=${jigCapacity}, Total Cases=${totalCasesLoaded}, Faulty Slots=${faultySlots}, Empty Slots=${emptySlots}`);
    
    // Trigger autosave to persist the recalculated empty_slots
    await window.triggerAutoSave(true);

    // === FOCUS LOGIC: Set focus based on data loading completion ===
    setTimeout(function focusNextEmptyInput() {
      // ...existing focus logic...
    }, 200);
  });
});

// === HELPER FUNCTION: FILTER TO SHOW ONLY TOP TRAY FOR VERIFICATION ===
function filterToTopTrayOnly(halfFilledTrays) {
  if (!halfFilledTrays || halfFilledTrays.length === 0) {
    return [];
  }
  
  console.log('Filtering half filled trays to show only top tray for verification');
  
  // Only show the top tray (the one that's actually partial/needs verification)
  // or if all trays are complete, show only the last one
  const topTray = halfFilledTrays.find(tray => tray.is_top_tray) || halfFilledTrays[halfFilledTrays.length - 1];
  
  if (topTray) {
    console.log(`Showing only top tray for verification: ${topTray.tray_id} with qty ${topTray.tray_quantity}`);
    return [topTray];
  }
  
  return [];
}

// === ENHANCED: HELPER FUNCTION TO CALCULATE AND POPULATE HALF FILLED TRAYS ===
function calculateAndPopulateHalfFilledTrays(data, adjustedDisplayQty) {
  const originalQty = data.original_quantity || data.brass_audit_accepted_qty || 0;
  let qtyToDistribute = adjustedDisplayQty;
  const allTrays = data.original_trays || data.trays || [];
  let usedTrays = [];
  let topTray = null;

  for (let i = 0; i < allTrays.length; i++) {
    const tray = allTrays[i];
    const trayQty = parseInt(tray.tray_quantity) || 0;
    if (qtyToDistribute >= trayQty) {
      qtyToDistribute -= trayQty;
      usedTrays.push(tray.tray_id);
    }else if (qtyToDistribute > 0) {
      // This is the top tray, partially used
      topTray = {
        tray_id: tray.tray_id,
        tray_quantity: qtyToDistribute, // <-- FIX: show used pieces, not remaining
        original_tray_quantity: trayQty,
        is_top_tray: true,
        lot_id: tray.lot_id || data.stock_lot_id || currentModalLotId
      };
      qtyToDistribute = 0;
      break;
    }
  }

  if (topTray && topTray.tray_quantity > 0) {
    populateHalfFilledTrayTable([topTray]);
  } else {
    populateHalfFilledTrayTable([]);
  }
}

// Update the populateHalfFilledTrayTable function to show the correct remaining quantity:

function populateHalfFilledTrayTable(halfFilledTrays) {
  const table = document.getElementById('halfFilledTrayTable');
  const halfFilledSection = document.getElementById('halfFilledTraySection');

  console.log('Populating half filled tray table with physical constraints:', halfFilledTrays);

  // Hide table if no valid trays
  const shouldHideTable = (
    !halfFilledTrays ||
    halfFilledTrays.length === 0 ||
    (Array.isArray(halfFilledTrays) && halfFilledTrays.every(tray => !tray || tray.tray_quantity <= 0))
  );

  if (shouldHideTable) {
    console.log('Hiding half filled tray table - no remaining quantity');
    if (halfFilledSection) halfFilledSection.style.display = 'none';
    if (table) table.innerHTML = '';
    return;
  }

  console.log('Showing half filled tray table with remaining quantity');
  if (halfFilledSection) halfFilledSection.style.display = 'block';

  // Table headers
  table.innerHTML = `
    <div style="background: #dcdcdc; font-weight: bold;">Tray ID</div>
    <div style="background: #dcdcdc; font-weight: bold;">Tray Quantity</div>
  `;

  halfFilledTrays.forEach((tray, idx) => {
    if (!tray || !tray.tray_id || tray.tray_quantity <= 0) return;

    const verificationLabel = '<span style="color:#b26a00;font-size:11px;font-weight:bold;margin-left:6px;">Verification Required</span>';

    // Enhanced info for remaining quantity
    const constraintInfo = `<div style="font-size:10px;color:#007bff;margin-top:1px;font-style:italic;">Remaining after optimal delink distribution</div>`;

    table.innerHTML += `
      <div>
        <input type="text"
          value=""
          placeholder="Scan remaining tray ID"
          data-expected-tray-id="${tray.tray_id}"
          data-qty="${tray.tray_quantity}"
          data-original-qty="${tray.original_tray_quantity || tray.tray_quantity}"
          data-top-tray="true"
          data-lot-id="${tray.lot_id || ''}"
          data-verification="true"
          style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px;"
        />
        ${constraintInfo}
      </div>
      <div>
        <input type="number"
          value="${tray.tray_quantity}"
          readonly
          style="background: #f9f9f9; border: 1px solid #ddd; width: 80px; text-align: center; padding: 4px; border-radius: 4px;"
        />
        ${verificationLabel}

      </div>
    `;
  });

  console.log(`Populated ${halfFilledTrays.length} half filled tray entries with physical constraints`);
}


// *** NEW: Function to restore delink tray data from autosave ***
function restoreDelinkTrayData(delinkTrayData) {
  console.log('ðŸ”„ Restoring delink tray data:', delinkTrayData.length, 'entries');
  
  const trayTable = document.getElementById('delinkTrayTable');
  if (!trayTable) {
    console.error('âŒ Tray table not found');
    return;
  }
  
  // Clear existing content except headers
  trayTable.innerHTML = `
    <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
    <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
  `;
  
  delinkTrayData.forEach((tray, index) => {
    const trayId = tray.tray_id || '';
    const lotId = tray.lot_id || '';
    const expectedUsage = tray.expected_usage || 0;
    const modelForPlaceholder = getModelForLot(lotId) || 'Model';
    
    // Show preserved tray ID with green styling if it has a value
    const inputStyle = trayId ? 'width:100%; border:1px solid #28a745; background:#f8fff8;' : 'width:100%; border:none; background:transparent;';
    const preservedTitle = trayId ? `Restored from autosave: ${trayId}` : `${modelForPlaceholder} - Scan Tray ID`;
    
    console.log(`ðŸ”„ Restoring row ${index + 1}: "${trayId}" for ${modelForPlaceholder}`);
    
    trayTable.innerHTML += `
      <div>${index + 1}</div>
      <div>
        <input type="text"
          value="${trayId}"
          placeholder="${modelForPlaceholder} - Scan Tray ID"
          data-lot-id="${lotId}"
          data-expected-usage="${expectedUsage}"
          data-from-autosave="true"
          data-preserved="${trayId ? 'true' : 'false'}"
          title="${preservedTitle}"
          style="${inputStyle}" />
      </div>
    `;
  });
  
  // Add restoration indicator
  const restoredCount = delinkTrayData.filter(t => t.tray_id && t.tray_id.trim()).length;
  if (restoredCount > 0) {
    trayTable.innerHTML += `
      <div style="grid-column: span 2; text-align:center; padding: 8px; background: #e8f5e8; color: #155724; font-size: 11px; border-radius: 4px; margin-top: 5px;">
        ðŸ’¾ Restored ${restoredCount} tray IDs from autosave
      </div>
    `;
  }
  
  console.log(`âœ… Successfully restored ${delinkTrayData.length} delink tray entries`);
}

// *** NEW: Modal opening function with comprehensive autosave restoration ***
function openModalForNewJig() {
  console.log('ðŸ”„ Opening modal for new jig...');
  
  // Clear the form first
  clearModalFields();
  
  // Try to get autosave data for current lot combination
  const currentLots = PickTable.getCurrentLotCombination();
  console.log('ðŸ“‹ Current lot combination:', currentLots);
  
  if (currentLots && currentLots.length > 0) {
    const lotKey = currentLots.sort().join(',');
    console.log('ðŸ” Checking autosave for lot combination:', lotKey);
    
    fetch(`/jig_loading/get_jig_autosave/?lot_combination=${encodeURIComponent(lotKey)}`)
      .then(response => response.json())
      .then(data => {
        console.log('ðŸ’¾ Autosave response:', data);
        
        if (data.success && data.data) {
          console.log('âœ… Found autosave data, restoring...');
          
          // Restore the form fields
          if (data.data.jig_id) {
            document.getElementById('jigIdInput').value = data.data.jig_id;
            console.log('ðŸ“ Restored jig_id:', data.data.jig_id);
          }
          
          // *** USE DEDICATED FUNCTION: Restore delink tray data ***
          if (data.data.delink_tray_data && Array.isArray(data.data.delink_tray_data)) {
            console.log('ðŸŽ¯ Restoring delink tray data using dedicated function...');
            restoreDelinkTrayData(data.data.delink_tray_data);
          } else {
            console.log('âš ï¸ No delink tray data to restore');
          }
          
          // Restore half filled tray data
          if (data.data.half_filled_tray_data) {
            console.log('ðŸ”„ Restoring half filled tray data...');
            populateHalfFilledTrayTableFromDraft(data.data.half_filled_tray_data);
          }
          
          console.log('âœ… Autosave restoration completed');
          
        } else {
          console.log('â„¹ï¸ No autosave data found for this lot combination');
        }
      })
      .catch(error => {
        console.error('âŒ Error fetching autosave data:', error);
      });
  } else {
    console.log('âš ï¸ No current lot combination available');
  }
  
  // Open the modal
  $('#newJigModal').modal('show');
  console.log('ðŸ”„ Modal opened');
}

// *** NEW: Function to populate half filled tray table from draft data ***
function populateHalfFilledTrayTableFromDraft(draftHalfFilledData) {
  const table = document.getElementById('halfFilledTrayTable');
  const halfFilledSection = document.getElementById('halfFilledTraySection');

  if (!draftHalfFilledData || draftHalfFilledData.length === 0) {
    if (halfFilledSection) halfFilledSection.style.display = 'none';
    if (table) table.innerHTML = '';
    return;
  }

  if (halfFilledSection) halfFilledSection.style.display = 'block';

  // Table headers
  table.innerHTML = `
    <div style="background: #dcdcdc; font-weight: bold;">Tray ID</div>
    <div style="background: #dcdcdc; font-weight: bold;">Tray Quantity</div>
  `;

  draftHalfFilledData.forEach((item, idx) => {
    // Use tray id and quantity styles like the main function
    const verificationLabel = '<span style="color:#b26a00;font-size:11px;font-weight:bold;margin-left:6px;">Verification Required</span>';
    const constraintInfo = `<div style="font-size:10px;color:#007bff;margin-top:1px;font-style:italic;">Loaded from draft</div>`;

    table.innerHTML += `
      <div>
        <input type="text"
          value="${item.tray_id !== undefined ? item.tray_id : ''}"
          placeholder="Scan remaining tray ID"
          data-expected-tray-id="${item.tray_id || ''}"
          data-qty="${item.tray_quantity || ''}"
          data-original-qty="${item.original_tray_quantity || item.tray_quantity || ''}"
          data-top-tray="true"
          data-lot-id="${item.lot_id || ''}"
          data-row-index="${item.row_index || idx + 1}"
          style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px;"
        />
        ${constraintInfo}
      </div>
      <div>
        <input type="number"
          value="${item.tray_quantity || ''}"
          readonly
          style="background: #f9f9f9; border: 1px solid #ddd; width: 80px; text-align: center; padding: 4px; border-radius: 4px;"
        />
        ${verificationLabel}

      </div>
    `;
  });

  console.log(`Populated ${draftHalfFilledData.length} half filled tray entries from draft`);
}
// FIXED: Enhanced logic for checking when to show half filled table
function shouldShowHalfFilledTable(data, displayQty, originalQty, jigCapacity) {
  // Don't show if no half filled trays data
  if (!data.half_filled_trays || data.half_filled_trays.length === 0) {
    console.log("No half filled trays data - hiding table");
    return false;
  }
  
  // Don't show if jig is fully utilized (display qty equals original qty)
  if (displayQty >= originalQty) {
    console.log(`Jig fully utilized (${displayQty} >= ${originalQty}) - hiding half filled table`);
    return false;
  }
  
  // Don't show if display qty equals jig capacity and original qty
  if (displayQty === jigCapacity && displayQty === originalQty) {
    console.log(`Jig fully utilized with all available quantity (${displayQty} = ${jigCapacity} = ${originalQty}) - hiding half filled table`);
    return false;
  }
  
  // Don't show if backend explicitly says not to show
  if (data.show_half_filled_table === false) {
    console.log("Backend says don't show half filled table");
    return false;
  }
  
  // Don't show if jig_fully_utilized flag is set
  if (data.jig_fully_utilized === true) {
    console.log("Jig fully utilized flag is true - hiding half filled table");
    return false;
  }
  
  console.log("Half filled table should be shown");
  return true;
}
// *** ENHANCED: Auto-fill function for half filled trays ***
function autoFillTrayQty(input) {
  const enteredTrayId = input.value.trim();
  const usedQty = parseInt(input.getAttribute('data-qty')) || 0;
  const originalQty = parseInt(input.getAttribute('data-original-qty')) || usedQty;
  const isTop = input.getAttribute('data-top-tray') === 'true';
  const lotId = input.getAttribute('data-lot-id') || '';
  const isTheoretical = input.getAttribute('data-theoretical') === 'true';
  
  // Remove any existing validation messages
  const existingMsg = input.parentNode.querySelector('.half-tray-validation');
  if (existingMsg) {
    existingMsg.remove();
  }
  
  // Reset styling
  input.style.background = '';
  input.style.borderColor = '';
  
  if (!enteredTrayId) {
    // Empty input - reset to default used quantity
    const qtyInput = input.parentNode.nextElementSibling?.querySelector('input[type="number"]');
    if (qtyInput) {
      qtyInput.value = usedQty;
    }
    return;
  }
  
  // *** NEW: Set the lot_id data attribute for backend processing ***
  input.setAttribute('data-lot-id', lotId);
  
  // Accept any tray ID since this is optimal/theoretical distribution
  const qtyInput = input.parentNode.nextElementSibling?.querySelector('input[type="number"]');
  if (qtyInput) {
    qtyInput.value = usedQty;  // Show the optimal used quantity
  }
  
  // Visual feedback for theoretical distribution
  input.style.background = isTheoretical ? '#e8f5e8' : '#fff3cd';
  input.style.borderColor = isTheoretical ? '#28a745' : '#ffc107';
  
  // Mark as top tray visually if applicable
  if (isTop) {
    input.style.fontWeight = 'bold';
  }
  
  // Add success message with optimal distribution info
  const successMsg = document.createElement('div');
  successMsg.className = 'half-tray-validation';
  successMsg.style.cssText = 'color: green; font-size: 11px; margin-top: 2px;';
  
  if (isTop) {
    successMsg.textContent = `âœ“ Optimal Top Tray: ${usedQty}/${originalQty} pieces (users can shuffle manually)`;
  } else {
    successMsg.textContent = `âœ“ Optimal Complete Tray: ${usedQty} pieces (users can shuffle manually)`;
  }
  
  input.parentNode.appendChild(successMsg);
  
  console.log(`Auto-filled optimal tray ${enteredTrayId} - Used: ${usedQty}/${originalQty}${isTop ? ' (Top)' : ' (Complete)'} for lot: ${lotId}`);
}

// *** ENHANCED: Also fix populateDelinkTrayTableFromCalculation to use API data first ***
function populateDelinkTrayTableFromCalculation(data, trayTable, displayQty) {
  // Clear previous rows except headers
  trayTable.innerHTML = `
    <div style="background: #dcdcdc; font-weight: bold;">S.No</div>
    <div style="background: #dcdcdc; font-weight: bold;">Tray ID</div>
  `;

  if (data.trays && data.trays.length > 0) {
    // Show optimal tray distribution based on physical constraints
    data.trays.forEach((tray, idx) => {
      // Use plating_stk_no from API data first, then fallback
      const modelForPlaceholder =
        data.plating_stk_no ||
        tray.plating_stk_no ||
        getModelForLot(tray.lot_id || data.stock_lot_id || currentModalLotId) ||
        'Model';

      // Create hint for expected usage
      const usageHint = `Expected: ${tray.used_quantity} pieces (Complete)`;

      trayTable.innerHTML += `
        <div>${idx + 1}</div>
        <div>
          <input type="text"
            value=""
            placeholder="${modelForPlaceholder} - Scan Tray ID"
            data-lot-id="${tray.lot_id || data.stock_lot_id || currentModalLotId}"
            data-expected-usage="${tray.used_quantity}"
            data-is-top-tray="false"
            data-original-tray-qty="${tray.original_tray_quantity || tray.tray_quantity}"
            data-theoretical="true"
            title="${usageHint}"
            style="width:100%; border:none; background:transparent;"
          />
        </div>
      `;
    });

    // Add info about remaining quantity if any
    const totalUsedInDelink = data.trays.reduce(
      (sum, tray) => sum + (tray.used_quantity || 0),
      0
    );
    const remainingQty = displayQty - totalUsedInDelink;
    console.log(`Total used in delink trays: ${totalUsedInDelink}, Remaining qty: ${remainingQty}`);

    if (remainingQty > 0) {
      trayTable.innerHTML += `
        <div style="grid-column: span 2; text-align:center; padding: 10px; background: #e8f5e8; color: #155724; font-size: 11px; border-radius: 4px; margin-top: 5px;">
          â„¹ï¸ ${remainingQty} remaining cases yet to be loaded
        </div>
      `;
    }
  } else {
    trayTable.innerHTML += `
      <div style="grid-column: span 2; text-align:center; padding: 20px; color: #666;">
        No optimal distribution found for quantity ${displayQty}
      </div>
    `;
  }
}

// === COMPLETELY FIXED: CALCULATE HALF FILLED TRAYS FOR FAULTY SLOTS (OPTIMAL) ===
function calculateAndPopulateHalfFilledTraysOptimal(data, adjustedDisplayQty) {
  const originalQty = data.original_quantity || data.brass_audit_accepted_qty || 0;
  const trayCapacity = data.tray_capacity; // Get tray capacity
  
  // FIXED: Calculate remaining quantity after this jig (direct calculation)
  const remainingQtyAfterJig = originalQty - adjustedDisplayQty;
  
  console.log(`HALF FILLED OPTIMAL CALCULATION (COMPLETELY FIXED):`);
  console.log(`  Original qty: ${originalQty}`);
  console.log(`  Adjusted display qty: ${adjustedDisplayQty}`);
  console.log(`  DIRECT CALCULATION: Remaining = ${originalQty} - ${adjustedDisplayQty} = ${remainingQtyAfterJig}`);
  console.log(`  Tray capacity: ${trayCapacity}`);
  
  if (remainingQtyAfterJig <= 0) {
    console.log(`  No remaining quantity, hiding half filled table`);
    populateHalfFilledTrayTable([]);
    return;
  }
  
  // FIXED: Generate optimal distribution for remaining quantity
  const completeTrays = Math.floor(remainingQtyAfterJig / trayCapacity);
  const remainder = remainingQtyAfterJig % trayCapacity;
  
  console.log(`  Distribution: ${remainingQtyAfterJig} Ã· ${trayCapacity} = ${completeTrays} complete + ${remainder} remainder`);
  
  let halfFilledTrays = [];
  
  // FIXED: ONLY show the top tray (remainder) for verification, not complete trays
  if (remainder > 0) {
    halfFilledTrays.push({
      tray_id: `TOP-TRAY`,
      tray_quantity: remainder,  // FIXED: Only the remainder portion
      original_tray_quantity: trayCapacity,
      is_top_tray: true,  // This is the top tray
      lot_id: data.stock_lot_id || currentModalLotId,
      theoretical: true
    });
    
    console.log(`  âœ“ TOP TRAY: ${remainder} pieces (remainder only)`);
  } else if (completeTrays > 0) {
    // If only complete trays remain, show one for verification
    halfFilledTrays.push({
      tray_id: `COMPLETE-TRAY`,
      tray_quantity: trayCapacity,
      original_tray_quantity: trayCapacity,
      is_top_tray: false,
      lot_id: data.stock_lot_id || currentModalLotId,
      theoretical: true
    });
    
    console.log(`  âœ“ COMPLETE TRAY: ${trayCapacity} pieces`);
  }
  
  console.log(`  Result: ${halfFilledTrays.length} half filled trays`);
  populateHalfFilledTrayTable(halfFilledTrays);
}


// *** ENHANCED: Calculate Half Filled Trays for Multi-Model Selection ***
async function calculateMultiModelHalfFilledTrays(validResults, calculatedLotIdQuantities) {
  const combinedHalfFilledTrays = [];
  
  console.log('Calculating half filled trays for multi-model selection');
  console.log('Calculated lot quantities:', calculatedLotIdQuantities);
  
  // For each lot, calculate if it has remaining quantity after this jig
  for (const result of validResults) {
    const lotId = result.original_lot_id;
    const originalQty = result.original_quantity || result.brass_audit_accepted_qty || 0;
    const usedQtyForJig = calculatedLotIdQuantities[lotId] || 0;
    const remainingQtyAfterJig = originalQty - usedQtyForJig;
    
    console.log(`Lot ${lotId}:`);
    console.log(`  Original qty: ${originalQty}`);
    console.log(`  Used for this jig: ${usedQtyForJig}`);
    console.log(`  Remaining after jig: ${remainingQtyAfterJig}`);
    
    if (remainingQtyAfterJig > 0) {
      // This lot has remaining quantity, calculate its half filled trays
      const trayCapacity = result.tray_capacity || 12;
      
      // Calculate optimal distribution for remaining quantity
      const completeTrays = Math.floor(remainingQtyAfterJig / trayCapacity);
      const remainder = remainingQtyAfterJig % trayCapacity;
      
      console.log(`  Optimal distribution: ${completeTrays} complete + ${remainder} remainder`);
      
      let lotTrayIndex = 1;
      
      // Add complete trays
      for (let i = 0; i < completeTrays; i++) {
        combinedHalfFilledTrays.push({
          tray_id: `${result.plating_stk_no}-TRAY-${lotTrayIndex}`,
          tray_quantity: trayCapacity,
          original_tray_quantity: trayCapacity,
          is_top_tray: false,
          lot_id: lotId,
          model_no: result.plating_stk_no,
          theoretical: true
        });
        
        console.log(`    Complete tray ${lotTrayIndex}: ${trayCapacity}/${trayCapacity} pieces`);
        lotTrayIndex++;
      }
      
      // Add partial tray if remainder exists
      if (remainder > 0) {
        combinedHalfFilledTrays.push({
          tray_id: `${result.plating_stk_no}-TRAY-${lotTrayIndex}`,
          tray_quantity: remainder,
          original_tray_quantity: trayCapacity,
          is_top_tray: true,
          lot_id: lotId,
          model_no: result.plating_stk_no,
          theoretical: true
        });
        
        console.log(`    Top tray ${lotTrayIndex}: ${remainder}/${trayCapacity} pieces`);
      }
    } else {
      console.log(`  No remaining quantity for lot ${lotId}`);
    }
  }
  
  console.log(`Total combined half filled trays: ${combinedHalfFilledTrays.length}`);
  return combinedHalfFilledTrays;
}

// UPDATED: Event listener for flexible tray validation
document.addEventListener('input', function(e) {
  const trayInput = e.target.closest('#delinkTrayTable input[type="text"]');
  if (trayInput && trayInput.hasAttribute('data-available-trays')) {
    clearTimeout(trayInput.validationTimeout);
    trayInput.validationTimeout = setTimeout(() => {
      validateFlexibleTrayId(trayInput);
    }, 300);
  }
});

// Add event listener for real-time tray validation
document.addEventListener('input', function(e) {
  const trayInput = e.target.closest('#delinkTrayTable input[type="text"]');
  if (trayInput && trayInput.hasAttribute('data-expected-tray-id')) {
    validateExpectedTrayId(trayInput);
  }
});

// *** UPDATED: Enhanced modal data collection for multi-model ***
function collectModalData() {
  const jigQrId = document.getElementById('modalJigQrId').value.trim();
  const faultySlots = parseInt(document.getElementById('modalFaultySlots').value) || 0;
  const emptySlots = parseInt(document.getElementById('modalEmptySlots').value) || 0;
  const totalCasesLoaded = parseInt(document.getElementById('modalLotQty').value) || 0;

  const platingStockNumbers = []; // Changed from modelNumbers
    document.querySelectorAll('#modelSliderDynamic .model-loaded-item').forEach(item => {
        const modelText = item.textContent;
        const platingStockMatch = modelText.match(/Model No:\s*([^\s]+)/); // Updated regex
        if (platingStockMatch) {
            platingStockNumbers.push(platingStockMatch[1]);
        }
    });

  const lotIds = (window.currentLotIds && Array.isArray(window.currentLotIds)) ? window.currentLotIds.slice() : [];
  
  const lotIdQuantities = {};
  
  const hasMultipleModels = document.querySelectorAll('.model-select-checkbox:checked').length > 0;
const isDraftMode = window.currentDraftId && window.currentLotIdQuantities;

if ((hasMultipleModels && window.currentLotIdQuantities) || isDraftMode) {
  console.log('Using stored lot_id_quantities:', window.currentLotIdQuantities);
  Object.assign(lotIdQuantities, window.currentLotIdQuantities);
  
  // For draft mode, also set lot_ids from stored data
  if (isDraftMode && window.currentLotIds) {
    lotIds.length = 0; // Clear existing
    lotIds.push(...window.currentLotIds);
  }
} else {
    console.log('Single model - using table row quantities');
    
    if (currentModalLotId) {
      const row = document.querySelector(`.open-jig-modal-btn[data-stock-lot-id="${currentModalLotId}"]`)?.closest('tr');
      let originalQty = 0;
      if (row) {
        const qtyInput = row.querySelector('.edit-qty-input');
        originalQty = qtyInput ? parseInt(qtyInput.value) || 0 : 0;
      }
      if (originalQty > 0) {
        if (!lotIds.includes(currentModalLotId)) {
          lotIds.push(currentModalLotId);
        }
        lotIdQuantities[currentModalLotId] = originalQty;
      }
    }

    document.querySelectorAll('.model-select-checkbox:checked').forEach(checkbox => {
      const stockLotId = checkbox.getAttribute('data-stock-lot-id');
      if (stockLotId && !lotIds.includes(stockLotId)) {
        const row = checkbox.closest('tr');
        const qtyInput = row.querySelector('.edit-qty-input');
        const qty = qtyInput ? parseInt(qtyInput.value) || 0 : 0;
        if (qty > 0) {
          lotIds.push(stockLotId);
          lotIdQuantities[stockLotId] = qty;
        }
      }
    });
  }

  // *** ENHANCED: Better delink tray data collection for multi-model ***
  const delinkTrayData = [];
  const trayTable = document.getElementById('delinkTrayTable');
  
  console.log('=== ENHANCED DELINK TRAY COLLECTION ===');
  
  if (trayTable) {
    const trayInputs = trayTable.querySelectorAll('input[type="text"]');
    console.log('Found tray inputs:', trayInputs.length);
    
    trayInputs.forEach((trayInput, index) => {
      const trayId = trayInput.value.trim();
      const lotId = trayInput.getAttribute('data-lot-id') || '';
      const expectedUsage = parseInt(trayInput.getAttribute('data-expected-usage')) || 0;
      const isBackendOptimal = trayInput.getAttribute('data-backend-optimal') === 'true';
      
      console.log(`Delink Tray ${index + 1}: ID="${trayId}", Lot="${lotId}", Expected=${expectedUsage}, BackendOptimal=${isBackendOptimal}`);
      
      // Include all tray entries for backend processing
      delinkTrayData.push({
        tray_id: trayId,
        lot_id: lotId,
        expected_usage: expectedUsage,
        is_backend_optimal: isBackendOptimal,
        row_index: index + 1
      });
    });
  }

  // *** ENHANCED: Better half-filled tray data collection for multi-model ***
  const halfFilledTrayData = [];
  const halfFilledTable = document.getElementById('halfFilledTrayTable');
  
  console.log('=== ENHANCED HALF-FILLED TRAY COLLECTION (WITH DRAFT SUPPORT) ===');
  
  if (halfFilledTable) {
    const trayIdInputs = halfFilledTable.querySelectorAll('input[type="text"]');
    const qtyInputs = halfFilledTable.querySelectorAll('input[type="number"]');
    
    console.log('Found half-filled inputs:', trayIdInputs.length, 'qty inputs:', qtyInputs.length);
    
    for (let i = 0; i < Math.min(trayIdInputs.length, qtyInputs.length); i++) {
      const trayInput = trayIdInputs[i];
      const qtyInput = qtyInputs[i];
      
      const trayId = trayInput.value.trim();
      const qty = parseInt(qtyInput.value) || 0;
      const lotId = trayInput.getAttribute('data-lot-id') || '';
      const modelNo = trayInput.getAttribute('data-model-no') || '';
      const isTopTray = trayInput.getAttribute('data-top-tray') === 'true';
      const isMultiModel = trayInput.getAttribute('data-multi-model') === 'true';
      const fromDraft = trayInput.getAttribute('data-from-draft') === 'true';
      const originalQty = parseInt(trayInput.getAttribute('data-original-qty')) || qty;
      
      console.log(`Half-Filled ${i + 1}: ID="${trayId}", Qty=${qty}, Lot="${lotId}", Model="${modelNo}", MultiModel=${isMultiModel}, FromDraft=${fromDraft}`);
      
      if (trayId || qty > 0) {
        halfFilledTrayData.push({
          tray_id: trayId,
          tray_quantity: qty,
          original_tray_quantity: originalQty,
          lot_id: lotId,
          model_no: modelNo,
          is_top_tray: isTopTray,
          is_multi_model: isMultiModel,
          from_draft: fromDraft,
          row_index: i + 1
        });
      }
    }
  }
  console.log('=== ENHANCED COLLECTION RESULTS ===');
  console.log('delinkTrayData:', delinkTrayData);
  console.log('halfFilledTrayData:', halfFilledTrayData);

  return {
    jig_qr_id: jigQrId,
    faulty_slots: faultySlots,
    empty_slots: emptySlots,
    total_cases_loaded: totalCasesLoaded,
    plating_stock_numbers: platingStockNumbers, // Changed from model_numbers
    lot_ids: lotIds,
    lot_id_quantities: lotIdQuantities,
    delink_tray_data: delinkTrayData, 
    half_filled_tray_data: halfFilledTrayData,
    primary_lot_id: lotIds.length > 0 ? lotIds[0] : '',
    draft_id: window.currentDraftId || null,
    is_multi_model: hasMultipleModels,
    multi_model_distribution: window.currentMultiModelDistribution || null
  };
}

// *** NEW: Function to validate if half filled section should be shown ***
function shouldShowHalfFilledSectionForDraft(draftData, calculatedData) {
  // If draft has saved half_filled_tray_data, always show it
  if (draftData && draftData.half_filled_tray_data && draftData.half_filled_tray_data.length > 0) {
    console.log("âœ… Showing half filled section: Draft has saved data");
    return true;
  }
  
  // Otherwise use the normal calculation logic
  if (calculatedData && calculatedData.half_filled_trays && calculatedData.show_half_filled_table) {
    const displayQty = parseInt(draftData?.total_cases_loaded || calculatedData.display_qty || 0);
    const originalQty = calculatedData.original_quantity || 0;
    const jigFullyUtilized = calculatedData.jig_fully_utilized || false;
    
    const shouldShow = displayQty < originalQty && !jigFullyUtilized;
    console.log(`ðŸ“Š Showing half filled section: ${shouldShow} (displayQty: ${displayQty}, originalQty: ${originalQty}, jigFullyUtilized: ${jigFullyUtilized})`);
    return shouldShow;
  }
  
  console.log("âŒ Not showing half filled section: No data");
  return false;
}

// Add this at the top of your script to track checkbox selection order
let checkboxSelectionOrder = [];

document.querySelectorAll('.model-select-checkbox').forEach(function(checkbox) {
  checkbox.addEventListener('change', async function() {
    // Check if checkbox is disabled due to full jig AND user is trying to check it (not uncheck)
    if (checkbox.disabled && checkbox.checked) {
      showModalMessage('warning', 'Cannot Select', 'Jig is full. Cannot add more models.', { duration: 3000 });
      checkbox.checked = false;
      return;
    }
    
    // Update checkbox selection order tracking
    const stockLotId = checkbox.getAttribute('data-stock-lot-id') || checkbox.closest('tr').querySelector('.open-jig-modal-btn')?.getAttribute('data-stock-lot-id');
    
    if (checkbox.checked && stockLotId) {
      // Add to selection order if not already present
      if (!checkboxSelectionOrder.includes(stockLotId)) {
        checkboxSelectionOrder.push(stockLotId);
        console.log('Added to selection order:', stockLotId, 'Order:', checkboxSelectionOrder);
      }
    } else if (!checkbox.checked && stockLotId) {
      // Remove from selection order if unchecked
      const index = checkboxSelectionOrder.indexOf(stockLotId);
      if (index > -1) {
        checkboxSelectionOrder.splice(index, 1);
        console.log('Removed from selection order:', stockLotId, 'Order:', checkboxSelectionOrder);
      }
    }
    const allLotIds = [window.initialLotId, ...checkboxSelectionOrder.filter(id => id !== window.initialLotId)];
    window.currentLotIds = allLotIds;

    
    const checked = Array.from(document.querySelectorAll('.model-select-checkbox:checked'));
    
    // Update status indicator
    updateSelectedItemsStatus();
    
    if (checked.length === 0) {
      // Reset selection order when no checkboxes are selected
      checkboxSelectionOrder = [];
      console.log('Reset selection order');
      
      // If no checkboxes are selected, restore original data and rebuild slider
      if (originalModalData) {
        document.getElementById('rightModalModelNo').textContent = originalModalData.modelNo;
        document.getElementById('modalBathType').value = originalModalData.bathType;
        document.getElementById('modalJigCapacity').value = originalModalData.jigCapacity;
        document.getElementById('modalLotQty').value = originalModalData.lotQty;
        
        // Recalculate Empty Hooks for original data
        const jigCapacity = parseInt(originalModalData.jigCapacity) || 0;
        const lotQty = parseInt(originalModalData.lotQty) || 0;
        const emptySlots = Math.max(0, jigCapacity - lotQty);
        document.getElementById('modalEmptySlots').value = emptySlots;

        updateAddModelButtonState(emptySlots);
        
        document.getElementById('delinkTrayTable').innerHTML = originalModalData.trayTableContent;
        
        // Hide half filled tray table when returning to original
        populateHalfFilledTrayTable([]);
        
        // Rebuild slider with original model only
        const slider = document.getElementById('modelSliderDynamic');
        slider.innerHTML = '';
        
        if (currentModalLotId) {
          try {
            const response = await fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentModalLotId)}`);
            const data = await response.json();
            
            const modelData = {
              modelNo: data.plating_stk_no || originalModalData.modelNo,
              image: (data.model_images && data.model_images.length > 0) ? data.model_images[0] : '/static/assets/images/imagePlaceholder.png',
              isOriginal: true
            };
            const item = createModelItem(modelData);
            slider.appendChild(item);
            
            // Show half filled tray table for original data if applicable (only top tray)
            const shouldShowHalfFilled = data.half_filled_trays && data.show_half_filled_table && 
              data.display_qty < (data.original_quantity || 0) && !data.jig_fully_utilized;
            if (shouldShowHalfFilled) {
              const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
              populateHalfFilledTrayTable(topTrayOnly);
            }
          } catch (error) {
            console.error('Error rebuilding original slider:', error);
            const modelData = {
              modelNo: originalModalData.modelNo,
              image: '/static/assets/images/imagePlaceholder.png',
              isOriginal: true
            };
            const item = createModelItem(modelData);
            slider.appendChild(item);
          }
        }
        
        setTimeout(updateSliderPosition, 100);
      }
      return;
    }

    // SHOW the modal again when checkbox is selected
    const modal = document.getElementById('rightSideModal');
    if (modal) {
      modal.style.display = 'block';
      modal.classList.add('open');
      modal.classList.remove('minimized');
      
      // Reset any forced styling
      modal.style.width = '';
      modal.style.height = '';
      modal.style.top = '';
      modal.style.right = '';
    }

    // Fetch details for all selected lots IN SELECTION ORDER
    const stockLotIds = checkboxSelectionOrder.filter(lotId => {
      // Only include lot IDs that are still checked
      const checkbox = document.querySelector(`.model-select-checkbox[data-stock-lot-id="${lotId}"]`);
      return checkbox && checkbox.checked;
    });

    console.log('Processing selected lot IDs in order:', stockLotIds);

    // Fetch all data in parallel but maintain selection order
    const results = await Promise.all(stockLotIds.map(lotId =>
      fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(lotId)}`)
        .then(res => res.json())
        .then(data => ({ ...data, original_lot_id: lotId })) // Preserve original lot_id for ordering
        .catch(error => {
          console.error(`Error fetching data for lot ${lotId}:`, error);
          return null;
        })
    ));

    const validResults = results.filter(r => r && !r.error);
    console.log('Valid results in selection order:', validResults.map(r => r.original_lot_id));

    if (validResults.length === 0) {
      console.warn('No valid results from checkbox selections');
      return;
    }

    // Combine data - ALLOW DUPLICATE MODEL NUMBERS
    let combinedModelNos = [];
    let combinedLotQtys = [];
    let combinedBathTypes = [];
    let combinedJigCapacities = [];
    let combinedTraysData = []; // Store all tray data for later processing
    let combinedHalfFilledTrays = []; // Store all half filled tray data

    // Add original data if available
    if (originalModalData && originalModalData.modelNo !== '-') {
      combinedModelNos.push(originalModalData.modelNo);
      if (originalModalData.lotQty) combinedLotQtys.push(parseInt(originalModalData.lotQty));
      if (originalModalData.bathType) combinedBathTypes.push(originalModalData.bathType);
      if (originalModalData.jigCapacity) combinedJigCapacities.push(originalModalData.jigCapacity);
      
      // Get original tray data
      if (currentModalLotId) {
        try {
          const originalResponse = await fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentModalLotId)}`);
          const originalData = await originalResponse.json();
          if (originalData.trays) {
            combinedTraysData.push({
              lot_id: currentModalLotId,
              model_no: originalModalData.modelNo,
              trays: originalData.trays,
              isOriginal: true
            });
          }
          // Add original half filled trays
          if (originalData.half_filled_trays && originalData.show_half_filled_table) {
            combinedHalfFilledTrays.push(...originalData.half_filled_trays);
          }
        } catch (error) {
          console.error('Error fetching original tray data:', error);
        }
      }
    }

    // Add checkbox data IN SELECTION ORDER - ALLOW DUPLICATES
    validResults.forEach((r, index) => {
      // ALWAYS ADD THE MODEL NUMBER (even if it's duplicate)
      if (r.plating_stk_no) combinedModelNos.push(r.plating_stk_no);
      
      if (r.trays && Array.isArray(r.trays)) {
        const lotQty = r.trays.reduce((sum, t) => sum + (parseInt(t.tray_quantity) || 0), 0);
        if (lotQty > 0) combinedLotQtys.push(lotQty);
        
        // Store tray data with associated lot_id IN SELECTION ORDER
        combinedTraysData.push({
          lot_id: r.original_lot_id, // Use the preserved original lot_id
          model_no: r.plating_stk_no,
          trays: r.trays,
          isOriginal: false,
          selectionIndex: index // Track selection order
        });
      }
      
      // Add half filled trays from each selected lot
      if (r.half_filled_trays && r.show_half_filled_table) {
        combinedHalfFilledTrays.push(...r.half_filled_trays);
      }
      
      if (r.ep_bath_type) combinedBathTypes.push(r.ep_bath_type);
      if (r.jig_capacity) combinedJigCapacities.push(r.jig_capacity);
    });

    // Update modal fields with combined data (will be updated later with deduplicated models)
    // Temporary: document.getElementById('rightModalModelNo').textContent will be set after deduplication
    
    // *** UPDATED: PROPORTIONAL CAPPING LOGIC ***
    const originalJigCapacity = originalModalData ? (parseInt(originalModalData.jigCapacity) || 0) : 0;
    const uncappedTotalLotQty = combinedLotQtys.reduce((sum, qty) => sum + qty, 0);
    
    console.log(`Original Jig Capacity: ${originalJigCapacity}`);
    console.log(`Uncapped Total LOT Qty: ${uncappedTotalLotQty}`);
    
// *** FIXED: First-fill prioritization instead of proportional capping ***
function calculateProportionalLotQuantities(originalLotQuantities, targetTotal, originalTotal) {
  const prioritizedQuantities = {};
  
  console.log(`ðŸ”§ FIRST-FILL PRIORITIZATION LOGIC`);
  console.log(`  Target total: ${targetTotal}, Original total: ${originalTotal}`);
  
  // *** CRITICAL FIX: If totals match exactly, use original quantities ***
  if (originalTotal <= targetTotal) {
    console.log('âœ… No capping needed - using original quantities');
    return originalLotQuantities; // Return as-is
  }
  
  // *** ADDITIONAL CHECK: If difference is minimal (rounding), use original ***
  if (Math.abs(originalTotal - targetTotal) <= 1) {
    console.log('âœ… Difference is minimal - using original quantities');
    return originalLotQuantities;
  }
  
  // *** NEW: First-fill approach - prioritize lots by selection order ***
  let remainingCapacity = targetTotal;
  const lotIds = Object.keys(originalLotQuantities);
  
  console.log(`  Processing ${lotIds.length} lots with first-fill approach`);
  
  for (let i = 0; i < lotIds.length; i++) {
    const lotId = lotIds[i];
    const originalQty = originalLotQuantities[lotId];
    
    if (remainingCapacity <= 0) {
      // No capacity left for this lot
      prioritizedQuantities[lotId] = 0;
      console.log(`  Lot ${lotId}: 0 pieces (no capacity left)`);
    } else if (originalQty <= remainingCapacity) {
      // This lot can use its full original quantity
      prioritizedQuantities[lotId] = originalQty;
      remainingCapacity -= originalQty;
      console.log(`  Lot ${lotId}: ${originalQty} pieces (FULL - original quantity)`);
    } else {
      // This lot gets whatever capacity is left
      prioritizedQuantities[lotId] = remainingCapacity;
      remainingCapacity = 0;
      console.log(`  Lot ${lotId}: ${prioritizedQuantities[lotId]} pieces (PARTIAL - remaining capacity)`);
    }
  }
  
  const finalTotal = Object.values(prioritizedQuantities).reduce((sum, qty) => sum + qty, 0);
  console.log(`  Final allocation: ${finalTotal}/${targetTotal} capacity used`);
  
  return prioritizedQuantities;
}

    // *** FIXED: Get original lot quantities from backend data, not tray calculations ***
// *** FIXED: Ensure original lot comes first, then checkboxes in selection order ***
const originalLotQuantities = {};

// Add original modal data FIRST (highest priority)
if (originalModalData && originalModalData.lotQty && currentModalLotId) {
  const originalLotQty = parseInt(originalModalData.lotQty);
  if (originalLotQty > 0) {
    originalLotQuantities[currentModalLotId] = originalLotQty;
    console.log(`ðŸ¥‡ PRIORITY 1 - Original lot ${currentModalLotId}: ${originalLotQty} pieces`);
  }
}

// Add checkbox selections in order (lower priority)
validResults.forEach((r, index) => {
  const lotId = r.original_lot_id;
  const originalQty = r.original_quantity || 0;
  
  // Skip if this is the original lot (already added)
  if (lotId === currentModalLotId) {
    console.log(`â­ï¸  Skipping lot ${lotId} (already added as original)`);
    return;
  }
  
  if (originalQty > 0) {
    originalLotQuantities[lotId] = originalQty;
    console.log(`ðŸ¥ˆ PRIORITY ${index + 2} - Checkbox lot ${lotId}: ${originalQty} pieces`);
  }
});

    console.log('CORRECTED original lot quantities from backend:', originalLotQuantities);
    const originalTotal = Object.values(originalLotQuantities).reduce((sum, qty) => sum + qty, 0);
    console.log(`Original Total: ${originalTotal}, Jig Capacity: ${originalJigCapacity}`);

    // *** FIX: Check if capping is needed ***
    let calculatedLotIdQuantities;
    let actualTotalQty;
    
    if (originalTotal <= originalJigCapacity) {
      console.log('ðŸŽ‰ NO CAPPING NEEDED! Using exact quantities');
      
      // Use exact quantities
      calculatedLotIdQuantities = { ...originalLotQuantities };
      actualTotalQty = originalTotal;
      
    } else {
      console.log('âš–ï¸ CAPPING NEEDED - applying proportional reduction');
      
      // Apply proportional reduction (existing logic)
      calculatedLotIdQuantities = calculateProportionalLotQuantities(
        originalLotQuantities, 
        originalJigCapacity,
        originalTotal
      );
      
      actualTotalQty = Object.values(calculatedLotIdQuantities).reduce((sum, qty) => sum + qty, 0);
      
      // Show warning
      const excessQty = originalTotal - actualTotalQty;
      showModalMessage('warning', 'LOT Quantity Capped', 
        `Total LOT quantity (${originalTotal}) exceeds Jig capacity (${originalJigCapacity}). Reduced by ${excessQty} to fit jig capacity.`, 
        { duration: 500 });
    }

    // Update modal fields with final values
    document.getElementById('modalLotQty').value = actualTotalQty;
    
    // Nickel Bath Type: Only show if all are the same
    const uniqueBathTypes = [...new Set(combinedBathTypes)];
    if (uniqueBathTypes.length === 1) {
      document.getElementById('modalBathType').value = uniqueBathTypes[0];
    } else if (uniqueBathTypes.length > 1) {
      document.getElementById('modalBathType').value = 'Mixed Types';
    } else {
      document.getElementById('modalBathType').value = '';
    }
    
    // Jig Capacity: Always use the original/initial jig capacity
    document.getElementById('modalJigCapacity').value = originalJigCapacity;

    // Calculate Empty Hooks: Jig Capacity - Actual Total
    const actualEmptySlots = Math.max(0, originalJigCapacity - actualTotalQty);
    document.getElementById('modalEmptySlots').value = actualEmptySlots;
    updateAddJigButtonState(actualEmptySlots);  // NEW: Disable Add Jig if empty slots > 0


    // Store values for faulty slots calculation
    window.originalCombinedEmptySlots = actualEmptySlots;
    window.originalCombinedLotQty = actualTotalQty;
    
    // Store in global variable for collectModalData to use
    window.currentLotIdQuantities = calculatedLotIdQuantities;
    
    console.log('Final calculated lot_id_quantities (with proportional capping):', calculatedLotIdQuantities);

    // === UPDATED: Use backend API for multi-model tray distribution ===
    console.log('ðŸš€ Using backend API for multi-model optimal distribution');
    
    const trayTable = document.getElementById('delinkTrayTable');
    trayTable.innerHTML = `
      <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
      <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
    `;

    // *** CRITICAL FIX: Always use multi-model API when multiple models selected ***
    const isMultiModel = checked.length > 0; // If any checkbox is selected
    console.log(`ðŸ” Multi-model detection: ${isMultiModel ? 'YES' : 'NO'} (${checked.length} checkboxes selected)`);

    // ðŸ” DEBUG: Add this console log to verify
    console.log('ðŸ” DEBUG: About to call multi-model API');
    console.log('   calculatedLotIdQuantities:', calculatedLotIdQuantities);
    console.log('   Object.keys(calculatedLotIdQuantities):', Object.keys(calculatedLotIdQuantities));
    console.log('   Values:', Object.values(calculatedLotIdQuantities));

if (isMultiModel) {
  // *** CRITICAL FIX: Capture CURRENT tray table state, not just original draft ***
  console.log('ðŸ”’ === STARTING MULTI-MODEL TRAY PRESERVATION ===');
  console.log('ðŸ”’ Step 1: Capturing LIVE tray table state before ANY DOM modifications');
  
  // Get current entered tray IDs from the table IMMEDIATELY
  const currentTrayData = preserveExistingTrayDataBeforeClear();
  console.log(`ðŸ”’ âœ… Current tray table state captured: ${currentTrayData.length} entries`);
  currentTrayData.forEach((entry, i) => {
    console.log(`ðŸ”’   Current ${i+1}: TrayID="${entry.tray_id}", LotID="${entry.lot_id}", Source=${entry.from_draft ? 'DRAFT' : 'MANUAL'}`);
  });
  
  // Step 2: Get original draft data from database
  const originalDraftData = window.originalDraftTrayData || [];
  console.log(`ðŸ”’ ðŸ“‹ Original draft entries from database: ${originalDraftData.length}`);
  originalDraftData.forEach((entry, i) => {
    console.log(`ðŸ”’   Original ${i+1}: TrayID="${entry.tray_id}", LotID="${entry.lot_id}"`);
  });
  
  // Step 3: Merge current state with original draft
  const existingDraftData = [...originalDraftData];
  
  // Add any new tray entries that weren't in the original draft
  currentTrayData.forEach(current => {
    if (current.tray_id && current.tray_id.trim()) { // Only if tray ID is filled
      const existsInDraft = existingDraftData.find(draft => 
        draft.tray_id === current.tray_id
      );
      
      if (!existsInDraft) {
        console.log(`ðŸ”’ âž• Adding NEW tray entry: ${current.tray_id} (lot: ${current.lot_id})`);
        existingDraftData.push({
          tray_id: current.tray_id,
          lot_id: current.lot_id,
          expected_usage: current.expected_usage || 0,
          from_current_table: true
        });
      }
    } else if (current.lot_id) {
      // Even for empty tray IDs, preserve the lot allocation
      const existsInDraft = existingDraftData.find(draft => 
        draft.lot_id === current.lot_id && !draft.tray_id
      );
      
      if (!existsInDraft) {
        console.log(`ðŸ”’ âž• Adding empty slot reservation for lot: ${current.lot_id}`);
        existingDraftData.push({
          tray_id: '',
          lot_id: current.lot_id,
          expected_usage: current.expected_usage || 0,
          from_current_table: true
        });
      }
    }
  });
  
  console.log('ðŸ”’ === FINAL PRESERVATION RESULT ===');
  console.log('ðŸ”’ Final combined draft entries:', existingDraftData.length);
  existingDraftData.forEach((entry, i) => {
    console.log(`ðŸ”’   Final ${i+1}: TrayID="${entry.tray_id}", LotID="${entry.lot_id}", Source=${entry.from_current_table ? 'CURRENT' : 'ORIGINAL'}`);
  });
  
  // Store for populateDelinkTrayTableMultiModel to use
  window.preservedDraftTrayData = existingDraftData;
  
  // Use multi-model backend API with proportionally capped quantities
  console.log('ðŸ“Š Calling multi-model backend API with quantities:', calculatedLotIdQuantities);
  
  const populationResult = await populateDelinkTrayTableMultiModel(calculatedLotIdQuantities, trayTable);
  
  // Clear the variable after use
  window.preservedDraftTrayData = null;
  
  // Store multi-model distribution for later use
  window.currentMultiModelDistribution = populationResult.distribution;
  
  // === UPDATED: Populate half-filled tray table using backend distribution ===
  if (populationResult && populationResult.distribution) {
    console.log('âœ… Updating half-filled tray table with multi-model distribution');
    populateHalfFilledTrayTableMultiModel(populationResult.distribution);
  } else {
    console.log('âŒ No distribution found, hiding half-filled tray table');
    populateHalfFilledTrayTable([]);
  }
}
    
    // === UPDATED: Setup faulty slots handler for multi-model ===
    if (validResults.length > 1) {
      console.log('ðŸ”§ Setting up multi-model faulty slots handler');
      setupFaultySlotHandlerMultiModel(validResults, calculatedLotIdQuantities, window.currentMultiModelDistribution);
    } else {
      console.log('ðŸ”§ Setting up single model faulty slots handler');
      // Use single model logic for single selection
      const faultySlotInput = document.getElementById('modalFaultySlots');
      const emptySlotInput = document.getElementById('modalEmptySlots');
      const lotQtyInput = document.getElementById('modalLotQty');
      
      if (faultySlotInput) {
        // Remove any existing event listeners
        faultySlotInput.replaceWith(faultySlotInput.cloneNode(true));
        const newFaultySlotInput = document.getElementById('modalFaultySlots');
        
        newFaultySlotInput.addEventListener('input', function() {
        const faultySlots = parseInt(newFaultySlotInput.value) || 0;
        
        if (faultySlots <= 0) {
          // Reset to original values
          emptySlotInput.value = window.originalCombinedEmptySlots;
          lotQtyInput.value = window.originalCombinedLotQty;
          
          // *** ENHANCED: Reset half filled trays for single model ***
          const filteredCombinedHalfFilledTrays = filterToTopTrayOnly(combinedHalfFilledTrays);
          populateHalfFilledTrayTable(filteredCombinedHalfFilledTrays);
        } else {
            // *** FIXED: Proper faulty slots logic ***
            let newEmptySlots = window.originalCombinedEmptySlots;
            let newLotQty = window.originalCombinedLotQty;
            
            // Calculate usable jig capacity after faulty slots
            const jigCapacity = parseInt(document.getElementById('modalJigCapacity').value) || 0;
            const usableJigCapacity = Math.max(0, jigCapacity - faultySlots);
            
            console.log(`Faulty slots calculation:`);
            console.log(`  Jig capacity: ${jigCapacity}`);
            console.log(`  Faulty slots: ${faultySlots}`);
            console.log(`  Usable capacity: ${usableJigCapacity}`);
            console.log(`  Original LOT qty: ${window.originalCombinedLotQty}`);
            
            // *** KEY FIX: Only reduce LOT qty if it exceeds usable jig capacity ***
            if (window.originalCombinedLotQty > usableJigCapacity) {
              // LOT qty exceeds usable capacity, need to reduce it
              newLotQty = usableJigCapacity;
              newEmptySlots = 0; // No empty slots if at capacity
              
              console.log(`  LOT qty reduced to fit usable capacity: ${newLotQty}`);
              
              // Show half filled tray only if there's actual remaining quantity
              // For single model, check if original available quantity > reduced jig quantity
              const filteredCombinedHalfFilledTrays = filterToTopTrayOnly(combinedHalfFilledTrays);
              if (filteredCombinedHalfFilledTrays.length > 0) {
                console.log(`  Showing original half filled trays`);
                populateHalfFilledTrayTable(filteredCombinedHalfFilledTrays);
              } else {
                console.log(`  No half filled trays available`);
                populateHalfFilledTrayTable([]);
              }
            } else {
              // *** FIXED: LOT qty fits within usable capacity ***
              // Only reduce empty slots, keep LOT qty unchanged
              newEmptySlots = Math.max(0, window.originalCombinedEmptySlots - faultySlots);
              newLotQty = window.originalCombinedLotQty; // Keep original LOT qty
              
              console.log(`  LOT qty fits in usable capacity, keeping original: ${newLotQty}`);
              console.log(`  New empty slots: ${newEmptySlots}`);
              
              // *** KEY FIX: Check if original half filled trays should be shown ***
              // Only show half filled trays if they were originally calculated and jig doesn't use entire quantity
              const filteredCombinedHalfFilledTrays = filterToTopTrayOnly(combinedHalfFilledTrays);
              
              // *** ADDITIONAL FIX: Check if backend said no half filled tray needed ***
              // If backend indicated jig_fully_utilized or show_half_filled_table is false, don't show half filled tray
              let shouldShowHalfFilled = filteredCombinedHalfFilledTrays.length > 0;
              
              // Check if any data object indicates jig uses entire quantity
              if (window.currentJigData) {
                const jigUsesEntireQuantity = window.currentJigData.jig_fully_utilized || 
                                            !window.currentJigData.show_half_filled_table ||
                                            (window.currentJigData.display_qty >= (window.currentJigData.original_quantity || 0));
                if (jigUsesEntireQuantity) {
                  shouldShowHalfFilled = false;
                  console.log(`  Backend indicates jig uses entire quantity - no half filled tray needed`);
                }
              }
              
              if (shouldShowHalfFilled) {
                console.log(`  Showing original half filled trays`);
                populateHalfFilledTrayTable(filteredCombinedHalfFilledTrays);
              } else {
                console.log(`  No half filled tray needed - jig uses entire quantity or backend said no`);
                populateHalfFilledTrayTable([]);
              }
            }
            
            // Update the fields
            emptySlotInput.value = newEmptySlots;
            updateAddJigButtonState(newEmptySlots);  // NEW: Update Add Jig button state
            lotQtyInput.value = newLotQty;

            // NEW: Recalculate tray distribution with adjusted quantity
            if (newLotQty !== window.originalCombinedLotQty) {
              const currentLotId = currentModalLotId;
              if (currentLotId) {
                fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentLotId)}&adjusted_qty=${newLotQty}`)
                  .then(res => res.json())
                  .then(data => {
                    // Update tray tables with new distribution
                    const trayTable = document.getElementById('delinkTrayTable');
                    trayTable.innerHTML = `
                      <div style="background: #dcdcdc; font-weight: bold; color: #028084;">S.No</div>
                      <div style="background: #dcdcdc; font-weight: bold; color: #028084;">Tray ID</div>
                    `;
                    populateDelinkTrayTableFromCalculation(data, trayTable, newLotQty);
                    
                    // Update half filled trays
                    if (data.half_filled_trays && data.show_half_filled_table) {
                      const topTrayOnly = filterToTopTrayOnly(data.half_filled_trays);
                      populateHalfFilledTrayTable(topTrayOnly);
                    } else {
                      populateHalfFilledTrayTable([]);
                    }
                  })
                  .catch(error => console.error('Error recalculating with adjusted qty:', error));
              }
            }
            
            // Show warning if faulty slots exceed total capacity
            if (faultySlots > jigCapacity) {
              showModalMessage('warning', 'Broken/Buildup Hooks Exceed Capacity', 
                `Faulty slots (${faultySlots}) exceed jig capacity (${jigCapacity}).`, 
                { duration: 500 });
              newFaultySlotInput.value = jigCapacity;
              return; // Exit early
            }
          }
          
          // Update Add Model button state
          const currentEmptySlots = parseInt(emptySlotInput.value) || 0;
          updateAddModelButtonState(currentEmptySlots);
        });
     
      }
    }

    // Disable/Enable "Add Model" button based on empty slots
    updateAddModelButtonState(actualEmptySlots);

    // Update slider with all models (original + selected) - DEDUPLICATED
    const slider = document.getElementById('modelSliderDynamic');
    slider.innerHTML = ''; // Clear all content first
    
    // Collect all models first, then deduplicate
    const allModels = [];
    
    // First, add the original model if available
    if (originalModalData && originalModalData.modelNo && originalModalData.modelNo !== '-') {
      // Re-fetch original model image data to ensure we have the image
      try {
        const originalResponse = await fetch(`/jig_loading/fetch_jig_related_data/?stock_lot_id=${encodeURIComponent(currentModalLotId)}`);
        const originalData = await originalResponse.json();
        
        allModels.push({
          modelNo: originalData.plating_stk_no || originalModalData.modelNo,
          image: (originalData.model_images && originalData.model_images.length > 0) ? originalData.model_images[0] : '/static/assets/images/imagePlaceholder.png',
          isOriginal: true,
          lotId: currentModalLotId
        });
      } catch (error) {
        console.error('Error fetching original model data:', error);
        // Fallback to stored data without image
        allModels.push({
          modelNo: originalModalData.modelNo,
          image: '/static/assets/images/imagePlaceholder.png',
          isOriginal: true,
          lotId: currentModalLotId
        });
      }
    }

    // Add checkbox models to slider using REDUCED QUANTITIES
    console.log(`Adding ${validResults.length} models to slider with reduced quantities`);

    // Add checkbox models to the collection - FIXED: Use single loop to avoid duplicates
    console.log(`Adding ${validResults.length} models to slider with reduced quantities`);
    
    for (const lotId of window.currentLotIds.slice(1)) {  // Skip first (parent), use rest in order
      const reducedQty = window.currentLotIdQuantities[lotId];
      if (!reducedQty) continue;  // Skip if no quantity
      
      // Find the corresponding result
      const result = validResults.find(r => r.original_lot_id === lotId);
      if (result && result.plating_stk_no) {
        console.log(`Adding model ${result.plating_stk_no} (lot: ${lotId}) with reduced qty: ${reducedQty} (was ${result.original_quantity})`);
        
        allModels.push({
          modelNo: result.plating_stk_no || '-',
          image: (result.model_images && result.model_images.length > 0) ? result.model_images[0] : '/static/assets/images/imagePlaceholder.png',
          isOriginal: false,
          lotId: lotId,
          reducedQuantity: reducedQty  // Store the reduced quantity
        });
      }
    }
    
    // Deduplicate models by modelNo and lotId
    const uniqueModels = deduplicateModels(allModels);
    console.log(`Deduplicated models: ${allModels.length} -> ${uniqueModels.length}`);
    
    // Render deduplicated models to slider
    uniqueModels.forEach(modelData => {
      const item = createModelItem(modelData);
      slider.appendChild(item);
    });
    
    // Update the scope-level combinedModelNos with deduplicated model numbers
    combinedModelNos = uniqueModels.map(m => m.modelNo);
    
    // Update the modal display with deduplicated model numbers
    document.getElementById('rightModalModelNo').textContent = combinedModelNos.join(', ') || '-';
    
    // Update slider position
    setTimeout(updateSliderPosition, 100);
    
    // Log the final model count (should be deduplicated)
    console.log(`Final model count in slider: ${slider.children.length}`);
    console.log(`Combined model numbers (deduplicated): [${combinedModelNos.join(', ')}]`);
  });
});

// Handle "Add Model" button click with modal messages and batch status filtering
document.querySelectorAll('.btn-action.teal').forEach(function(btn) {
  btn.addEventListener('click', function(e) {
    e.preventDefault();
    
    // Check if button is disabled
    if (btn.disabled) {
      showModalMessage('warning', 'Jig is Full', 'Cannot add more models. The jig has reached its maximum capacity.', { duration: 3000 });
      return;
    }
    
    // Check if empty slots is zero or negative
    const emptySlots = parseInt(document.getElementById('modalEmptySlots').value) || 0;
    if (emptySlots <= 0) {
      showModalMessage('warning', 'No Available Slots', 'Cannot add more models. The jig capacity is full.', { duration: 3000 });
      return;
    }
    
    // Get the current lot ID from the modal
    const currentLotId = currentModalLotId;
    if (!currentLotId) return;

    // Get original model details for filtering
    const originalPlatingColor = document.getElementById('modalBathType').value || '';
    const originalModelNo = document.getElementById('rightModalModelNo').textContent || '';
    const originalPolishFinish = ''; // We'll get this from the table row

    // HIDE the modal completely
    const modal = document.getElementById('rightSideModal');
    if (modal) {
      modal.classList.remove('open');
      modal.classList.remove('minimized');
      modal.style.display = 'none'; // Completely hide
    }

    // Get original row data for comparison
    let originalRowData = {};
    const tbody = document.querySelector('#order-listing tbody');
    
// First pass: find the original row and get its data
tbody.querySelectorAll('tr').forEach(function(row) {
  const actionCell = row.querySelector('a[data-stock-lot-id], button[data-stock-lot-id]');
  if (actionCell && actionCell.getAttribute('data-stock-lot-id') === currentLotId) {
    const cells = row.querySelectorAll('td');
    originalRowData = {
      modelNo: cells[2]?.textContent?.trim() || '',
      platingColor: cells[4]?.textContent?.trim() || '',
      polishFinish: cells[5]?.textContent?.trim() || '',
      version: cells[6]?.textContent?.trim() || '',
      trayType: cells[8]?.textContent?.trim() || '', // NEW: Extract tray type
      jigType: cells[11]?.textContent?.trim().split(' - ')[0] || ''
    };
  }
});

    console.log('Original row data for filtering (with jig type):', originalRowData);

    // Helper function to get batch status from row
    function getBatchStatusFromRow(row) {
      const batchStatusCell = row.cells[15]; // Lot Status is the 16th column (index 15)
      if (batchStatusCell) {
        const statusElement = batchStatusCell.querySelector('.d-inline-block');
        if (statusElement) {
          return statusElement.textContent.trim();
        }
      }
      return '';
    }

    /// Second pass: filter the table based on criteria AND batch status
let visibleRowCount = 0;
let excludedByBatchStatus = 0;
let excludedByJigType = 0;
let excludedByTrayType = 0; // NEW: Track tray type exclusions

tbody.querySelectorAll('tr').forEach(function(row) {
  const actionCell = row.querySelector('a[data-stock-lot-id], button[data-stock-lot-id]');
  const checkbox = row.querySelector('.model-select-checkbox');
  
  if (actionCell && actionCell.getAttribute('data-stock-lot-id') === currentLotId) {
    // Hide the current lot_id row completely
    row.style.display = 'none';
  } else {
    // Check batch status first
    const batchStatus = getBatchStatusFromRow(row);
    const isExcludedStatus = batchStatus === 'Yet to Release' || batchStatus === 'Released' || batchStatus === 'Draft';
    if (isExcludedStatus) {
      // Hide rows with excluded batch statuses
      row.style.display = 'none';
      if (checkbox) {
        checkbox.style.display = 'none';
      }
      excludedByBatchStatus++;
      return; // Skip further processing for this row
    }

    // Check if this row matches the filtering criteria
    const cells = row.querySelectorAll('td');
    const rowData = {
      modelNo: cells[2]?.textContent?.trim() || '',
      platingColor: cells[4]?.textContent?.trim() || '',
      polishFinish: cells[5]?.textContent?.trim() || '',
      version: cells[6]?.textContent?.trim() || '',
      trayType: cells[8]?.textContent?.trim() || '', // NEW: Extract tray type
      jigType: cells[11]?.textContent?.trim().split(' - ')[0] || ''
    };

// Apply filtering criteria with priority order
let shouldShow = false;
let isVersionMismatch = false;

// Check all required matches
const trayTypeMatches = rowData.trayType === originalRowData.trayType && originalRowData.trayType !== '';
const jigTypeMatches = rowData.jigType === originalRowData.jigType && originalRowData.jigType !== '';
const platingColorMatches = rowData.platingColor === originalRowData.platingColor && originalRowData.platingColor !== '';
const polishFinishMatches = rowData.polishFinish === originalRowData.polishFinish && originalRowData.polishFinish !== '';

// ALL conditions must match: Tray Type + Jig Type + Plating Color + Polish Finish
if (trayTypeMatches || jigTypeMatches) {
    shouldShow = true;
}

// If any condition doesn't match, don't show the row
else {
  shouldShow = false;
  if (!trayTypeMatches) excludedByTrayType++;
  if (!jigTypeMatches) excludedByJigType++;
}

    // Show/hide based on criteria
    if (shouldShow) {
      row.style.display = '';
      if (checkbox) {
        checkbox.style.display = 'inline-block';
      }
      
      // Add a visual indicator for the match type
      if (!row.querySelector('.match-indicator')) {
        const indicator = document.createElement('span');
        indicator.className = 'match-indicator';
        
        // Special styling for version mismatch
        if (isVersionMismatch) {
          indicator.style.cssText = `
            background: #d1ecf1;
            color: #0c5460;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            font-weight: bold;
            border: 1px solid #bee5eb;
            animation: pulse 2s infinite;
          `;
        } else {
          indicator.style.cssText = `
            background: #e8f5e8;
            color: #155724;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            font-weight: bold;
          `;
        }
        
      }
      
      visibleRowCount++;
    } else {
      row.style.display = 'none';
      if (checkbox) {
        checkbox.style.display = 'none';
      }
    }
  }
});

// AFTER filtering logic, sort visible rows by "Empty Hooks" value (ascending)
const visibleRows = [];
tbody.querySelectorAll('tr').forEach(function(row) {
  if (row.style.display !== 'none') {
    // Adjust index if needed; here 8th column is "Empty Hooks"
    const emptyHooksCell = row.querySelector('td:nth-child(8)');
    let emptyHooks = 0;
    if (emptyHooksCell) {
      emptyHooks = parseInt(emptyHooksCell.textContent.trim()) || 0;
    }
    visibleRows.push({ row, emptyHooks });
  }
});

// Sort and re-append
visibleRows.sort((a, b) => a.emptyHooks - b.emptyHooks);
visibleRows.forEach(({ row }) => {
  tbody.appendChild(row);
});

    // Add a visual indicator that filtering is active
    let filterIndicator = document.getElementById('filterIndicator');
    if (!filterIndicator) {
      filterIndicator = document.createElement('div');
      filterIndicator.id = 'filterIndicator';
      filterIndicator.style.cssText = `
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: #e8f5e8;
        border: 2px solid #28a745;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        color: #155724;
        z-index: 9999;
        animation: slideDown 0.3s ease;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      `;
      
      // NEW: Enhanced message to show jig type filtering
// NEW: Enhanced message to show both tray type and jig type filtering
let filterMessage = `
  <i class="fa fa-filter" style="margin-right: 8px;"></i>
  Filtered view - <strong>Choose a Lot to Add in the Jig</strong>
`;

// Add batch status exclusion info if any were excluded
if (excludedByBatchStatus > 0) {
}

// NEW: Add tray type exclusion info if any were excluded
if (excludedByTrayType > 0) {
}

// Add jig type exclusion info if any were excluded
if (excludedByJigType > 0) {
}
      filterMessage += `
        <button type="button" id="resetFilterBtn" style="margin-left: 10px; background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset & Close</button>
      `;
      
      filterIndicator.innerHTML = filterMessage;
      document.body.appendChild(filterIndicator);
      
      // Add event listener to the reset button
      const resetBtn = document.getElementById('resetFilterBtn');
      if (resetBtn) {
        resetBtn.addEventListener('click', function() {
          // Restore the modal popup
          const modal = document.getElementById('rightSideModal');
          if (modal) {
            modal.style.display = 'block';
            modal.classList.add('open');
            modal.classList.remove('minimized');
          }
          // Remove filter indicator
          const filterIndicator = document.getElementById('filterIndicator');
          if (filterIndicator) {
            filterIndicator.remove();
          }
          // Restore checkboxes and table rows
          document.querySelectorAll('.model-select-checkbox').forEach(cb => {
            cb.style.display = '';
            cb.disabled = false;
            cb.style.opacity = '1';
            cb.style.cursor = 'pointer';
            cb.title = '';
          });
          document.querySelectorAll('tbody tr').forEach(row => {
            row.style.display = '';
            row.style.opacity = '';
            row.style.pointerEvents = '';
          });
          // Scroll modal into view and focus Jig ID input
          setTimeout(() => {
            modal.scrollIntoView({ behavior: 'smooth', block: 'center' });
            const jigInput = document.getElementById('modalJigQrId');
            if (jigInput) {
              jigInput.focus();
              jigInput.select();
            }
          }, 200);
        });
      }

    }





    // Show toast with enhanced message
// Show toast with enhanced message
if (visibleRowCount === 0) {
  // NEW: Updated toast message to include both tray type and jig type requirement
  let toastMessage = `No compatible models found with same Tray Type (${originalRowData.trayType}) and Jig Type (${originalRowData.jigType}) and matching plating color, polish finish, or model number.`;
  if (excludedByBatchStatus > 0) {
    toastMessage += ` (${excludedByBatchStatus} items were excluded due to "Yet to Release" or "Released" status)`;
  }
  if (excludedByTrayType > 0) {
    toastMessage += ` (${excludedByTrayType} items had different Tray Type)`;
  }
  if (excludedByJigType > 0) {
    toastMessage += ` (${excludedByJigType} items had different Jig Type)`;
  }
  showToast('info', toastMessage, 500);
    } else {
      // Check if we should disable checkboxes based on empty slots
      // Get current empty slots from the modal before it was hidden
      const modalEmptySlots = parseInt(document.getElementById('modalEmptySlots').value) || 0;
      
      if (modalEmptySlots <= 0) {
        // Disable all checkboxes if no empty slots
        tbody.querySelectorAll('tr').forEach(function(row) {
          const checkbox = row.querySelector('.model-select-checkbox');
          if (checkbox && checkbox.style.display !== 'none') {
            checkbox.disabled = true;
            checkbox.style.opacity = '0.5';
            checkbox.style.cursor = 'not-allowed';
            checkbox.title = 'Cannot select - Jig is full';
            
            // Add visual indicator to the row
            row.style.opacity = '0.7';
            row.style.pointerEvents = 'none';
          }
        });
        
        // Update filter indicator to show that selection is disabled
        const filterIndicator = document.getElementById('filterIndicator');
        if (filterIndicator) {
          // NEW: Updated message to include jig type info
          let updatedMessage = `
            <i class="fa fa-filter" style="margin-right: 8px;"></i>
  Filtered view - <strong>Choose a Lot to Add in the Jig</strong>
            <br><small style="color: #dc3545;"><strong>Selection Disabled:</strong> Jig is full (0 empty slots)</small>
          `;
          
          if (excludedByBatchStatus > 0) {
            updatedMessage += `<br><small style="color: #dc3545;"><strong>Note:</strong> ${excludedByBatchStatus} items excluded (Yet to Release/Released status)</small>`;
          }
          
          if (excludedByJigType > 0) {
            updatedMessage += `<br><small style="color: #ff9800;"><strong>Note:</strong> ${excludedByJigType} items excluded (Different Jig Type)</small>`;
          }
          
          updatedMessage += `
            <button type="button" id="resetFilterBtn" style="margin-left: 10px; background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset & Close</button>
          `;
          
          filterIndicator.innerHTML = updatedMessage;
          
          // Re-add event listener to the new reset button
          const resetBtn = document.getElementById('resetFilterBtn');
          if (resetBtn) {
            resetBtn.addEventListener('click', function() {
              // Restore the modal popup
              const modal = document.getElementById('rightSideModal');
              if (modal) {
                modal.style.display = 'block';
                modal.classList.add('open');
                modal.classList.remove('minimized');
              }
              // Remove filter indicator
              const filterIndicator = document.getElementById('filterIndicator');
              if (filterIndicator) {
                filterIndicator.remove();
              }
              // Restore checkboxes and table rows
              document.querySelectorAll('.model-select-checkbox').forEach(cb => {
                cb.style.display = '';
                cb.disabled = false;
                cb.style.opacity = '1';
                cb.style.cursor = 'pointer';
                cb.title = '';
              });
              document.querySelectorAll('tbody tr').forEach(row => {
                row.style.display = '';
                row.style.opacity = '';
                row.style.pointerEvents = '';
              });
              // Scroll modal into view and focus Jig ID input
              setTimeout(() => {
                modal.scrollIntoView({ behavior: 'smooth', block: 'center' });
                const jigInput = document.getElementById('modalJigQrId');
                if (jigInput) {
                  jigInput.focus();
                  jigInput.select();
                }
              }, 200);
            });
          }

        }
      }
    }
  });
});

  // Add navigation event listeners for slider
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('prev-btn')) {
      if (currentSlideIndex > 0) {
        currentSlideIndex--;
        updateSliderPosition();
      }
    } else if (e.target.classList.contains('next-btn')) {
      const container = document.querySelector('.model-slider-container');
      if (!container) return;
      const containerWidth = container.offsetWidth;
      const visibleItems = Math.floor(containerWidth / itemWidth);
      const totalItems = document.getElementById('modelSliderDynamic').children.length;
      
      if (currentSlideIndex + visibleItems < totalItems) {
        currentSlideIndex++;
        updateSliderPosition();
      }
    }
  });

 // Handle modal close button
document.querySelectorAll('.close-btn').forEach(function(btn) {
  btn.addEventListener('click', async function(e) {
    e.preventDefault();
    
    // *** NEW: Clear autosave data when closing modal to reset new models and calculations ***
    if (currentModalLotId) {
      try {
        await fetch('/jig_loading/autosave/' + encodeURIComponent(currentModalLotId), {
          method: 'DELETE',
          headers: {
            'X-CSRFToken': getCookie('csrftoken')
          }
        });
        console.log('âœ… Autosave cleared for lot:', currentModalLotId);
      } catch (error) {
        console.warn('âš ï¸ Failed to clear autosave:', error);
      }
    }
    
    const modal = document.getElementById('rightSideModal');
    if (modal) {
      modal.classList.remove('open');
      modal.classList.remove('minimized');
      modal.style.display = 'none';
    }
    
    // Reset table filter and hide all checkboxes
    resetTableFilter();
    
    // Reset everything
    document.querySelectorAll('.model-select-checkbox').forEach(function(cb) {
      cb.checked = false;
      cb.style.display = 'none';
    });
    
    updateSelectedItemsStatus();
    originalModalData = null;
    currentModalLotId = null;
    currentSlideIndex = 0;
  });
});
  // Global function to reset table filter
  window.resetTableFilter = function() {
    window.location.reload();
  };

  // Handle window resize
  window.addEventListener('resize', updateSliderPosition);

// Action button handlers - Enhanced Add Jig functionality
// Clear auto-save on successful Add Jig
document.addEventListener('click', function(e) {
  if (e.target.closest('.action-buttons .btn-twitter')) {
    const button = e.target.closest('.action-buttons .btn-twitter');
    if (button.textContent.trim() === 'Add Jig') {
      e.preventDefault();
      // Save jig details but keep modal open
      saveJigDetails({ keepModalOpen: true }).then(success => {
        if (success) {
          // Clear auto-save after successful add
          const lotId = getCurrentLotId();
          if (lotId) {
           
          }
          console.log('Add Jig completed successfully');
        }
      });
    }
  }
});

document.addEventListener('click', function(e) {
  if (e.target.closest('.action-buttons .btn-success')) {
    const button = e.target.closest('.action-buttons .btn-success');
    if (button.textContent.trim() === 'Submit') {
      e.preventDefault();
      
      // Save and close modal, then refresh page
      saveJigDetails().then(success => {
        if (success) {

          // Clear auto-save after successful submit
      const lotId = getCurrentLotId();
      if (lotId) {
   
      }
      console.log('Add Jig completed successfully');

          // <<< ADD: clear local guard so buttons are re-enabled immediately >>>
          try {
            const addBtn = document.querySelector('.right-slide-modal .action-buttons .btn-twitter');
            const submitBtn = document.querySelector('.right-slide-modal .action-buttons .btn-success');
            if (window.__jig_mark_local_done) {
              if (addBtn) window.__jig_mark_local_done(addBtn);
              if (submitBtn) window.__jig_mark_local_done(submitBtn);
            } else {
              if (addBtn) { delete addBtn.dataset.__jig_submitted; addBtn.disabled = false; }
              if (submitBtn) { delete submitBtn.dataset.__jig_submitted; submitBtn.disabled = false; }
            }
          } catch (e) { console.warn('Failed to clear jig guard after save', e); }
          // <<< END add >>
          // Modal will be closed automatically by saveJigDetails
        }
      });
    }
  }
});

  // Handle other action buttons (Draft, Cancel)
  document.addEventListener('click', function(e) {
    if (e.target.closest('.action-buttons button')) {
      const button = e.target.closest('.action-buttons button');
      const action = button.textContent.trim();
  
      // Skip if this is Add Jig or Submit (they have their own handlers)
      if (action === 'Add Jig' || action === 'Submit') {
        return;
      }
  
      e.preventDefault();
  
      if (action === 'Draft') {
        // Save as draft (send is_draft: true)
        const modalData = collectModalData();
        modalData.is_draft = true;
        if (window.currentDraftId) modalData.draft_id = window.currentDraftId;
  
        fetch('/jig_loading/save_jig_details/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(modalData)
        })
        .then(res => res.json())
        .then(result => {
          if (result.success) {
            showToast('success', 'Drafted successfully', 1200);
            setTimeout(() => {
              window.location.href = "/jig_loading/JigView/";
            }, 500);
          } else {
            showModalMessage('error', 'Draft Failed', result.error || 'Could not save draft', { duration: 5000 });
          }
        })
        .catch(() => {
          showModalMessage('error', 'Draft Failed', 'Network error', { duration: 5000 });
        });
      } else if (action === 'Cancel') {
          // Just close the modal and show toast
          document.querySelectorAll('.right-slide-modal').forEach(modal => {
            modal.classList.remove('open');
            modal.style.display = 'none';
          });
      
          // Clear auto-save for current lot
          const lotId = typeof getCurrentLotId === 'function' ? getCurrentLotId() : window.currentModalLotId;

      
          showToast('success', 'Cancelled successfully', 1200);
          setTimeout(() => {
            window.location.href = "/jig_loading/JigView/";
          }, 500);
      }
    }
  });

  // Helper function for CSRF token
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }

// 1. Add this function after your other helper functions, e.g. after getCookie or similar helpers:
function collectTrayInputs() {
    // Collect tray IDs in the order they appear in the table
    const trayInputs = document.querySelectorAll('#delinkTrayTable input[type="text"]');
    const trays = [];
    trayInputs.forEach(input => {
        const trayId = input.value.trim();
        if (trayId) trays.push(trayId);
    });
    return trays;
}

// 2. Add this function after collectTrayInputs, before any modal logic:
function showTrayIdsInViewModal(trayIds) {
    // trayIds is an array in scanned order
    const trayList = trayIds.map((id, idx) => `<span>${idx + 1}. ${id}</span>`).join('<br>');
    // Example: set as innerHTML of your tooltip/modal
    document.getElementById('trayIdsViewModal').innerHTML = trayList;
}


});
</script>

<!-- Edit Quantity Script -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll('.edit-batch-qty-btn').forEach(function(editBtn) {
    editBtn.addEventListener('click', function(e) {
      e.preventDefault();
      const batchId = editBtn.getAttribute('data-batch-id');
      const row = editBtn.closest('tr');
      const qtyInput = row.querySelector('.edit-qty-input');
      if (qtyInput) {
        qtyInput.removeAttribute('readonly');
        qtyInput.focus();
        qtyInput.select();

        qtyInput.addEventListener('keydown', async function handler(ev) {
          if (ev.key === 'Enter') {
            ev.preventDefault();
            qtyInput.setAttribute('readonly', 'readonly');
            const newQty = qtyInput.value;
            
            // Show loading state
            const originalValue = qtyInput.value;
            qtyInput.style.opacity = '0.5';
            
            try {
              const resp = await fetch("{% url 'jig_update_batch_quantity' %}", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "X-CSRFToken": getCookie('csrftoken')
                },
                body: JSON.stringify({
                  batch_id: batchId,
                  brass_audit_accepted_qty: newQty
                })
              });
              const result = await resp.json();
              
              qtyInput.style.opacity = '1';
              
              if (result.success) {
                // Show success toast
                showToast('success', 'Quantity updated successfully!', 1500);
                
                setTimeout(() => {
                  window.location.reload();
                }, 1200);
              } else {
                // Show error message
                const modal = document.getElementById('rightSideModal');
                if (modal && modal.classList.contains('open')) {
                  showModalMessage('error', 'Update Failed', result.error || 'Update failed', { duration: 500 });
                } else {
                  showToast('error', result.error || 'Update failed', 500);
                }
                qtyInput.value = originalValue; // Restore original value
              }
            } catch (err) {
              console.error('Update error:', err);
              qtyInput.style.opacity = '1';
              qtyInput.value = originalValue; // Restore original value
              
              const modal = document.getElementById('rightSideModal');
              if (modal && modal.classList.contains('open')) {
                showModalMessage('error', 'Network Error', 'Failed to update quantity', { duration: 500 });
              } else {
                showToast('error', 'Network error occurred', 500);
              }
            }
            qtyInput.removeEventListener('keydown', handler);
          }
        });
      }
    });
  });
});

// Toast function for use in other scripts
function showToast(type, message, duration = 3000) {
  // Remove any existing toast
  const existingToast = document.getElementById('toastMessage');
  if (existingToast) {
    existingToast.remove();
  }

  const toast = document.createElement('div');
  toast.id = 'toastMessage';
  
  let bgColor, textColor, borderColor, icon;
  switch(type) {
    case 'success':
      bgColor = '#e7f3ff';
      textColor = '#0066cc';
      borderColor = '#007bff';
      icon = 'âœ“';
      break;
    case 'error':
      bgColor = '#ffd6d6';
      textColor = '#b30000';
      borderColor = '#dc3545';
      icon = 'âœ—';
      break;
    case 'warning':
      bgColor = '#fff3cd';
      textColor = '#856404';
      borderColor = '#ffc107';
      icon = 'âš ';
      break;
    case 'info':
      bgColor = '#d1ecf1';
      textColor = '#0c5460';
      borderColor = '#17a2b8';
      icon = 'â“˜';
      break;
    default:
      bgColor = '#d1ecf1';
      textColor = '#0c5460';
      borderColor = '#17a2b8';
      icon = 'â“˜';
  }
  
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${bgColor};
    color: ${textColor};
    border: 1px solid ${borderColor};
    padding: 12px 20px;
    border-radius: 8px;
    z-index: 10000;
    font-size: 14px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    animation: slideInToast 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    max-width: 350px;
  `;
  
  toast.innerHTML = `
    <span style="font-weight: bold; font-size: 16px;">${icon}</span>
    <span>${message}</span>
  `;
  
  document.body.appendChild(toast);
  
  if (duration > 0) {
    setTimeout(() => {
      toast.style.animation = 'slideOutToast 0.3s ease';
      setTimeout(() => {
        if (toast.parentNode) {
          toast.remove();
        }
      }, 300);
    }, duration);
  }
  
  return toast;
}
</script>

<!-- Delete Batch Script -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll('.jig-delete-batch-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const stockLotId = btn.getAttribute('data-stock-lot-id');

      // Use SweetAlert2 for confirmation
      Swal.fire({
        title: 'Are you sure?',
        text: "This action cannot be undone.",
        icon: 'warning',
        showCancelButton: true,
        confirmButtonColor: '#dc3545',
        cancelButtonColor: '#6c757d',
        confirmButtonText: 'Yes, delete it!',
        cancelButtonText: 'Cancel'
      }).then((result) => {
        if (result.isConfirmed) {
          // Show loading state
          const originalHTML = btn.innerHTML;
          btn.innerHTML = '<img src="{% static "assets/icons/loading.gif" %}" alt="Loading" style="width: 20px; height: 20px;" />';
          btn.style.opacity = '0.5';
          btn.style.pointerEvents = 'none';

          fetch("{% url 'jig_delete_batch' %}", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": getCookie('csrftoken')
            },
            body: JSON.stringify({ stock_lot_id: stockLotId })
          })
          .then(response => response.json())
          .then(data => {
            // Restore button state
            btn.innerHTML = originalHTML;
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';

            if (data.success) {
              Swal.fire('Deleted!', 'Batch deleted successfully!', 'success');
              setTimeout(() => {
                window.location.reload();
              }, 900);
            } else {
              Swal.fire('Error', data.error || 'Delete failed', 'error');
            }
          })
          .catch(error => {
            console.error('Delete error:', error);
            btn.innerHTML = originalHTML;
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
            Swal.fire('Error', 'Network error occurred', 'error');
          });
        }
      });
    });
  });
});
</script>

<!-- CSRF Token Helper -->
<script nonce="{{ csp_nonce }}">
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}
</script>

<!-- Active row to be highlighted & Restores the highlighted row to its original position and removes the highlight bg when the tray scan modal is closed. -->
<script nonce="{{ csp_nonce }}">
// Row highlight for Tray Scan (matches highlightWF.html logic) + Move active row to top and restore on close
document.addEventListener("DOMContentLoaded", function() {
  // Add highlight style if not present
  if (!document.getElementById('dp-row-action-highlight-style')) {
    var style = document.createElement('style');
    style.id = 'dp-row-action-highlight-style';
    style.innerHTML = `
      .dp-row-action-highlight {
        transition: box-shadow 1.3s;
        background-color: #fff5bd !important;
        animation: highlightAnimation 2s ease-in-out;
      }
    `;
    document.head.appendChild(style);
  }

  // Use a single set of variables for both tray-scan-btn and tray-scan-btn-Jig and Add Jig
  let originalRowIndex = null;
  let movedRow = null;
  let placeholderRow = null;

  // Highlight and move row for .tray-scan-btn, .tray-scan-btn-Jig, .open-jig-modal-btn, and checked checkboxes
  function highlightAndMoveRow(row) {
    // Remove highlight from all rows
    document.querySelectorAll('tbody tr').forEach(function(r) {
      r.classList.remove('dp-row-action-highlight');
    });
    if (row && row.parentNode) {
      const tbody = row.parentNode;
      // Only move if not already at top
      if (tbody.firstElementChild !== row) {
        // If a previous move exists, restore it first
        if (movedRow && placeholderRow && placeholderRow.parentNode) {
          placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
          placeholderRow.parentNode.removeChild(placeholderRow);
          movedRow.classList.remove('dp-row-action-highlight');
          movedRow = null;
          placeholderRow = null;
          originalRowIndex = null;
        }
        // Store original index and row
        originalRowIndex = Array.from(tbody.children).indexOf(row);
        movedRow = row;
        // Insert a placeholder at the original position
        placeholderRow = document.createElement('tr');
        placeholderRow.style.display = 'none';
        // Add same number of <td> as the moved row
        for (let i = 0; i < row.children.length; i++) {
          placeholderRow.appendChild(document.createElement('td'));
        }
        tbody.insertBefore(placeholderRow, tbody.children[originalRowIndex]);
        // Move row to top
        tbody.insertBefore(row, tbody.firstElementChild);
      }
      row.classList.add('dp-row-action-highlight');
    }
  }

  // For tray scan/view/add jig buttons
  document.querySelectorAll('.tray-scan-btn, .tray-scan-btn-Jig, .open-jig-modal-btn').forEach(function(link) {
    link.addEventListener('click', function(event) {
      var row = event.target.closest('tr');
      highlightAndMoveRow(row);
    });
  });

  // For checked checkboxes: highlight and move row to top
  document.querySelectorAll('.model-select-checkbox').forEach(function(checkbox) {
    checkbox.addEventListener('change', function() {
      setTimeout(() => {
      const lotId = getCurrentLotId();
      if (lotId) {
        console.log('Restoring auto-save after checkbox change');
      }
    }, 500);
      if (checkbox.checked) {
        var row = checkbox.closest('tr');
        highlightAndMoveRow(row);
      } else {
        // On uncheck, remove highlight but do not move row back (keep current active row)
        if (checkbox.closest('tr')) {
          checkbox.closest('tr').classList.remove('dp-row-action-highlight');
        }
      }
    });
  });

  // On modal close, restore row to original position and remove highlight for both modals
  function restoreRowAndClearHighlight() {
    if (movedRow && placeholderRow && placeholderRow.parentNode) {
      placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
      placeholderRow.parentNode.removeChild(placeholderRow);
      movedRow.classList.remove('dp-row-action-highlight');
      movedRow = null;
      placeholderRow = null;
      originalRowIndex = null;
    }
    // Also remove highlight from any row just in case
    document.querySelectorAll('tbody tr').forEach(function(row) {
      row.classList.remove('dp-row-action-highlight');
      row.classList.remove('highlighted-tray-scan');
    });
  }

  var closeBtn = document.getElementById('closeTrayScanModal');
  if (closeBtn) {
    closeBtn.addEventListener('click', restoreRowAndClearHighlight);
  }
  var jigCloseBtn = document.getElementById('closeTrayScanModal_DayPlanning');
  if (jigCloseBtn) {
    jigCloseBtn.addEventListener('click', restoreRowAndClearHighlight);
  }
});
</script>


<!-- // --- Child Screen Lock Feature ---
// When child screen (tray scan modal) is open, only allow scroll and Eye icon (view) access on parent.
// All other actions (edit, delete, filter, etc.) are blocked visually and functionally.
-->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  function lockParentActions() {
    // Select only buttons/inputs/links in parent panels, exclude modal dialogs
    document.querySelectorAll(
      '.main-panel button, .sidebar button, .main-panel a, .sidebar a, .main-panel img, .sidebar img, .main-panel .hold-toggle-btn, .sidebar .hold-toggle-btn, .open-jig-modal-btn button'
    ).forEach(function (el) {
      // Skip allowed elements: view eye
      if (
        el.closest('#rightSideModal') ||
        el.closest('#trayScanModal_DayPlanning') ||
        el.classList.contains('tray-scan-btn-Jig')
      ) {
        return; // donâ€™t lock modal internals or allowed buttons
      }

      // Disable everything else
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.4';
      el.style.filter = 'grayscale(1)';
      el.style.cursor = 'not-allowed';

      if (el.classList.contains('hold-toggle-btn') || el.tagName === 'BUTTON') {
        el.disabled = true;
      }
    });

    // Keep table scroll active
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = 'auto';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  function unlockParentActions() {
    // Reset everything
    document.querySelectorAll('.main-panel *, .sidebar *').forEach(function (el) {
      el.style.pointerEvents = '';
      el.style.opacity = '';
      el.style.filter = '';
      el.style.cursor = '';
      if (el.classList.contains('hold-toggle-btn') || el.tagName === 'BUTTON') {
        el.disabled = false;
      }
    });

    // Restore table scroll
    var tableResponsive = document.querySelector('.table-responsive');
    if (tableResponsive) {
      tableResponsive.style.pointerEvents = '';
      tableResponsive.style.overflow = '';
    }
    var table = document.getElementById('order-listing');
    if (table) {
      table.style.pointerEvents = '';
    }
  }

  // Listen for modal open/close
  var closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");

  // Lock parent when any view or Add Jig is clicked
  document.querySelectorAll('.tray-scan-btn-Jig, .open-jig-modal-btn').forEach(function(link) {
    link.addEventListener('click', function() {
      setTimeout(lockParentActions, 100);
    });
  });

  // Unlock when tray scan modal closes
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }

  // Also unlock when Add Jig modal closes (if you have a close button)
  var addJigClose = document.querySelector('#rightSideModal .close, #rightSideModal [data-bs-dismiss="modal"]');
  if (addJigClose) {
    addJigClose.addEventListener('click', function() {
      setTimeout(unlockParentActions, 200);
    });
  }
});
</script>


<script nonce="{{ csp_nonce }}">
document.addEventListener('DOMContentLoaded', function() {
  const slider = document.getElementById('modelSliderDynamic');
  const prevBtn = document.querySelector('.model-slider-wrapper .prev-btn');
  const nextBtn = document.querySelector('.model-slider-wrapper .next-btn');
  const container = document.querySelector('.model-slider-container');
  let currentIndex = 0;

  function getItemWidth() {
    const first = slider.children[0];
    if (!first) return 180;
    const style = window.getComputedStyle(first);
    const width = first.offsetWidth;
    const marginRight = parseInt(style.marginRight) || 0;
    return width + marginRight;
  }

  function updateSlider() {
    const totalItems = slider.children.length;
    const itemWidth = getItemWidth();
    // Always scroll one card at a time, like a gallery
    if (currentIndex < 0) currentIndex = 0;
    if (currentIndex > totalItems - 1) currentIndex = totalItems - 1;

    slider.style.transform = `translateX(-${currentIndex * itemWidth}px)`;

    // Show arrows if more than 1 card
    prevBtn.style.display = totalItems > 1 && currentIndex > 0 ? 'block' : 'none';
    nextBtn.style.display = totalItems > 1 && currentIndex < totalItems - 1 ? 'block' : 'none';
  }

  prevBtn.addEventListener('click', function() {
    currentIndex--;
    updateSlider();
  });

  nextBtn.addEventListener('click', function() {
    currentIndex++;
    updateSlider();
  });

  window.addEventListener('resize', updateSlider);

  setTimeout(updateSlider, 400);
});
</script>

<!-- Add this helper function to your script block (once, near your other helpers) -->
<script nonce="{{ csp_nonce }}">
function showAutoSaveInfo(enabled = true) {
  // Remove any existing info
  const existing = document.getElementById('autosave-info-toast');
  if (existing) existing.remove();

  const toast = document.createElement('div');
  toast.id = 'autosave-info-toast';
  toast.style.cssText = `
    position: fixed;
    top: 18px;
    right: 24px;
    background: ${enabled ? '#028084' : '#b30000'};
    color: #fff;
    padding: 10px 22px;
    border-radius: 8px;
    font-size: 15px;
    font-weight: 600;
    z-index: 99999;
    box-shadow: 0 2px 8px rgba(0,0,0,0.12);
    animation: fadeIn 0.5s;
    pointer-events: none;
  `;
  toast.textContent = enabled ? "Auto-save enabled" : "Auto-save disabled";
  document.body.appendChild(toast);

  // Hide after 2.5 seconds
  setTimeout(() => {
    toast.style.opacity = '0';
    setTimeout(() => toast.remove(), 400);
  }, 2500);

}
</script>


<script nonce="{{ csp_nonce }}">
// Lightweight autosave shim â€” only defines minimal API if missing
(function(){
  function getCookie(name) {
    const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
    return v ? v.pop() : '';
  }

  // Use existing collectModalData if present, otherwise build a tiny fallback
  async function buildPayload() {
    // Prefer an existing collector if present
    if (typeof collectModalData === 'function') {
      try { return await collectModalData(); } catch(e){ console.warn('collectModalData error', e); }
    }

    const modal = document.getElementById('rightSideModal') || document.getElementById('uploadChildModal');
    const lot_id = modal?.dataset?.currentLotId || modal?.getAttribute('data-current-lot-id') || '';

    // helper: collect delink tray ids from DOM structure used in templates
    function collectDelinkFromDOM() {
      try {
        const table = document.getElementById('delinkTrayTable');
        if (!table) return [];
        const items = [];
        // tray-table uses header then pairs of cells; prefer inputs when present
        const inputs = table.querySelectorAll('input[type="text"]');
        if (inputs && inputs.length) {
          inputs.forEach(inp => {
            const id = (inp.value || '').trim();
            const lid = inp.getAttribute('data-lot-id') || lot_id || '';
            if (id) items.push({ tray_id: id, lot_id: lid, expected_usage: parseInt(inp.getAttribute('data-expected-usage')) || 0 });
          });
          return items;
        }
        // fallback: read text cells
        const children = Array.from(table.children || []);
        for (let i = 0; i < children.length; i++) {
          const text = (children[i].textContent || '').trim();
          if (!text || /s\.?no|tray/i.test(text)) continue;
          if (text.length > 2 && text.indexOf('Scan Tray ID') === -1) {
            items.push({ tray_id: text, lot_id: lot_id });
          }
        }
        return items;
      } catch (err) { console.warn('collectDelinkFromDOM error', err); return []; }
    }

    function collectHalfFilledFromDOM() {
      try {
        const table = document.getElementById('halfFilledTrayTable');
        if (!table) return [];
        const items = [];
        const inputs = table.querySelectorAll('input[type="text"]');
        const qtys = table.querySelectorAll('input[type="number"]');
        if (inputs && inputs.length) {
          for (let i = 0; i < inputs.length; i++) {
            const id = (inputs[i].value || '').trim();
            const qty = parseInt((qtys[i] && (qtys[i].value || qtys[i].textContent)) || 0) || 0;
            const lid = inputs[i].getAttribute('data-lot-id') || lot_id || '';
            if (id || qty) items.push({ tray_id: id, quantity: qty, lot_id: lid });
          }
          return items;
        }
        // fallback: cell-based parse (pairs)
        const children = Array.from(table.children || []);
        for (let i = 0; i < children.length; i += 2) {
          const idCell = children[i];
          const qtyCell = children[i + 1];
          const tray_id = (idCell?.textContent || '').trim();
          const qtext = (qtyCell?.textContent || qtyCell?.value || '').trim();
          const quantity = parseInt(qtext.replace(/[^\d\-]/g, '')) || 0;
          if (tray_id || quantity > 0) items.push({ tray_id, quantity, lot_id });
        }
        return items;
      } catch (err) { console.warn('collectHalfFilledFromDOM error', err); return []; }
    }

    function collectLotIdQuantitiesFromDOM() {
      try {
        if (window.currentLotIdQuantities && typeof window.currentLotIdQuantities === 'object') {
          return window.currentLotIdQuantities;
        }
        const obj = {};
        if (modal) {
          const primaryLot = modal.getAttribute('data-current-lot-id') || modal?.dataset?.currentLotId || lot_id;
          const v = document.getElementById('modalLotQty')?.value || document.getElementById('modalLotQty')?.textContent || '';
          const qty = parseInt((v || '').toString().replace(/[^\d]/g, '')) || 0;
          if (primaryLot) obj[primaryLot] = qty;
        }
        return obj;
      } catch (err) { console.warn('collectLotIdQuantitiesFromDOM error', err); return {}; }
    }

    function collectSelectedModelNosFromDOM() {
      try {
        const models = [];
        document.querySelectorAll('#modelSliderDynamic .model-loaded-item .model-no-label, .model-loaded-item .model-no-label').forEach(el => {
          const t = (el.textContent || '').trim();
          if (t) models.push(t);
        });
        if (!models.length) {
          const header = document.getElementById('rightModalModelNo') || document.getElementById('modalModelNo');
          const txt = header?.textContent?.trim();
          if (txt && txt !== '-') txt.split(',').map(s=>s.trim()).forEach(x=>{ if(x) models.push(x); });
        }
        return Array.from(new Set(models));
      } catch (err) { console.warn('collectSelectedModelNosFromDOM error', err); return []; }
    }

    const payload = {
      lot_id: String(lot_id || ''),
      jig_qr_id: (document.getElementById('modalJigQrId')?.value || '').trim(),
      faulty_slots: parseInt(document.getElementById('modalFaultySlots')?.value || '0',10)||0,
      empty_slots: parseInt(document.getElementById('modalEmptySlots')?.value || '0',10)||0,
      total_cases_loaded: parseInt(document.getElementById('modalLotQty')?.value || '0',10)||0,
      delink_tray_data: collectDelinkFromDOM(),
      half_filled_tray_data: collectHalfFilledFromDOM(),
      lot_id_quantities: collectLotIdQuantitiesFromDOM(),
      selected_model_nos: collectSelectedModelNosFromDOM(),
      no_of_cycle_count: (document.getElementById('cycleCount')?.textContent || '-/-').trim()
    };

    return payload;
  }

  // saveModalData: post to existing endpoint â€” only define if not already present
  if (typeof window.saveModalData !== 'function') {
    window.saveModalData = async function() {
      try {
        const payload = await buildPayload();
        if (!payload || !payload.lot_id) return null;
        const res = await fetch('/jig_loading/autosave/', {
          method: 'POST',
          credentials: 'same-origin',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(payload)
        });
        let json = null;
        try { json = await res.json(); } catch(e){ /* ignore non-json */ }
        if (json && json.success) window.dispatchEvent(new CustomEvent('autosave-success', { detail: json }));
        else window.dispatchEvent(new CustomEvent('autosave-error', { detail: json || { status: res.status } }));
        return json;
      } catch (err) {
        console.warn('saveModalData error', err);
        window.dispatchEvent(new CustomEvent('autosave-error', { detail: { error: err.message || err } }));
        return null;
      }
    };
  }

  // triggerAutoSave: debounce wrapper â€” define only if not already present
  if (typeof window.triggerAutoSave !== 'function') {
    window.autoSaveTimer = null;
    window.triggerAutoSave = function(immediate){
      if (immediate) {
        if (window.saveModalData) window.saveModalData().catch(()=>{});
        return;
      }
      if (window.autoSaveTimer) clearTimeout(window.autoSaveTimer);
      window.autoSaveTimer = setTimeout(()=> {
        if (window.saveModalData) window.saveModalData().catch(()=>{});
      }, 900);
    };
  }

  // restore helpers used by other scripts â€” define non-destructively
  if (typeof window.restoreDelinkTrayData !== 'function') {
    window.restoreDelinkTrayData = function(trayData){
      try {
        const delinkTable = document.getElementById('delinkTrayTable');
        if (!delinkTable || !Array.isArray(trayData)) return;
        // remove existing rows beyond headers
        const children = Array.from(delinkTable.children || []);
        for (let i = children.length - 1; i >= 2; i--) children[i].remove();
        trayData.forEach((t, idx) => {
          const sno = document.createElement('div'); sno.textContent = (idx+1).toString();
          const tray = document.createElement('div'); tray.textContent = t.tray_id || t.trayId || '';
          delinkTable.appendChild(sno);
          delinkTable.appendChild(tray);
        });
      } catch(e){ console.warn('restoreDelinkTrayData failed', e); }
    };
  }

  if (typeof window.restoreHalfFilledTrayData !== 'function') {
    window.restoreHalfFilledTrayData = function(trayData){
      try {
        const halfTable = document.getElementById('halfFilledTrayTable');
        if (!halfTable || !Array.isArray(trayData)) return;
        const section = document.getElementById('halfFilledTraySection');
        if (section) section.style.display = 'block';
        const children = Array.from(halfTable.children || []);
        for (let i = children.length - 1; i >= 2; i--) children[i].remove();
        trayData.forEach((t) => {
          const idCell = document.createElement('div'); idCell.textContent = t.tray_id || t.trayId || '';
          const qtyCell = document.createElement('div'); qtyCell.textContent = String(t.quantity ?? t.tray_quantity ?? 0);
          halfTable.appendChild(idCell);
          halfTable.appendChild(qtyCell);
        });
      } catch(e){ console.warn('restoreHalfFilledTrayData failed', e); }
    };
  }

})();
</script>


<script nonce="{{ csp_nonce }}">
// Lightweight autosave shim â€” only defines minimal API if missing
(function(){
  function getCookie(name) {
    const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
    return v ? v.pop() : '';
  }

  // Use existing collectModalData if present, otherwise build a tiny fallback
  async function buildPayload() {
    // Prefer an existing collector if present
    if (typeof collectModalData === 'function') {
      try { return await collectModalData(); } catch(e){ console.warn('collectModalData error', e); }
    }

    const modal = document.getElementById('rightSideModal') || document.getElementById('uploadChildModal');
    const lot_id = modal?.dataset?.currentLotId || modal?.getAttribute('data-current-lot-id') || '';

    // helper: collect delink tray ids from DOM structure used in templates
    function collectDelinkFromDOM() {
      try {
        const table = document.getElementById('delinkTrayTable');
        if (!table) return [];
        const items = [];
        // tray-table uses header then pairs of cells; prefer inputs when present
        const inputs = table.querySelectorAll('input[type="text"]');
        if (inputs && inputs.length) {
          inputs.forEach(inp => {
            const id = (inp.value || '').trim();
            const lid = inp.getAttribute('data-lot-id') || lot_id || '';
            if (id) items.push({ tray_id: id, lot_id: lid, expected_usage: parseInt(inp.getAttribute('data-expected-usage')) || 0 });
          });
          return items;
        }
        // fallback: read text cells
        const children = Array.from(table.children || []);
        for (let i = 0; i < children.length; i++) {
          const text = (children[i].textContent || '').trim();
          if (!text || /s\.?no|tray/i.test(text)) continue;
          if (text.length > 2 && text.indexOf('Scan Tray ID') === -1) {
            items.push({ tray_id: text, lot_id: lot_id });
          }
        }
        return items;
      } catch (err) { console.warn('collectDelinkFromDOM error', err); return []; }
    }

    function collectHalfFilledFromDOM() {
      try {
        const table = document.getElementById('halfFilledTrayTable');
        if (!table) return [];
        const items = [];
        const inputs = table.querySelectorAll('input[type="text"]');
        const qtys = table.querySelectorAll('input[type="number"]');
        if (inputs && inputs.length) {
          for (let i = 0; i < inputs.length; i++) {
            const id = (inputs[i].value || '').trim();
            const qty = parseInt((qtys[i] && (qtys[i].value || qtys[i].textContent)) || 0) || 0;
            const lid = inputs[i].getAttribute('data-lot-id') || lot_id || '';
            if (id || qty) items.push({ tray_id: id, quantity: qty, lot_id: lid });
          }
          return items;
        }
        // fallback: cell-based parse (pairs)
        const children = Array.from(table.children || []);
        for (let i = 0; i < children.length; i += 2) {
          const idCell = children[i];
          const qtyCell = children[i + 1];
          const tray_id = (idCell?.textContent || '').trim();
          const qtext = (qtyCell?.textContent || qtyCell?.value || '').trim();
          const quantity = parseInt(qtext.replace(/[^\d\-]/g, '')) || 0;
          if (tray_id || quantity > 0) items.push({ tray_id, quantity, lot_id });
        }
        return items;
      } catch (err) { console.warn('collectHalfFilledFromDOM error', err); return []; }
    }

    function collectLotIdQuantitiesFromDOM() {
      try {
        if (window.currentLotIdQuantities && typeof window.currentLotIdQuantities === 'object') {
          return window.currentLotIdQuantities;
        }
        const obj = {};
        if (modal) {
          const primaryLot = modal.getAttribute('data-current-lot-id') || modal?.dataset?.currentLotId || lot_id;
          const v = document.getElementById('modalLotQty')?.value || document.getElementById('modalLotQty')?.textContent || '';
          const qty = parseInt((v || '').toString().replace(/[^\d]/g, '')) || 0;
          if (primaryLot) obj[primaryLot] = qty;
        }
        return obj;
      } catch (err) { console.warn('collectLotIdQuantitiesFromDOM error', err); return {}; }
    }

    function collectSelectedModelNosFromDOM() {
      try {
        const models = [];
        document.querySelectorAll('#modelSliderDynamic .model-loaded-item .model-no-label, .model-loaded-item .model-no-label').forEach(el => {
          const t = (el.textContent || '').trim();
          if (t) models.push(t);
        });
        if (!models.length) {
          const header = document.getElementById('rightModalModelNo') || document.getElementById('modalModelNo');
          const txt = header?.textContent?.trim();
          if (txt && txt !== '-') txt.split(',').map(s=>s.trim()).forEach(x=>{ if(x) models.push(x); });
        }
        return Array.from(new Set(models));
      } catch (err) { console.warn('collectSelectedModelNosFromDOM error', err); return []; }
    }

    const payload = {
      lot_id: String(lot_id || ''),
      jig_qr_id: (document.getElementById('modalJigQrId')?.value || '').trim(),
      faulty_slots: parseInt(document.getElementById('modalFaultySlots')?.value || '0',10)||0,
      empty_slots: parseInt(document.getElementById('modalEmptySlots')?.value || '0',10)||0,
      total_cases_loaded: parseInt(document.getElementById('modalLotQty')?.value || '0',10)||0,
      delink_tray_data: collectDelinkFromDOM(),
      half_filled_tray_data: collectHalfFilledFromDOM(),
      lot_id_quantities: collectLotIdQuantitiesFromDOM(),
      selected_model_nos: collectSelectedModelNosFromDOM(),
      no_of_cycle_count: (document.getElementById('cycleCount')?.textContent || '-/-').trim()
    };

    return payload;
  }

  // saveModalData: post to existing endpoint â€” only define if not already present
  if (typeof window.saveModalData !== 'function') {
    window.saveModalData = async function() {
      try {
        const payload = await buildPayload();
        if (!payload || !payload.lot_id) return null;
        const res = await fetch('/jig_loading/autosave/', {
          method: 'POST',
          credentials: '-origin',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(payload)
        });
        let json = null;
        try { json = await res.json(); } catch(e){ /* ignore non-json */ }
        if (json && json.success) window.dispatchEvent(new CustomEvent('autosave-success', { detail: json }));
        else window.dispatchEvent(new CustomEvent('autosave-error', { detail: json || { status: res.status } }));
        return json;
      } catch (err) {
        console.warn('saveModalData error', err);
        window.dispatchEvent(new CustomEvent('autosave-error', { detail: { error: err.message || err } }));
        return null;
      }
    };
  }

  // triggerAutoSave: debounce wrapper â€” define only if not already present
  if (typeof window.triggerAutoSave !== 'function') {
    window.autoSaveTimer = null;
    window.triggerAutoSave = function(immediate){
      if (immediate) {
        if (window.saveModalData) window.saveModalData().catch(()=>{});
        return;
      }
      if (window.autoSaveTimer) clearTimeout(window.autoSaveTimer);
      window.autoSaveTimer = setTimeout(()=> {
        if (window.saveModalData) window.saveModalData().catch(()=>{});
      }, 900);
    };
  }

  // restore helpers used by other scripts â€” define non-destructively
  if (typeof window.restoreDelinkTrayData !== 'function') {
    window.restoreDelinkTrayData = function(trayData){
      try {
        const delinkTable = document.getElementById('delinkTrayTable');
        if (!delinkTable || !Array.isArray(trayData)) return;
        // remove existing rows beyond headers
        const children = Array.from(delinkTable.children || []);
        for (let i = children.length - 1; i >= 2; i--) children[i].remove();
        trayData.forEach((t, idx) => {
          const sno = document.createElement('div'); sno.textContent = (idx+1).toString();
          const tray = document.createElement('div'); tray.textContent = t.tray_id || t.trayId || '';
          delinkTable.appendChild(sno);
          delinkTable.appendChild(tray);
        });
      } catch(e){ console.warn('restoreDelinkTrayData failed', e); }
    };
  }

  if (typeof window.restoreHalfFilledTrayData !== 'function') {
    window.restoreHalfFilledTrayData = function(trayData){
      try {
        const halfTable = document.getElementById('halfFilledTrayTable');
        if (!halfTable || !Array.isArray(trayData)) return;
        const section = document.getElementById('halfFilledTraySection');
        if (section) section.style.display = 'block';
        const children = Array.from(halfTable.children || []);
        for (let i = children.length - 1; i >= 2; i--) children[i].remove();
        trayData.forEach((t) => {
          const idCell = document.createElement('div'); idCell.textContent = t.tray_id || t.trayId || '';
          const qtyCell = document.createElement('div'); qtyCell.textContent = String(t.quantity ?? t.tray_quantity ?? 0);
          halfTable.appendChild(idCell);
          halfTable.appendChild(qtyCell);
        });
      } catch(e){ console.warn('restoreHalfFilledTrayData failed', e); }
    };
  }

})();
</script>


<script nonce="{{ csp_nonce }}">
   function getCookie(name) {
     let cookieValue = null;
     if (document.cookie && document.cookie !== '') {
       const cookies = document.cookie.split(';');
       for (let i = 0; i < cookies.length; i++) {
         const cookie = cookies[i].trim();
         if (cookie.substring(0, name.length + 1) === (name + '=')) {
           cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
           break;
         }
       }
     }
     return cookieValue;
   }

   function autoSaveTrayData(lotId, trays, halfTrays) {
     fetch("/jig/autosave/", {
       method: "POST",
       headers: {
         "Content-Type": "application/json",
         "X-CSRFToken": getCookie("csrftoken"),
       },
       body: JSON.stringify({
         lot_id: lotId,
         delink_tray_data: trays,
         half_filled_tray_data: halfTrays,
       }),
     });
   }

   // Hook into modal close
   $('#trayScanModal').on('hide.bs.modal', function () {
     const lotId = $("#currentLotId").val();   // make sure you have a hidden input with id=currentLotId
     const trays = collectTrayInputs();        // implement this to read delink tray table
     showTrayIdsInViewModal(trays);
     viewButton.setAttribute('title', trayTitle);
     const halfTrays = collectHalfTrayInputs();// implement this to read half tray table
     autoSaveTrayData(lotId, trays, halfTrays);
   });

   // ===== JIG ID VALIDATION SYSTEM =====
   let jigValidationTimeout;

   function validateJigId(jigId, lotId) {
     return fetch('/jig_loading/validate_jig_id_and_type/', {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
         'X-CSRFToken': getCookie('csrftoken')
       },
       body: JSON.stringify({
         jig_qr_id: jigId,
         lot_id: lotId
       })
     })
     .then(response => response.json())
     .catch(error => {
       console.error('Validation error:', error);
       return { valid: false, error: 'Network error occurred' };
     });
   }

   function showJigValidationStatus(isValid, message) {
     const statusDiv = document.getElementById('jigValidationStatus');
     const messageSpan = document.getElementById('jigValidationMessage');
     const jigInput = document.getElementById('modalJigQrId');
     
     if (!statusDiv || !messageSpan || !jigInput) return;

     statusDiv.style.display = 'block';
     messageSpan.textContent = message;
     
     // Clear previous styles
     jigInput.style.borderColor = '';
     jigInput.style.backgroundColor = '';
     
     if (isValid) {
       messageSpan.style.color = '#007bff';
       jigInput.style.borderColor = '#007bff';
       jigInput.style.backgroundColor = '#e7f3ff';
     } else {
       messageSpan.style.color = '#dc3545';
       jigInput.style.borderColor = '#dc3545';
       jigInput.style.backgroundColor = '#fff8f8';
     }
   }

document.addEventListener('DOMContentLoaded', function() {
  const closeBtn = document.getElementById('closeJigValidationStatusBtn');
  const statusDiv = document.getElementById('jigValidationStatus');
  if (closeBtn && statusDiv) {
    closeBtn.addEventListener('click', function() {
      statusDiv.style.display = 'none';
    });
  }
});

function showJigValidationAlerts(response) {
    // response: { valid, message, error, jig_type, jig_qr_id, model_no }
    const statusDiv = document.getElementById('jigValidationStatus');
    const messageSpan = document.getElementById('jigValidationMessage');
    if (!statusDiv || !messageSpan) return;

    // Scenario 2: If error is a jig type mismatch, show ONLY the error
    if (response.error && response.error.includes('Jig type mismatch')) {
        statusDiv.style.display = 'block';
        messageSpan.textContent = response.error;
        messageSpan.style.color = '#dc3545';
        return;
    }

    // Scenario 1: Combine "Jig ID is available" and "valid for jig type" as a single alert
    if (response.message && response.message.startsWith('âœ“ Jig ID') && response.valid) {
        statusDiv.style.display = 'block';
        messageSpan.innerHTML = `Jig ID is available &<br>Jig ID - "${response.jig_qr_id}" is valid for jig type "${response.jig_type}"`;
        messageSpan.style.color = '#28a745';
        return;
    }

    // Default: Show message if valid
    if (response.message && response.valid) {
        statusDiv.style.display = 'block';
        messageSpan.textContent = response.message;
        messageSpan.style.color = '#28a745';
        return;
    }

    // Otherwise, hide
    statusDiv.style.display = 'none';
}




   function hideJigValidationStatus() {
     const statusDiv = document.getElementById('jigValidationStatus');
     const jigInput = document.getElementById('modalJigQrId');
     
     if (statusDiv) statusDiv.style.display = 'none';
     if (jigInput) {
       jigInput.style.borderColor = '';
       jigInput.style.backgroundColor = '';
     }
   }

   // Add event listener to Jig ID input for real-time validation
   document.addEventListener('DOMContentLoaded', function() {
     const jigInput = document.getElementById('modalJigQrId');


     
     
     if (jigInput) {
       jigInput.addEventListener('input', function() {
         const jigId = this.value.trim().toUpperCase();
         
         // Clear previous timeout
         if (jigValidationTimeout) {
           clearTimeout(jigValidationTimeout);
         }
         
         // Hide validation if input is empty
         if (!jigId) {
           hideJigValidationStatus();
           return;
         }
         
         // Set timeout for validation (debounce)
         jigValidationTimeout = setTimeout(() => {
           const lotId = getCurrentLotId(); // Get current lot ID
           
           if (!lotId) {
             showJigValidationStatus(false, 'Please select a lot first');
             return;
           }
           
           // Show loading
           showJigValidationStatus(false, 'Validating...');
           
           // Validate Jig ID
           validateJigId(jigId, lotId)
             .then(result => {
               if (result.valid) {
                 showJigValidationStatus(true, result.message);
               } else {
                 showJigValidationStatus(false, result.error);
               }
             });
         }, 500); // Wait 500ms after user stops typing
       });
       
       // Also validate on blur (when user leaves the field)
       jigInput.addEventListener('blur', function() {
         const jigId = this.value.trim().toUpperCase();
         if (jigId) {
           this.value = jigId; // Set uppercase value
         }
       });
     }
   });

   // Helper function to get current lot ID
   function getCurrentLotId() {
     // Try different ways to get the current lot ID
     const modalLotId = window.currentLotId || 
                       document.getElementById('currentLotId')?.value ||
                       document.querySelector('[data-stock-lot-id]')?.getAttribute('data-stock-lot-id');
     return modalLotId;
   }
</script>


<!-- Small unobtrusive script to keep the "Total Trays" value in sync with dynamic content.
     This does not change existing logic â€” it only observes DOM changes and updates count & sanitizes cell classes. -->
<script nonce="{{ csp_nonce }}">
document.addEventListener('DOMContentLoaded', function () {
  const trayTable = document.getElementById('delinkTrayTable');
  if (!trayTable) return;

  const totalEl = document.getElementById('delinkTrayTotalCount');  // Add this line for the total count element

  // Determine whether an element should be hidden (UI-only)
  function isSerialOrHeaderNode(node) {
    if (!node || !node.textContent) return false;
    const txt = node.textContent.trim();
    if (!txt) return false;
    const lower = txt.toLowerCase();

    // exact header matches
    if (lower === 's.no' || lower === 's.no.' || lower === 'sno' || lower === 'tray id' || lower === 'trayid') {
      return true;
    }

    // purely numeric serials (e.g. "1", "2", "3")
    if (/^[0-9]+$/.test(txt)) return true;

    // sometimes header may be "S.No" with extra whitespace or punctuation
    if (/^s[\W_]*no\.?$/i.test(txt)) return true;

    return false;
  }

  function markSerialCellsHidden() {
    Array.from(trayTable.children).forEach(child => {
      // only operate on direct children (UI-only)
      const candidate = child;
      if (!candidate) return;

      // if node already intentionally styled/marked, skip
      if (candidate.classList.contains('ui-hidden')) return;

      // check text-only nodes or nodes whose inner text equals header/serial
      // prefer checking immediate textContent (handles simple grid cells rendered server-side)
      if (isSerialOrHeaderNode(candidate)) {
        candidate.classList.add('ui-hidden');
        return;
      }

      // if the element contains a single text node or only short numeric text inside a child,
      // check first child as fallback (helps when server wraps text)
      const firstChild = candidate.firstElementChild;
      if (firstChild && isSerialOrHeaderNode(firstChild)) {
        candidate.classList.add('ui-hidden');
        return;
      }

      // If the element contains an input but the label/placeholder child is a short number,
      // hide the parent only when the element has no input (safety check)
      const hasInput = !!candidate.querySelector('input[type="text"], input[type="number"], .tray-input');
      if (!hasInput && /^\d+$/.test(candidate.textContent.trim())) {
        candidate.classList.add('ui-hidden');
        return;
      }
    });

  }

    // Add the updateTotalCount function here (right after markSerialCellsHidden)
  function updateTotalCount() {
    try {
      const trayInputs = trayTable.querySelectorAll('input[type="text"], input[type="number"], .tray-input');
      const count = trayInputs.length;  // Count allocated tray slots, not filled IDs
      if (totalEl) totalEl.textContent = count;
    } catch (e) {
      console.warn('refreshDelinkTrayCount error', e);
    }
  }

  // Run once now (handles server-rendered structure)
  markSerialCellsHidden();

  // Observe future changes (injection by existing scripts) and hide serials non-destructively
  const mo = new MutationObserver((mutations) => {
    // debounce
    if (mo._t) clearTimeout(mo._t);
    mo._t = setTimeout(() => {
      markSerialCellsHidden();
      updateTotalCount();// Add this call to update the count on changes
    }, 100);
  });
  mo.observe(trayTable, { childList: true, subtree: true, characterData: true });

  // expose manual refresh (safe API)
  window.refreshDelinkUiHide = markSerialCellsHidden;
});
</script>



<script nonce="{{ csp_nonce }}">
// Sync model slider background class (bg-1..bg-5) to delink tray cells (non-destructive)
(function(){
  function getBgClassFromModel(item){
    if(!item) return null;
    // model-loaded-item already uses classes like bg-1 .. bg-5
    return Array.from(item.classList).find(c=>/^bg-\d+$/.test(c)) || null;
  }

  function syncModelTrayBg(){
    const map = {};
    // build lotId -> bgClass map from slider items
    document.querySelectorAll('.model-loaded-item').forEach(item=>{
      const lot = item.getAttribute('data-lot-id') || item.dataset.lotId || item.getAttribute('data-lotid');
      const bg = getBgClassFromModel(item);
      if(lot && bg) map[String(lot)] = bg;
    });

    const trayTable = document.getElementById('delinkTrayTable');
    if(!trayTable) return;

    // For each direct child cell, apply matching bg class when lot match found.
    Array.from(trayTable.children).forEach(cell=>{
      try {
        // find the input inside cell if present (most templates put input inside a div)
        const input = cell.querySelector && cell.querySelector('input[type="text"], input[type="number"]');
        const lot = (input && (input.getAttribute('data-lot-id') || input.dataset.lotId)) || cell.getAttribute('data-lot-id') || cell.dataset.lotId;
        if(lot && map[String(lot)]) {
          const bgClass = map[String(lot)];
          // remove any previous bg-N classes we may have added
          Array.from(cell.classList).forEach(c=>{
            if(/^bg-\d+$/.test(c)) cell.classList.remove(c);
          });
          // add same class used by model item (non-destructive)
          cell.classList.add(bgClass);
        }
      } catch(e){ /* safe-ignore */ }
    });
  }

  document.addEventListener('DOMContentLoaded', function(){
    // initial sync
    syncModelTrayBg();

    // observe changes in slider and tray table so colors stay in sync dynamically
    const slider = document.querySelector('.model-slider');
    const trayTable = document.getElementById('delinkTrayTable');

    const obsCallback = function() {
      // small debounce
      if (obsCallback._t) clearTimeout(obsCallback._t);
      obsCallback._t = setTimeout(syncModelTrayBg, 80);
    };

    if(slider) new MutationObserver(obsCallback).observe(slider, { childList:true, subtree:true, attributes:true });
    if(trayTable) new MutationObserver(obsCallback).observe(trayTable, { childList:true, subtree:true, attributes:true });

    // expose manual refresh API
    window.syncModelTrayBg = syncModelTrayBg;
  });
})();
</script>



{% endblock %}
{% endblock content %}